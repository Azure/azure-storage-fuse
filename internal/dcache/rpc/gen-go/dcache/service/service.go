/*
    _____           _____   _____   ____          ______  _____  ------
   |     |  |      |     | |     | |     |     | |       |            |
   |     |  |      |     | |     | |     |     | |       |            |
   | --- |  |      |     | |-----| |---- |     | |-----| |-----  ------
   |     |  |      |     | |     | |     |     |       | |       |
   | ____|  |_____ | ____| | ____| |     |_____|  _____| |_____  |_____


   Licensed under the MIT License <http://opensource.org/licenses/MIT>.

   Copyright Â© 2020-2025 Microsoft Corporation. All rights reserved.
   Author : <blobfusedev@microsoft.com>

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE
*/

// Code generated by Thrift Compiler (0.16.0). DO NOT EDIT.

package service

import (
	"bytes"
	"context"
	"fmt"
	"github.com/Azure/azure-storage-fuse/v2/internal/dcache/rpc/gen-go/dcache/models"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"time"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

var _ = models.GoUnusedProtection__

type ChunkService interface {
	// Parameters:
	//  - Request
	Hello(ctx context.Context, request *models.HelloRequest) (_r *models.HelloResponse, _err error)
	// Parameters:
	//  - Request
	GetChunk(ctx context.Context, request *models.GetChunkRequest) (_r *models.GetChunkResponse, _err error)
	// Parameters:
	//  - Request
	PutChunk(ctx context.Context, request *models.PutChunkRequest) (_r *models.PutChunkResponse, _err error)
	// Parameters:
	//  - Request
	RemoveChunk(ctx context.Context, request *models.RemoveChunkRequest) (_r *models.RemoveChunkResponse, _err error)
	// Parameters:
	//  - Request
	JoinMV(ctx context.Context, request *models.JoinMVRequest) (_r *models.JoinMVResponse, _err error)
	// Parameters:
	//  - Request
	UpdateMV(ctx context.Context, request *models.UpdateMVRequest) (_r *models.UpdateMVResponse, _err error)
	// Parameters:
	//  - Request
	LeaveMV(ctx context.Context, request *models.LeaveMVRequest) (_r *models.LeaveMVResponse, _err error)
	// Parameters:
	//  - Request
	StartSync(ctx context.Context, request *models.StartSyncRequest) (_r *models.StartSyncResponse, _err error)
	// Parameters:
	//  - Request
	EndSync(ctx context.Context, request *models.EndSyncRequest) (_r *models.EndSyncResponse, _err error)
	// Parameters:
	//  - Request
	GetMVSize(ctx context.Context, request *models.GetMVSizeRequest) (_r *models.GetMVSizeResponse, _err error)
}

type ChunkServiceClient struct {
	c    thrift.TClient
	meta thrift.ResponseMeta
}

func NewChunkServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ChunkServiceClient {
	return &ChunkServiceClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewChunkServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ChunkServiceClient {
	return &ChunkServiceClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewChunkServiceClient(c thrift.TClient) *ChunkServiceClient {
	return &ChunkServiceClient{
		c: c,
	}
}

func (p *ChunkServiceClient) Client_() thrift.TClient {
	return p.c
}

func (p *ChunkServiceClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *ChunkServiceClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) Hello(ctx context.Context, request *models.HelloRequest) (_r *models.HelloResponse, _err error) {
	var _args0 ChunkServiceHelloArgs
	_args0.Request = request
	var _result2 ChunkServiceHelloResult
	var _meta1 thrift.ResponseMeta
	_meta1, _err = p.Client_().Call(ctx, "Hello", &_args0, &_result2)
	p.SetLastResponseMeta_(_meta1)
	if _err != nil {
		return
	}
	switch {
	case _result2.Err != nil:
		return _r, _result2.Err
	}

	if _ret3 := _result2.GetSuccess(); _ret3 != nil {
		return _ret3, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "Hello failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) GetChunk(ctx context.Context, request *models.GetChunkRequest) (_r *models.GetChunkResponse, _err error) {
	var _args4 ChunkServiceGetChunkArgs
	_args4.Request = request
	var _result6 ChunkServiceGetChunkResult
	var _meta5 thrift.ResponseMeta
	_meta5, _err = p.Client_().Call(ctx, "GetChunk", &_args4, &_result6)
	p.SetLastResponseMeta_(_meta5)
	if _err != nil {
		return
	}
	switch {
	case _result6.Err != nil:
		return _r, _result6.Err
	}

	if _ret7 := _result6.GetSuccess(); _ret7 != nil {
		return _ret7, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "GetChunk failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) PutChunk(ctx context.Context, request *models.PutChunkRequest) (_r *models.PutChunkResponse, _err error) {
	var _args8 ChunkServicePutChunkArgs
	_args8.Request = request
	var _result10 ChunkServicePutChunkResult
	var _meta9 thrift.ResponseMeta
	_meta9, _err = p.Client_().Call(ctx, "PutChunk", &_args8, &_result10)
	p.SetLastResponseMeta_(_meta9)
	if _err != nil {
		return
	}
	switch {
	case _result10.Err != nil:
		return _r, _result10.Err
	}

	if _ret11 := _result10.GetSuccess(); _ret11 != nil {
		return _ret11, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "PutChunk failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) RemoveChunk(ctx context.Context, request *models.RemoveChunkRequest) (_r *models.RemoveChunkResponse, _err error) {
	var _args12 ChunkServiceRemoveChunkArgs
	_args12.Request = request
	var _result14 ChunkServiceRemoveChunkResult
	var _meta13 thrift.ResponseMeta
	_meta13, _err = p.Client_().Call(ctx, "RemoveChunk", &_args12, &_result14)
	p.SetLastResponseMeta_(_meta13)
	if _err != nil {
		return
	}
	switch {
	case _result14.Err != nil:
		return _r, _result14.Err
	}

	if _ret15 := _result14.GetSuccess(); _ret15 != nil {
		return _ret15, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "RemoveChunk failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) JoinMV(ctx context.Context, request *models.JoinMVRequest) (_r *models.JoinMVResponse, _err error) {
	var _args16 ChunkServiceJoinMVArgs
	_args16.Request = request
	var _result18 ChunkServiceJoinMVResult
	var _meta17 thrift.ResponseMeta
	_meta17, _err = p.Client_().Call(ctx, "JoinMV", &_args16, &_result18)
	p.SetLastResponseMeta_(_meta17)
	if _err != nil {
		return
	}
	switch {
	case _result18.Err != nil:
		return _r, _result18.Err
	}

	if _ret19 := _result18.GetSuccess(); _ret19 != nil {
		return _ret19, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "JoinMV failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) UpdateMV(ctx context.Context, request *models.UpdateMVRequest) (_r *models.UpdateMVResponse, _err error) {
	var _args20 ChunkServiceUpdateMVArgs
	_args20.Request = request
	var _result22 ChunkServiceUpdateMVResult
	var _meta21 thrift.ResponseMeta
	_meta21, _err = p.Client_().Call(ctx, "UpdateMV", &_args20, &_result22)
	p.SetLastResponseMeta_(_meta21)
	if _err != nil {
		return
	}
	switch {
	case _result22.Err != nil:
		return _r, _result22.Err
	}

	if _ret23 := _result22.GetSuccess(); _ret23 != nil {
		return _ret23, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "UpdateMV failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) LeaveMV(ctx context.Context, request *models.LeaveMVRequest) (_r *models.LeaveMVResponse, _err error) {
	var _args24 ChunkServiceLeaveMVArgs
	_args24.Request = request
	var _result26 ChunkServiceLeaveMVResult
	var _meta25 thrift.ResponseMeta
	_meta25, _err = p.Client_().Call(ctx, "LeaveMV", &_args24, &_result26)
	p.SetLastResponseMeta_(_meta25)
	if _err != nil {
		return
	}
	switch {
	case _result26.Err != nil:
		return _r, _result26.Err
	}

	if _ret27 := _result26.GetSuccess(); _ret27 != nil {
		return _ret27, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "LeaveMV failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) StartSync(ctx context.Context, request *models.StartSyncRequest) (_r *models.StartSyncResponse, _err error) {
	var _args28 ChunkServiceStartSyncArgs
	_args28.Request = request
	var _result30 ChunkServiceStartSyncResult
	var _meta29 thrift.ResponseMeta
	_meta29, _err = p.Client_().Call(ctx, "StartSync", &_args28, &_result30)
	p.SetLastResponseMeta_(_meta29)
	if _err != nil {
		return
	}
	switch {
	case _result30.Err != nil:
		return _r, _result30.Err
	}

	if _ret31 := _result30.GetSuccess(); _ret31 != nil {
		return _ret31, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "StartSync failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) EndSync(ctx context.Context, request *models.EndSyncRequest) (_r *models.EndSyncResponse, _err error) {
	var _args32 ChunkServiceEndSyncArgs
	_args32.Request = request
	var _result34 ChunkServiceEndSyncResult
	var _meta33 thrift.ResponseMeta
	_meta33, _err = p.Client_().Call(ctx, "EndSync", &_args32, &_result34)
	p.SetLastResponseMeta_(_meta33)
	if _err != nil {
		return
	}
	switch {
	case _result34.Err != nil:
		return _r, _result34.Err
	}

	if _ret35 := _result34.GetSuccess(); _ret35 != nil {
		return _ret35, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "EndSync failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) GetMVSize(ctx context.Context, request *models.GetMVSizeRequest) (_r *models.GetMVSizeResponse, _err error) {
	var _args36 ChunkServiceGetMVSizeArgs
	_args36.Request = request
	var _result38 ChunkServiceGetMVSizeResult
	var _meta37 thrift.ResponseMeta
	_meta37, _err = p.Client_().Call(ctx, "GetMVSize", &_args36, &_result38)
	p.SetLastResponseMeta_(_meta37)
	if _err != nil {
		return
	}
	switch {
	case _result38.Err != nil:
		return _r, _result38.Err
	}

	if _ret39 := _result38.GetSuccess(); _ret39 != nil {
		return _ret39, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "GetMVSize failed: unknown result")
}

type ChunkServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      ChunkService
}

func (p *ChunkServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ChunkServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ChunkServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewChunkServiceProcessor(handler ChunkService) *ChunkServiceProcessor {

	self40 := &ChunkServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self40.processorMap["Hello"] = &chunkServiceProcessorHello{handler: handler}
	self40.processorMap["GetChunk"] = &chunkServiceProcessorGetChunk{handler: handler}
	self40.processorMap["PutChunk"] = &chunkServiceProcessorPutChunk{handler: handler}
	self40.processorMap["RemoveChunk"] = &chunkServiceProcessorRemoveChunk{handler: handler}
	self40.processorMap["JoinMV"] = &chunkServiceProcessorJoinMV{handler: handler}
	self40.processorMap["UpdateMV"] = &chunkServiceProcessorUpdateMV{handler: handler}
	self40.processorMap["LeaveMV"] = &chunkServiceProcessorLeaveMV{handler: handler}
	self40.processorMap["StartSync"] = &chunkServiceProcessorStartSync{handler: handler}
	self40.processorMap["EndSync"] = &chunkServiceProcessorEndSync{handler: handler}
	self40.processorMap["GetMVSize"] = &chunkServiceProcessorGetMVSize{handler: handler}
	return self40
}

func (p *ChunkServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil {
		return false, thrift.WrapTException(err2)
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x41 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x41.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x41

}

type chunkServiceProcessorHello struct {
	handler ChunkService
}

func (p *chunkServiceProcessorHello) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ChunkServiceHelloArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "Hello", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceHelloResult{}
	var retval *models.HelloResponse
	if retval, err2 = p.handler.Hello(ctx, args.Request); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Hello: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "Hello", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "Hello", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type chunkServiceProcessorGetChunk struct {
	handler ChunkService
}

func (p *chunkServiceProcessorGetChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ChunkServiceGetChunkArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "GetChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceGetChunkResult{}
	var retval *models.GetChunkResponse
	if retval, err2 = p.handler.GetChunk(ctx, args.Request); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetChunk: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "GetChunk", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "GetChunk", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type chunkServiceProcessorPutChunk struct {
	handler ChunkService
}

func (p *chunkServiceProcessorPutChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ChunkServicePutChunkArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "PutChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServicePutChunkResult{}
	var retval *models.PutChunkResponse
	if retval, err2 = p.handler.PutChunk(ctx, args.Request); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing PutChunk: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "PutChunk", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "PutChunk", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type chunkServiceProcessorRemoveChunk struct {
	handler ChunkService
}

func (p *chunkServiceProcessorRemoveChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ChunkServiceRemoveChunkArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "RemoveChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceRemoveChunkResult{}
	var retval *models.RemoveChunkResponse
	if retval, err2 = p.handler.RemoveChunk(ctx, args.Request); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing RemoveChunk: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "RemoveChunk", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "RemoveChunk", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type chunkServiceProcessorJoinMV struct {
	handler ChunkService
}

func (p *chunkServiceProcessorJoinMV) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ChunkServiceJoinMVArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "JoinMV", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceJoinMVResult{}
	var retval *models.JoinMVResponse
	if retval, err2 = p.handler.JoinMV(ctx, args.Request); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing JoinMV: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "JoinMV", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "JoinMV", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type chunkServiceProcessorUpdateMV struct {
	handler ChunkService
}

func (p *chunkServiceProcessorUpdateMV) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ChunkServiceUpdateMVArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "UpdateMV", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceUpdateMVResult{}
	var retval *models.UpdateMVResponse
	if retval, err2 = p.handler.UpdateMV(ctx, args.Request); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing UpdateMV: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "UpdateMV", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "UpdateMV", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type chunkServiceProcessorLeaveMV struct {
	handler ChunkService
}

func (p *chunkServiceProcessorLeaveMV) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ChunkServiceLeaveMVArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "LeaveMV", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceLeaveMVResult{}
	var retval *models.LeaveMVResponse
	if retval, err2 = p.handler.LeaveMV(ctx, args.Request); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing LeaveMV: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "LeaveMV", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "LeaveMV", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type chunkServiceProcessorStartSync struct {
	handler ChunkService
}

func (p *chunkServiceProcessorStartSync) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ChunkServiceStartSyncArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "StartSync", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceStartSyncResult{}
	var retval *models.StartSyncResponse
	if retval, err2 = p.handler.StartSync(ctx, args.Request); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing StartSync: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "StartSync", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "StartSync", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type chunkServiceProcessorEndSync struct {
	handler ChunkService
}

func (p *chunkServiceProcessorEndSync) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ChunkServiceEndSyncArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "EndSync", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceEndSyncResult{}
	var retval *models.EndSyncResponse
	if retval, err2 = p.handler.EndSync(ctx, args.Request); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing EndSync: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "EndSync", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "EndSync", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type chunkServiceProcessorGetMVSize struct {
	handler ChunkService
}

func (p *chunkServiceProcessorGetMVSize) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ChunkServiceGetMVSizeArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "GetMVSize", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceGetMVSizeResult{}
	var retval *models.GetMVSizeResponse
	if retval, err2 = p.handler.GetMVSize(ctx, args.Request); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetMVSize: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "GetMVSize", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "GetMVSize", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//   - Request
type ChunkServiceHelloArgs struct {
	Request *models.HelloRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceHelloArgs() *ChunkServiceHelloArgs {
	return &ChunkServiceHelloArgs{}
}

var ChunkServiceHelloArgs_Request_DEFAULT *models.HelloRequest

func (p *ChunkServiceHelloArgs) GetRequest() *models.HelloRequest {
	if !p.IsSetRequest() {
		return ChunkServiceHelloArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceHelloArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceHelloArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceHelloArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.HelloRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceHelloArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Hello_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceHelloArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceHelloArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceHelloArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceHelloResult struct {
	Success *models.HelloResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceHelloResult() *ChunkServiceHelloResult {
	return &ChunkServiceHelloResult{}
}

var ChunkServiceHelloResult_Success_DEFAULT *models.HelloResponse

func (p *ChunkServiceHelloResult) GetSuccess() *models.HelloResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceHelloResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceHelloResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceHelloResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceHelloResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceHelloResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceHelloResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceHelloResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceHelloResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.HelloResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceHelloResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceHelloResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Hello_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceHelloResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceHelloResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceHelloResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceHelloResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceGetChunkArgs struct {
	Request *models.GetChunkRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceGetChunkArgs() *ChunkServiceGetChunkArgs {
	return &ChunkServiceGetChunkArgs{}
}

var ChunkServiceGetChunkArgs_Request_DEFAULT *models.GetChunkRequest

func (p *ChunkServiceGetChunkArgs) GetRequest() *models.GetChunkRequest {
	if !p.IsSetRequest() {
		return ChunkServiceGetChunkArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceGetChunkArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceGetChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceGetChunkArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.GetChunkRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceGetChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetChunk_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceGetChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceGetChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceGetChunkArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceGetChunkResult struct {
	Success *models.GetChunkResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError    `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceGetChunkResult() *ChunkServiceGetChunkResult {
	return &ChunkServiceGetChunkResult{}
}

var ChunkServiceGetChunkResult_Success_DEFAULT *models.GetChunkResponse

func (p *ChunkServiceGetChunkResult) GetSuccess() *models.GetChunkResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceGetChunkResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceGetChunkResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceGetChunkResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceGetChunkResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceGetChunkResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceGetChunkResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceGetChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceGetChunkResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.GetChunkResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceGetChunkResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceGetChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetChunk_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceGetChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceGetChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceGetChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceGetChunkResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServicePutChunkArgs struct {
	Request *models.PutChunkRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServicePutChunkArgs() *ChunkServicePutChunkArgs {
	return &ChunkServicePutChunkArgs{}
}

var ChunkServicePutChunkArgs_Request_DEFAULT *models.PutChunkRequest

func (p *ChunkServicePutChunkArgs) GetRequest() *models.PutChunkRequest {
	if !p.IsSetRequest() {
		return ChunkServicePutChunkArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServicePutChunkArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServicePutChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServicePutChunkArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.PutChunkRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServicePutChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "PutChunk_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServicePutChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServicePutChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServicePutChunkArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServicePutChunkResult struct {
	Success *models.PutChunkResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError    `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServicePutChunkResult() *ChunkServicePutChunkResult {
	return &ChunkServicePutChunkResult{}
}

var ChunkServicePutChunkResult_Success_DEFAULT *models.PutChunkResponse

func (p *ChunkServicePutChunkResult) GetSuccess() *models.PutChunkResponse {
	if !p.IsSetSuccess() {
		return ChunkServicePutChunkResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServicePutChunkResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServicePutChunkResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServicePutChunkResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServicePutChunkResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServicePutChunkResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServicePutChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServicePutChunkResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.PutChunkResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServicePutChunkResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServicePutChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "PutChunk_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServicePutChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServicePutChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServicePutChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServicePutChunkResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceRemoveChunkArgs struct {
	Request *models.RemoveChunkRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceRemoveChunkArgs() *ChunkServiceRemoveChunkArgs {
	return &ChunkServiceRemoveChunkArgs{}
}

var ChunkServiceRemoveChunkArgs_Request_DEFAULT *models.RemoveChunkRequest

func (p *ChunkServiceRemoveChunkArgs) GetRequest() *models.RemoveChunkRequest {
	if !p.IsSetRequest() {
		return ChunkServiceRemoveChunkArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceRemoveChunkArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceRemoveChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.RemoveChunkRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "RemoveChunk_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceRemoveChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceRemoveChunkArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceRemoveChunkResult struct {
	Success *models.RemoveChunkResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError       `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceRemoveChunkResult() *ChunkServiceRemoveChunkResult {
	return &ChunkServiceRemoveChunkResult{}
}

var ChunkServiceRemoveChunkResult_Success_DEFAULT *models.RemoveChunkResponse

func (p *ChunkServiceRemoveChunkResult) GetSuccess() *models.RemoveChunkResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceRemoveChunkResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceRemoveChunkResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceRemoveChunkResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceRemoveChunkResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceRemoveChunkResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceRemoveChunkResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceRemoveChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.RemoveChunkResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "RemoveChunk_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceRemoveChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceRemoveChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceRemoveChunkResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceJoinMVArgs struct {
	Request *models.JoinMVRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceJoinMVArgs() *ChunkServiceJoinMVArgs {
	return &ChunkServiceJoinMVArgs{}
}

var ChunkServiceJoinMVArgs_Request_DEFAULT *models.JoinMVRequest

func (p *ChunkServiceJoinMVArgs) GetRequest() *models.JoinMVRequest {
	if !p.IsSetRequest() {
		return ChunkServiceJoinMVArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceJoinMVArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceJoinMVArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceJoinMVArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.JoinMVRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceJoinMVArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "JoinMV_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceJoinMVArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceJoinMVArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceJoinMVArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceJoinMVResult struct {
	Success *models.JoinMVResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError  `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceJoinMVResult() *ChunkServiceJoinMVResult {
	return &ChunkServiceJoinMVResult{}
}

var ChunkServiceJoinMVResult_Success_DEFAULT *models.JoinMVResponse

func (p *ChunkServiceJoinMVResult) GetSuccess() *models.JoinMVResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceJoinMVResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceJoinMVResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceJoinMVResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceJoinMVResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceJoinMVResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceJoinMVResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceJoinMVResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceJoinMVResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.JoinMVResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceJoinMVResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceJoinMVResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "JoinMV_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceJoinMVResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceJoinMVResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceJoinMVResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceJoinMVResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceUpdateMVArgs struct {
	Request *models.UpdateMVRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceUpdateMVArgs() *ChunkServiceUpdateMVArgs {
	return &ChunkServiceUpdateMVArgs{}
}

var ChunkServiceUpdateMVArgs_Request_DEFAULT *models.UpdateMVRequest

func (p *ChunkServiceUpdateMVArgs) GetRequest() *models.UpdateMVRequest {
	if !p.IsSetRequest() {
		return ChunkServiceUpdateMVArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceUpdateMVArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceUpdateMVArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.UpdateMVRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "UpdateMV_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceUpdateMVArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceUpdateMVArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceUpdateMVResult struct {
	Success *models.UpdateMVResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError    `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceUpdateMVResult() *ChunkServiceUpdateMVResult {
	return &ChunkServiceUpdateMVResult{}
}

var ChunkServiceUpdateMVResult_Success_DEFAULT *models.UpdateMVResponse

func (p *ChunkServiceUpdateMVResult) GetSuccess() *models.UpdateMVResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceUpdateMVResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceUpdateMVResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceUpdateMVResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceUpdateMVResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceUpdateMVResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceUpdateMVResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceUpdateMVResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.UpdateMVResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "UpdateMV_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceUpdateMVResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceUpdateMVResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceUpdateMVResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceLeaveMVArgs struct {
	Request *models.LeaveMVRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceLeaveMVArgs() *ChunkServiceLeaveMVArgs {
	return &ChunkServiceLeaveMVArgs{}
}

var ChunkServiceLeaveMVArgs_Request_DEFAULT *models.LeaveMVRequest

func (p *ChunkServiceLeaveMVArgs) GetRequest() *models.LeaveMVRequest {
	if !p.IsSetRequest() {
		return ChunkServiceLeaveMVArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceLeaveMVArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceLeaveMVArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.LeaveMVRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "LeaveMV_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceLeaveMVArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceLeaveMVArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceLeaveMVResult struct {
	Success *models.LeaveMVResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError   `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceLeaveMVResult() *ChunkServiceLeaveMVResult {
	return &ChunkServiceLeaveMVResult{}
}

var ChunkServiceLeaveMVResult_Success_DEFAULT *models.LeaveMVResponse

func (p *ChunkServiceLeaveMVResult) GetSuccess() *models.LeaveMVResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceLeaveMVResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceLeaveMVResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceLeaveMVResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceLeaveMVResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceLeaveMVResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceLeaveMVResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceLeaveMVResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.LeaveMVResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "LeaveMV_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceLeaveMVResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceLeaveMVResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceLeaveMVResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceStartSyncArgs struct {
	Request *models.StartSyncRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceStartSyncArgs() *ChunkServiceStartSyncArgs {
	return &ChunkServiceStartSyncArgs{}
}

var ChunkServiceStartSyncArgs_Request_DEFAULT *models.StartSyncRequest

func (p *ChunkServiceStartSyncArgs) GetRequest() *models.StartSyncRequest {
	if !p.IsSetRequest() {
		return ChunkServiceStartSyncArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceStartSyncArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceStartSyncArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceStartSyncArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.StartSyncRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceStartSyncArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "StartSync_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceStartSyncArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceStartSyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceStartSyncArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceStartSyncResult struct {
	Success *models.StartSyncResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError     `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceStartSyncResult() *ChunkServiceStartSyncResult {
	return &ChunkServiceStartSyncResult{}
}

var ChunkServiceStartSyncResult_Success_DEFAULT *models.StartSyncResponse

func (p *ChunkServiceStartSyncResult) GetSuccess() *models.StartSyncResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceStartSyncResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceStartSyncResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceStartSyncResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceStartSyncResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceStartSyncResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceStartSyncResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceStartSyncResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceStartSyncResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.StartSyncResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceStartSyncResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceStartSyncResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "StartSync_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceStartSyncResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceStartSyncResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceStartSyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceStartSyncResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceEndSyncArgs struct {
	Request *models.EndSyncRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceEndSyncArgs() *ChunkServiceEndSyncArgs {
	return &ChunkServiceEndSyncArgs{}
}

var ChunkServiceEndSyncArgs_Request_DEFAULT *models.EndSyncRequest

func (p *ChunkServiceEndSyncArgs) GetRequest() *models.EndSyncRequest {
	if !p.IsSetRequest() {
		return ChunkServiceEndSyncArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceEndSyncArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceEndSyncArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceEndSyncArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.EndSyncRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceEndSyncArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "EndSync_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceEndSyncArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceEndSyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceEndSyncArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceEndSyncResult struct {
	Success *models.EndSyncResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError   `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceEndSyncResult() *ChunkServiceEndSyncResult {
	return &ChunkServiceEndSyncResult{}
}

var ChunkServiceEndSyncResult_Success_DEFAULT *models.EndSyncResponse

func (p *ChunkServiceEndSyncResult) GetSuccess() *models.EndSyncResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceEndSyncResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceEndSyncResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceEndSyncResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceEndSyncResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceEndSyncResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceEndSyncResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceEndSyncResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceEndSyncResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.EndSyncResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceEndSyncResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceEndSyncResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "EndSync_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceEndSyncResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceEndSyncResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceEndSyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceEndSyncResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceGetMVSizeArgs struct {
	Request *models.GetMVSizeRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceGetMVSizeArgs() *ChunkServiceGetMVSizeArgs {
	return &ChunkServiceGetMVSizeArgs{}
}

var ChunkServiceGetMVSizeArgs_Request_DEFAULT *models.GetMVSizeRequest

func (p *ChunkServiceGetMVSizeArgs) GetRequest() *models.GetMVSizeRequest {
	if !p.IsSetRequest() {
		return ChunkServiceGetMVSizeArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceGetMVSizeArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceGetMVSizeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.GetMVSizeRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetMVSize_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceGetMVSizeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceGetMVSizeArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceGetMVSizeResult struct {
	Success *models.GetMVSizeResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError     `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceGetMVSizeResult() *ChunkServiceGetMVSizeResult {
	return &ChunkServiceGetMVSizeResult{}
}

var ChunkServiceGetMVSizeResult_Success_DEFAULT *models.GetMVSizeResponse

func (p *ChunkServiceGetMVSizeResult) GetSuccess() *models.GetMVSizeResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceGetMVSizeResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceGetMVSizeResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceGetMVSizeResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceGetMVSizeResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceGetMVSizeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceGetMVSizeResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceGetMVSizeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.GetMVSizeResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetMVSize_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceGetMVSizeResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceGetMVSizeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceGetMVSizeResult(%+v)", *p)
}
