/*
    _____           _____   _____   ____          ______  _____  ------
   |     |  |      |     | |     | |     |     | |       |            |
   |     |  |      |     | |     | |     |     | |       |            |
   | --- |  |      |     | |-----| |---- |     | |-----| |-----  ------
   |     |  |      |     | |     | |     |     |       | |       |
   | ____|  |_____ | ____| | ____| |     |_____|  _____| |_____  |_____


   Licensed under the MIT License <http://opensource.org/licenses/MIT>.

   Copyright Â© 2020-2025 Microsoft Corporation. All rights reserved.
   Author : <blobfusedev@microsoft.com>

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE
*/

// Code generated by Thrift Compiler (0.19.0). DO NOT EDIT.

package service

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-storage-fuse/v2/internal/dcache/rpc/gen-go/dcache/models"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"regexp"
	"strings"
	"time"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = errors.New
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

// (needed by validator.)
var _ = strings.Contains
var _ = regexp.MatchString

var _ = models.GoUnusedProtection__

type ChunkService interface {
	// Parameters:
	//  - Request
	Hello(ctx context.Context, request *models.HelloRequest) (_r *models.HelloResponse, _err error)
	// Parameters:
	//  - Request
	GetChunk(ctx context.Context, request *models.GetChunkRequest) (_r *models.GetChunkResponse, _err error)
	// Parameters:
	//  - Request
	PutChunk(ctx context.Context, request *models.PutChunkRequest) (_r *models.PutChunkResponse, _err error)
	// Parameters:
	//  - Request
	PutChunkDC(ctx context.Context, request *models.PutChunkDCRequest) (_r *models.PutChunkDCResponse, _err error)
	// Parameters:
	//  - Request
	RemoveChunk(ctx context.Context, request *models.RemoveChunkRequest) (_r *models.RemoveChunkResponse, _err error)
	// Parameters:
	//  - Request
	JoinMV(ctx context.Context, request *models.JoinMVRequest) (_r *models.JoinMVResponse, _err error)
	// Parameters:
	//  - Request
	UpdateMV(ctx context.Context, request *models.UpdateMVRequest) (_r *models.UpdateMVResponse, _err error)
	// Parameters:
	//  - Request
	LeaveMV(ctx context.Context, request *models.LeaveMVRequest) (_r *models.LeaveMVResponse, _err error)
	// Parameters:
	//  - Request
	GetMVSize(ctx context.Context, request *models.GetMVSizeRequest) (_r *models.GetMVSizeResponse, _err error)
	// Parameters:
	//  - Request
	GetLogs(ctx context.Context, request *models.GetLogsRequest) (_r *models.GetLogsResponse, _err error)
}

type ChunkServiceClient struct {
	c    thrift.TClient
	meta thrift.ResponseMeta
}

func NewChunkServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ChunkServiceClient {
	return &ChunkServiceClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewChunkServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ChunkServiceClient {
	return &ChunkServiceClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewChunkServiceClient(c thrift.TClient) *ChunkServiceClient {
	return &ChunkServiceClient{
		c: c,
	}
}

func (p *ChunkServiceClient) Client_() thrift.TClient {
	return p.c
}

func (p *ChunkServiceClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *ChunkServiceClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) Hello(ctx context.Context, request *models.HelloRequest) (_r *models.HelloResponse, _err error) {
	var _args0 ChunkServiceHelloArgs
	_args0.Request = request
	var _result2 ChunkServiceHelloResult
	var _meta1 thrift.ResponseMeta
	_meta1, _err = p.Client_().Call(ctx, "Hello", &_args0, &_result2)
	p.SetLastResponseMeta_(_meta1)
	if _err != nil {
		return
	}
	switch {
	case _result2.Err != nil:
		return _r, _result2.Err
	}

	if _ret3 := _result2.GetSuccess(); _ret3 != nil {
		return _ret3, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "Hello failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) GetChunk(ctx context.Context, request *models.GetChunkRequest) (_r *models.GetChunkResponse, _err error) {
	var _args4 ChunkServiceGetChunkArgs
	_args4.Request = request
	var _result6 ChunkServiceGetChunkResult
	var _meta5 thrift.ResponseMeta
	_meta5, _err = p.Client_().Call(ctx, "GetChunk", &_args4, &_result6)
	p.SetLastResponseMeta_(_meta5)
	if _err != nil {
		return
	}
	switch {
	case _result6.Err != nil:
		return _r, _result6.Err
	}

	if _ret7 := _result6.GetSuccess(); _ret7 != nil {
		return _ret7, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "GetChunk failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) PutChunk(ctx context.Context, request *models.PutChunkRequest) (_r *models.PutChunkResponse, _err error) {
	var _args8 ChunkServicePutChunkArgs
	_args8.Request = request
	var _result10 ChunkServicePutChunkResult
	var _meta9 thrift.ResponseMeta
	_meta9, _err = p.Client_().Call(ctx, "PutChunk", &_args8, &_result10)
	p.SetLastResponseMeta_(_meta9)
	if _err != nil {
		return
	}
	switch {
	case _result10.Err != nil:
		return _r, _result10.Err
	}

	if _ret11 := _result10.GetSuccess(); _ret11 != nil {
		return _ret11, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "PutChunk failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) PutChunkDC(ctx context.Context, request *models.PutChunkDCRequest) (_r *models.PutChunkDCResponse, _err error) {
	var _args12 ChunkServicePutChunkDCArgs
	_args12.Request = request
	var _result14 ChunkServicePutChunkDCResult
	var _meta13 thrift.ResponseMeta
	_meta13, _err = p.Client_().Call(ctx, "PutChunkDC", &_args12, &_result14)
	p.SetLastResponseMeta_(_meta13)
	if _err != nil {
		return
	}
	switch {
	case _result14.Err != nil:
		return _r, _result14.Err
	}

	if _ret15 := _result14.GetSuccess(); _ret15 != nil {
		return _ret15, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "PutChunkDC failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) RemoveChunk(ctx context.Context, request *models.RemoveChunkRequest) (_r *models.RemoveChunkResponse, _err error) {
	var _args16 ChunkServiceRemoveChunkArgs
	_args16.Request = request
	var _result18 ChunkServiceRemoveChunkResult
	var _meta17 thrift.ResponseMeta
	_meta17, _err = p.Client_().Call(ctx, "RemoveChunk", &_args16, &_result18)
	p.SetLastResponseMeta_(_meta17)
	if _err != nil {
		return
	}
	switch {
	case _result18.Err != nil:
		return _r, _result18.Err
	}

	if _ret19 := _result18.GetSuccess(); _ret19 != nil {
		return _ret19, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "RemoveChunk failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) JoinMV(ctx context.Context, request *models.JoinMVRequest) (_r *models.JoinMVResponse, _err error) {
	var _args20 ChunkServiceJoinMVArgs
	_args20.Request = request
	var _result22 ChunkServiceJoinMVResult
	var _meta21 thrift.ResponseMeta
	_meta21, _err = p.Client_().Call(ctx, "JoinMV", &_args20, &_result22)
	p.SetLastResponseMeta_(_meta21)
	if _err != nil {
		return
	}
	switch {
	case _result22.Err != nil:
		return _r, _result22.Err
	}

	if _ret23 := _result22.GetSuccess(); _ret23 != nil {
		return _ret23, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "JoinMV failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) UpdateMV(ctx context.Context, request *models.UpdateMVRequest) (_r *models.UpdateMVResponse, _err error) {
	var _args24 ChunkServiceUpdateMVArgs
	_args24.Request = request
	var _result26 ChunkServiceUpdateMVResult
	var _meta25 thrift.ResponseMeta
	_meta25, _err = p.Client_().Call(ctx, "UpdateMV", &_args24, &_result26)
	p.SetLastResponseMeta_(_meta25)
	if _err != nil {
		return
	}
	switch {
	case _result26.Err != nil:
		return _r, _result26.Err
	}

	if _ret27 := _result26.GetSuccess(); _ret27 != nil {
		return _ret27, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "UpdateMV failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) LeaveMV(ctx context.Context, request *models.LeaveMVRequest) (_r *models.LeaveMVResponse, _err error) {
	var _args28 ChunkServiceLeaveMVArgs
	_args28.Request = request
	var _result30 ChunkServiceLeaveMVResult
	var _meta29 thrift.ResponseMeta
	_meta29, _err = p.Client_().Call(ctx, "LeaveMV", &_args28, &_result30)
	p.SetLastResponseMeta_(_meta29)
	if _err != nil {
		return
	}
	switch {
	case _result30.Err != nil:
		return _r, _result30.Err
	}

	if _ret31 := _result30.GetSuccess(); _ret31 != nil {
		return _ret31, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "LeaveMV failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) GetMVSize(ctx context.Context, request *models.GetMVSizeRequest) (_r *models.GetMVSizeResponse, _err error) {
	var _args32 ChunkServiceGetMVSizeArgs
	_args32.Request = request
	var _result34 ChunkServiceGetMVSizeResult
	var _meta33 thrift.ResponseMeta
	_meta33, _err = p.Client_().Call(ctx, "GetMVSize", &_args32, &_result34)
	p.SetLastResponseMeta_(_meta33)
	if _err != nil {
		return
	}
	switch {
	case _result34.Err != nil:
		return _r, _result34.Err
	}

	if _ret35 := _result34.GetSuccess(); _ret35 != nil {
		return _ret35, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "GetMVSize failed: unknown result")
}

// Parameters:
//   - Request
func (p *ChunkServiceClient) GetLogs(ctx context.Context, request *models.GetLogsRequest) (_r *models.GetLogsResponse, _err error) {
	var _args36 ChunkServiceGetLogsArgs
	_args36.Request = request
	var _result38 ChunkServiceGetLogsResult
	var _meta37 thrift.ResponseMeta
	_meta37, _err = p.Client_().Call(ctx, "GetLogs", &_args36, &_result38)
	p.SetLastResponseMeta_(_meta37)
	if _err != nil {
		return
	}
	switch {
	case _result38.Err != nil:
		return _r, _result38.Err
	}

	if _ret39 := _result38.GetSuccess(); _ret39 != nil {
		return _ret39, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "GetLogs failed: unknown result")
}

type ChunkServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      ChunkService
}

func (p *ChunkServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ChunkServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ChunkServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewChunkServiceProcessor(handler ChunkService) *ChunkServiceProcessor {

	self40 := &ChunkServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self40.processorMap["Hello"] = &chunkServiceProcessorHello{handler: handler}
	self40.processorMap["GetChunk"] = &chunkServiceProcessorGetChunk{handler: handler}
	self40.processorMap["PutChunk"] = &chunkServiceProcessorPutChunk{handler: handler}
	self40.processorMap["PutChunkDC"] = &chunkServiceProcessorPutChunkDC{handler: handler}
	self40.processorMap["RemoveChunk"] = &chunkServiceProcessorRemoveChunk{handler: handler}
	self40.processorMap["JoinMV"] = &chunkServiceProcessorJoinMV{handler: handler}
	self40.processorMap["UpdateMV"] = &chunkServiceProcessorUpdateMV{handler: handler}
	self40.processorMap["LeaveMV"] = &chunkServiceProcessorLeaveMV{handler: handler}
	self40.processorMap["GetMVSize"] = &chunkServiceProcessorGetMVSize{handler: handler}
	self40.processorMap["GetLogs"] = &chunkServiceProcessorGetLogs{handler: handler}
	return self40
}

func (p *ChunkServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil {
		return false, thrift.WrapTException(err2)
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x41 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x41.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x41

}

type chunkServiceProcessorHello struct {
	handler ChunkService
}

func (p *chunkServiceProcessorHello) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err42 error
	args := ChunkServiceHelloArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "Hello", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceHelloResult{}
	if retval, err2 := p.handler.Hello(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc43 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Hello: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "Hello", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err42 = thrift.WrapTException(err2)
			}
			if err2 := _exc43.Write(ctx, oprot); _write_err42 == nil && err2 != nil {
				_write_err42 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err42 == nil && err2 != nil {
				_write_err42 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err42 == nil && err2 != nil {
				_write_err42 = thrift.WrapTException(err2)
			}
			if _write_err42 != nil {
				return false, thrift.WrapTException(_write_err42)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "Hello", thrift.REPLY, seqId); err2 != nil {
		_write_err42 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err42 == nil && err2 != nil {
		_write_err42 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err42 == nil && err2 != nil {
		_write_err42 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err42 == nil && err2 != nil {
		_write_err42 = thrift.WrapTException(err2)
	}
	if _write_err42 != nil {
		return false, thrift.WrapTException(_write_err42)
	}
	return true, err
}

type chunkServiceProcessorGetChunk struct {
	handler ChunkService
}

func (p *chunkServiceProcessorGetChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err44 error
	args := ChunkServiceGetChunkArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "GetChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceGetChunkResult{}
	if retval, err2 := p.handler.GetChunk(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc45 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetChunk: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "GetChunk", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err44 = thrift.WrapTException(err2)
			}
			if err2 := _exc45.Write(ctx, oprot); _write_err44 == nil && err2 != nil {
				_write_err44 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err44 == nil && err2 != nil {
				_write_err44 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err44 == nil && err2 != nil {
				_write_err44 = thrift.WrapTException(err2)
			}
			if _write_err44 != nil {
				return false, thrift.WrapTException(_write_err44)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "GetChunk", thrift.REPLY, seqId); err2 != nil {
		_write_err44 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err44 == nil && err2 != nil {
		_write_err44 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err44 == nil && err2 != nil {
		_write_err44 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err44 == nil && err2 != nil {
		_write_err44 = thrift.WrapTException(err2)
	}
	if _write_err44 != nil {
		return false, thrift.WrapTException(_write_err44)
	}
	return true, err
}

type chunkServiceProcessorPutChunk struct {
	handler ChunkService
}

func (p *chunkServiceProcessorPutChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err46 error
	args := ChunkServicePutChunkArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "PutChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServicePutChunkResult{}
	if retval, err2 := p.handler.PutChunk(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc47 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing PutChunk: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "PutChunk", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err46 = thrift.WrapTException(err2)
			}
			if err2 := _exc47.Write(ctx, oprot); _write_err46 == nil && err2 != nil {
				_write_err46 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err46 == nil && err2 != nil {
				_write_err46 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err46 == nil && err2 != nil {
				_write_err46 = thrift.WrapTException(err2)
			}
			if _write_err46 != nil {
				return false, thrift.WrapTException(_write_err46)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "PutChunk", thrift.REPLY, seqId); err2 != nil {
		_write_err46 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err46 == nil && err2 != nil {
		_write_err46 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err46 == nil && err2 != nil {
		_write_err46 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err46 == nil && err2 != nil {
		_write_err46 = thrift.WrapTException(err2)
	}
	if _write_err46 != nil {
		return false, thrift.WrapTException(_write_err46)
	}
	return true, err
}

type chunkServiceProcessorPutChunkDC struct {
	handler ChunkService
}

func (p *chunkServiceProcessorPutChunkDC) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err48 error
	args := ChunkServicePutChunkDCArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "PutChunkDC", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServicePutChunkDCResult{}
	if retval, err2 := p.handler.PutChunkDC(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc49 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing PutChunkDC: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "PutChunkDC", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err48 = thrift.WrapTException(err2)
			}
			if err2 := _exc49.Write(ctx, oprot); _write_err48 == nil && err2 != nil {
				_write_err48 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err48 == nil && err2 != nil {
				_write_err48 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err48 == nil && err2 != nil {
				_write_err48 = thrift.WrapTException(err2)
			}
			if _write_err48 != nil {
				return false, thrift.WrapTException(_write_err48)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "PutChunkDC", thrift.REPLY, seqId); err2 != nil {
		_write_err48 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err48 == nil && err2 != nil {
		_write_err48 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err48 == nil && err2 != nil {
		_write_err48 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err48 == nil && err2 != nil {
		_write_err48 = thrift.WrapTException(err2)
	}
	if _write_err48 != nil {
		return false, thrift.WrapTException(_write_err48)
	}
	return true, err
}

type chunkServiceProcessorRemoveChunk struct {
	handler ChunkService
}

func (p *chunkServiceProcessorRemoveChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err50 error
	args := ChunkServiceRemoveChunkArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "RemoveChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceRemoveChunkResult{}
	if retval, err2 := p.handler.RemoveChunk(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc51 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing RemoveChunk: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "RemoveChunk", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err50 = thrift.WrapTException(err2)
			}
			if err2 := _exc51.Write(ctx, oprot); _write_err50 == nil && err2 != nil {
				_write_err50 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err50 == nil && err2 != nil {
				_write_err50 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err50 == nil && err2 != nil {
				_write_err50 = thrift.WrapTException(err2)
			}
			if _write_err50 != nil {
				return false, thrift.WrapTException(_write_err50)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "RemoveChunk", thrift.REPLY, seqId); err2 != nil {
		_write_err50 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err50 == nil && err2 != nil {
		_write_err50 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err50 == nil && err2 != nil {
		_write_err50 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err50 == nil && err2 != nil {
		_write_err50 = thrift.WrapTException(err2)
	}
	if _write_err50 != nil {
		return false, thrift.WrapTException(_write_err50)
	}
	return true, err
}

type chunkServiceProcessorJoinMV struct {
	handler ChunkService
}

func (p *chunkServiceProcessorJoinMV) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err52 error
	args := ChunkServiceJoinMVArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "JoinMV", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceJoinMVResult{}
	if retval, err2 := p.handler.JoinMV(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc53 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing JoinMV: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "JoinMV", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err52 = thrift.WrapTException(err2)
			}
			if err2 := _exc53.Write(ctx, oprot); _write_err52 == nil && err2 != nil {
				_write_err52 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err52 == nil && err2 != nil {
				_write_err52 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err52 == nil && err2 != nil {
				_write_err52 = thrift.WrapTException(err2)
			}
			if _write_err52 != nil {
				return false, thrift.WrapTException(_write_err52)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "JoinMV", thrift.REPLY, seqId); err2 != nil {
		_write_err52 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err52 == nil && err2 != nil {
		_write_err52 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err52 == nil && err2 != nil {
		_write_err52 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err52 == nil && err2 != nil {
		_write_err52 = thrift.WrapTException(err2)
	}
	if _write_err52 != nil {
		return false, thrift.WrapTException(_write_err52)
	}
	return true, err
}

type chunkServiceProcessorUpdateMV struct {
	handler ChunkService
}

func (p *chunkServiceProcessorUpdateMV) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err54 error
	args := ChunkServiceUpdateMVArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "UpdateMV", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceUpdateMVResult{}
	if retval, err2 := p.handler.UpdateMV(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc55 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing UpdateMV: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "UpdateMV", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err54 = thrift.WrapTException(err2)
			}
			if err2 := _exc55.Write(ctx, oprot); _write_err54 == nil && err2 != nil {
				_write_err54 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err54 == nil && err2 != nil {
				_write_err54 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err54 == nil && err2 != nil {
				_write_err54 = thrift.WrapTException(err2)
			}
			if _write_err54 != nil {
				return false, thrift.WrapTException(_write_err54)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "UpdateMV", thrift.REPLY, seqId); err2 != nil {
		_write_err54 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err54 == nil && err2 != nil {
		_write_err54 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err54 == nil && err2 != nil {
		_write_err54 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err54 == nil && err2 != nil {
		_write_err54 = thrift.WrapTException(err2)
	}
	if _write_err54 != nil {
		return false, thrift.WrapTException(_write_err54)
	}
	return true, err
}

type chunkServiceProcessorLeaveMV struct {
	handler ChunkService
}

func (p *chunkServiceProcessorLeaveMV) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err56 error
	args := ChunkServiceLeaveMVArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "LeaveMV", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceLeaveMVResult{}
	if retval, err2 := p.handler.LeaveMV(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc57 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing LeaveMV: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "LeaveMV", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err56 = thrift.WrapTException(err2)
			}
			if err2 := _exc57.Write(ctx, oprot); _write_err56 == nil && err2 != nil {
				_write_err56 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err56 == nil && err2 != nil {
				_write_err56 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err56 == nil && err2 != nil {
				_write_err56 = thrift.WrapTException(err2)
			}
			if _write_err56 != nil {
				return false, thrift.WrapTException(_write_err56)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "LeaveMV", thrift.REPLY, seqId); err2 != nil {
		_write_err56 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err56 == nil && err2 != nil {
		_write_err56 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err56 == nil && err2 != nil {
		_write_err56 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err56 == nil && err2 != nil {
		_write_err56 = thrift.WrapTException(err2)
	}
	if _write_err56 != nil {
		return false, thrift.WrapTException(_write_err56)
	}
	return true, err
}

type chunkServiceProcessorGetMVSize struct {
	handler ChunkService
}

func (p *chunkServiceProcessorGetMVSize) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err58 error
	args := ChunkServiceGetMVSizeArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "GetMVSize", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceGetMVSizeResult{}
	if retval, err2 := p.handler.GetMVSize(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc59 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetMVSize: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "GetMVSize", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err58 = thrift.WrapTException(err2)
			}
			if err2 := _exc59.Write(ctx, oprot); _write_err58 == nil && err2 != nil {
				_write_err58 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err58 == nil && err2 != nil {
				_write_err58 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err58 == nil && err2 != nil {
				_write_err58 = thrift.WrapTException(err2)
			}
			if _write_err58 != nil {
				return false, thrift.WrapTException(_write_err58)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "GetMVSize", thrift.REPLY, seqId); err2 != nil {
		_write_err58 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err58 == nil && err2 != nil {
		_write_err58 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err58 == nil && err2 != nil {
		_write_err58 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err58 == nil && err2 != nil {
		_write_err58 = thrift.WrapTException(err2)
	}
	if _write_err58 != nil {
		return false, thrift.WrapTException(_write_err58)
	}
	return true, err
}

type chunkServiceProcessorGetLogs struct {
	handler ChunkService
}

func (p *chunkServiceProcessorGetLogs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err60 error
	args := ChunkServiceGetLogsArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "GetLogs", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ChunkServiceGetLogsResult{}
	if retval, err2 := p.handler.GetLogs(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *models.ResponseError:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc61 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetLogs: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "GetLogs", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err60 = thrift.WrapTException(err2)
			}
			if err2 := _exc61.Write(ctx, oprot); _write_err60 == nil && err2 != nil {
				_write_err60 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err60 == nil && err2 != nil {
				_write_err60 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err60 == nil && err2 != nil {
				_write_err60 = thrift.WrapTException(err2)
			}
			if _write_err60 != nil {
				return false, thrift.WrapTException(_write_err60)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "GetLogs", thrift.REPLY, seqId); err2 != nil {
		_write_err60 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err60 == nil && err2 != nil {
		_write_err60 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err60 == nil && err2 != nil {
		_write_err60 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err60 == nil && err2 != nil {
		_write_err60 = thrift.WrapTException(err2)
	}
	if _write_err60 != nil {
		return false, thrift.WrapTException(_write_err60)
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//   - Request
type ChunkServiceHelloArgs struct {
	Request *models.HelloRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceHelloArgs() *ChunkServiceHelloArgs {
	return &ChunkServiceHelloArgs{}
}

var ChunkServiceHelloArgs_Request_DEFAULT *models.HelloRequest

func (p *ChunkServiceHelloArgs) GetRequest() *models.HelloRequest {
	if !p.IsSetRequest() {
		return ChunkServiceHelloArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceHelloArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceHelloArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceHelloArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.HelloRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceHelloArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Hello_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceHelloArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceHelloArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceHelloArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceHelloResult struct {
	Success *models.HelloResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceHelloResult() *ChunkServiceHelloResult {
	return &ChunkServiceHelloResult{}
}

var ChunkServiceHelloResult_Success_DEFAULT *models.HelloResponse

func (p *ChunkServiceHelloResult) GetSuccess() *models.HelloResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceHelloResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceHelloResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceHelloResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceHelloResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceHelloResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceHelloResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceHelloResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceHelloResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.HelloResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceHelloResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceHelloResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Hello_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceHelloResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceHelloResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceHelloResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceHelloResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceGetChunkArgs struct {
	Request *models.GetChunkRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceGetChunkArgs() *ChunkServiceGetChunkArgs {
	return &ChunkServiceGetChunkArgs{}
}

var ChunkServiceGetChunkArgs_Request_DEFAULT *models.GetChunkRequest

func (p *ChunkServiceGetChunkArgs) GetRequest() *models.GetChunkRequest {
	if !p.IsSetRequest() {
		return ChunkServiceGetChunkArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceGetChunkArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceGetChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceGetChunkArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.GetChunkRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceGetChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetChunk_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceGetChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceGetChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceGetChunkArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceGetChunkResult struct {
	Success *models.GetChunkResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError    `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceGetChunkResult() *ChunkServiceGetChunkResult {
	return &ChunkServiceGetChunkResult{}
}

var ChunkServiceGetChunkResult_Success_DEFAULT *models.GetChunkResponse

func (p *ChunkServiceGetChunkResult) GetSuccess() *models.GetChunkResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceGetChunkResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceGetChunkResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceGetChunkResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceGetChunkResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceGetChunkResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceGetChunkResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceGetChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceGetChunkResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.GetChunkResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceGetChunkResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceGetChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetChunk_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceGetChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceGetChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceGetChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceGetChunkResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServicePutChunkArgs struct {
	Request *models.PutChunkRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServicePutChunkArgs() *ChunkServicePutChunkArgs {
	return &ChunkServicePutChunkArgs{}
}

var ChunkServicePutChunkArgs_Request_DEFAULT *models.PutChunkRequest

func (p *ChunkServicePutChunkArgs) GetRequest() *models.PutChunkRequest {
	if !p.IsSetRequest() {
		return ChunkServicePutChunkArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServicePutChunkArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServicePutChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServicePutChunkArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.PutChunkRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServicePutChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "PutChunk_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServicePutChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServicePutChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServicePutChunkArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServicePutChunkResult struct {
	Success *models.PutChunkResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError    `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServicePutChunkResult() *ChunkServicePutChunkResult {
	return &ChunkServicePutChunkResult{}
}

var ChunkServicePutChunkResult_Success_DEFAULT *models.PutChunkResponse

func (p *ChunkServicePutChunkResult) GetSuccess() *models.PutChunkResponse {
	if !p.IsSetSuccess() {
		return ChunkServicePutChunkResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServicePutChunkResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServicePutChunkResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServicePutChunkResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServicePutChunkResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServicePutChunkResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServicePutChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServicePutChunkResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.PutChunkResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServicePutChunkResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServicePutChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "PutChunk_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServicePutChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServicePutChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServicePutChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServicePutChunkResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServicePutChunkDCArgs struct {
	Request *models.PutChunkDCRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServicePutChunkDCArgs() *ChunkServicePutChunkDCArgs {
	return &ChunkServicePutChunkDCArgs{}
}

var ChunkServicePutChunkDCArgs_Request_DEFAULT *models.PutChunkDCRequest

func (p *ChunkServicePutChunkDCArgs) GetRequest() *models.PutChunkDCRequest {
	if !p.IsSetRequest() {
		return ChunkServicePutChunkDCArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServicePutChunkDCArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServicePutChunkDCArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServicePutChunkDCArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.PutChunkDCRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServicePutChunkDCArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "PutChunkDC_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServicePutChunkDCArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServicePutChunkDCArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServicePutChunkDCArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServicePutChunkDCResult struct {
	Success *models.PutChunkDCResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError      `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServicePutChunkDCResult() *ChunkServicePutChunkDCResult {
	return &ChunkServicePutChunkDCResult{}
}

var ChunkServicePutChunkDCResult_Success_DEFAULT *models.PutChunkDCResponse

func (p *ChunkServicePutChunkDCResult) GetSuccess() *models.PutChunkDCResponse {
	if !p.IsSetSuccess() {
		return ChunkServicePutChunkDCResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServicePutChunkDCResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServicePutChunkDCResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServicePutChunkDCResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServicePutChunkDCResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServicePutChunkDCResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServicePutChunkDCResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServicePutChunkDCResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.PutChunkDCResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServicePutChunkDCResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServicePutChunkDCResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "PutChunkDC_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServicePutChunkDCResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServicePutChunkDCResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServicePutChunkDCResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServicePutChunkDCResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceRemoveChunkArgs struct {
	Request *models.RemoveChunkRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceRemoveChunkArgs() *ChunkServiceRemoveChunkArgs {
	return &ChunkServiceRemoveChunkArgs{}
}

var ChunkServiceRemoveChunkArgs_Request_DEFAULT *models.RemoveChunkRequest

func (p *ChunkServiceRemoveChunkArgs) GetRequest() *models.RemoveChunkRequest {
	if !p.IsSetRequest() {
		return ChunkServiceRemoveChunkArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceRemoveChunkArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceRemoveChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.RemoveChunkRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "RemoveChunk_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceRemoveChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceRemoveChunkArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceRemoveChunkResult struct {
	Success *models.RemoveChunkResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError       `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceRemoveChunkResult() *ChunkServiceRemoveChunkResult {
	return &ChunkServiceRemoveChunkResult{}
}

var ChunkServiceRemoveChunkResult_Success_DEFAULT *models.RemoveChunkResponse

func (p *ChunkServiceRemoveChunkResult) GetSuccess() *models.RemoveChunkResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceRemoveChunkResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceRemoveChunkResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceRemoveChunkResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceRemoveChunkResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceRemoveChunkResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceRemoveChunkResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceRemoveChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.RemoveChunkResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "RemoveChunk_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceRemoveChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceRemoveChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceRemoveChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceRemoveChunkResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceJoinMVArgs struct {
	Request *models.JoinMVRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceJoinMVArgs() *ChunkServiceJoinMVArgs {
	return &ChunkServiceJoinMVArgs{}
}

var ChunkServiceJoinMVArgs_Request_DEFAULT *models.JoinMVRequest

func (p *ChunkServiceJoinMVArgs) GetRequest() *models.JoinMVRequest {
	if !p.IsSetRequest() {
		return ChunkServiceJoinMVArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceJoinMVArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceJoinMVArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceJoinMVArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.JoinMVRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceJoinMVArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "JoinMV_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceJoinMVArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceJoinMVArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceJoinMVArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceJoinMVResult struct {
	Success *models.JoinMVResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError  `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceJoinMVResult() *ChunkServiceJoinMVResult {
	return &ChunkServiceJoinMVResult{}
}

var ChunkServiceJoinMVResult_Success_DEFAULT *models.JoinMVResponse

func (p *ChunkServiceJoinMVResult) GetSuccess() *models.JoinMVResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceJoinMVResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceJoinMVResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceJoinMVResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceJoinMVResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceJoinMVResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceJoinMVResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceJoinMVResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceJoinMVResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.JoinMVResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceJoinMVResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceJoinMVResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "JoinMV_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceJoinMVResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceJoinMVResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceJoinMVResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceJoinMVResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceUpdateMVArgs struct {
	Request *models.UpdateMVRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceUpdateMVArgs() *ChunkServiceUpdateMVArgs {
	return &ChunkServiceUpdateMVArgs{}
}

var ChunkServiceUpdateMVArgs_Request_DEFAULT *models.UpdateMVRequest

func (p *ChunkServiceUpdateMVArgs) GetRequest() *models.UpdateMVRequest {
	if !p.IsSetRequest() {
		return ChunkServiceUpdateMVArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceUpdateMVArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceUpdateMVArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.UpdateMVRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "UpdateMV_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceUpdateMVArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceUpdateMVArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceUpdateMVResult struct {
	Success *models.UpdateMVResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError    `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceUpdateMVResult() *ChunkServiceUpdateMVResult {
	return &ChunkServiceUpdateMVResult{}
}

var ChunkServiceUpdateMVResult_Success_DEFAULT *models.UpdateMVResponse

func (p *ChunkServiceUpdateMVResult) GetSuccess() *models.UpdateMVResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceUpdateMVResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceUpdateMVResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceUpdateMVResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceUpdateMVResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceUpdateMVResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceUpdateMVResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceUpdateMVResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.UpdateMVResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "UpdateMV_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceUpdateMVResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceUpdateMVResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceUpdateMVResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceUpdateMVResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceLeaveMVArgs struct {
	Request *models.LeaveMVRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceLeaveMVArgs() *ChunkServiceLeaveMVArgs {
	return &ChunkServiceLeaveMVArgs{}
}

var ChunkServiceLeaveMVArgs_Request_DEFAULT *models.LeaveMVRequest

func (p *ChunkServiceLeaveMVArgs) GetRequest() *models.LeaveMVRequest {
	if !p.IsSetRequest() {
		return ChunkServiceLeaveMVArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceLeaveMVArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceLeaveMVArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.LeaveMVRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "LeaveMV_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceLeaveMVArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceLeaveMVArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceLeaveMVResult struct {
	Success *models.LeaveMVResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError   `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceLeaveMVResult() *ChunkServiceLeaveMVResult {
	return &ChunkServiceLeaveMVResult{}
}

var ChunkServiceLeaveMVResult_Success_DEFAULT *models.LeaveMVResponse

func (p *ChunkServiceLeaveMVResult) GetSuccess() *models.LeaveMVResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceLeaveMVResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceLeaveMVResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceLeaveMVResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceLeaveMVResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceLeaveMVResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceLeaveMVResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceLeaveMVResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.LeaveMVResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "LeaveMV_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceLeaveMVResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceLeaveMVResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceLeaveMVResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceLeaveMVResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceGetMVSizeArgs struct {
	Request *models.GetMVSizeRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceGetMVSizeArgs() *ChunkServiceGetMVSizeArgs {
	return &ChunkServiceGetMVSizeArgs{}
}

var ChunkServiceGetMVSizeArgs_Request_DEFAULT *models.GetMVSizeRequest

func (p *ChunkServiceGetMVSizeArgs) GetRequest() *models.GetMVSizeRequest {
	if !p.IsSetRequest() {
		return ChunkServiceGetMVSizeArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceGetMVSizeArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceGetMVSizeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.GetMVSizeRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetMVSize_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceGetMVSizeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceGetMVSizeArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceGetMVSizeResult struct {
	Success *models.GetMVSizeResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError     `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceGetMVSizeResult() *ChunkServiceGetMVSizeResult {
	return &ChunkServiceGetMVSizeResult{}
}

var ChunkServiceGetMVSizeResult_Success_DEFAULT *models.GetMVSizeResponse

func (p *ChunkServiceGetMVSizeResult) GetSuccess() *models.GetMVSizeResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceGetMVSizeResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceGetMVSizeResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceGetMVSizeResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceGetMVSizeResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceGetMVSizeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceGetMVSizeResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceGetMVSizeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.GetMVSizeResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetMVSize_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceGetMVSizeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceGetMVSizeResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceGetMVSizeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceGetMVSizeResult(%+v)", *p)
}

// Attributes:
//   - Request
type ChunkServiceGetLogsArgs struct {
	Request *models.GetLogsRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewChunkServiceGetLogsArgs() *ChunkServiceGetLogsArgs {
	return &ChunkServiceGetLogsArgs{}
}

var ChunkServiceGetLogsArgs_Request_DEFAULT *models.GetLogsRequest

func (p *ChunkServiceGetLogsArgs) GetRequest() *models.GetLogsRequest {
	if !p.IsSetRequest() {
		return ChunkServiceGetLogsArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ChunkServiceGetLogsArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ChunkServiceGetLogsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceGetLogsArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &models.GetLogsRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ChunkServiceGetLogsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetLogs_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceGetLogsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ChunkServiceGetLogsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceGetLogsArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Err
type ChunkServiceGetLogsResult struct {
	Success *models.GetLogsResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *models.ResponseError   `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewChunkServiceGetLogsResult() *ChunkServiceGetLogsResult {
	return &ChunkServiceGetLogsResult{}
}

var ChunkServiceGetLogsResult_Success_DEFAULT *models.GetLogsResponse

func (p *ChunkServiceGetLogsResult) GetSuccess() *models.GetLogsResponse {
	if !p.IsSetSuccess() {
		return ChunkServiceGetLogsResult_Success_DEFAULT
	}
	return p.Success
}

var ChunkServiceGetLogsResult_Err_DEFAULT *models.ResponseError

func (p *ChunkServiceGetLogsResult) GetErr() *models.ResponseError {
	if !p.IsSetErr() {
		return ChunkServiceGetLogsResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ChunkServiceGetLogsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChunkServiceGetLogsResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ChunkServiceGetLogsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ChunkServiceGetLogsResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &models.GetLogsResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ChunkServiceGetLogsResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &models.ResponseError{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ChunkServiceGetLogsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetLogs_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ChunkServiceGetLogsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceGetLogsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ChunkServiceGetLogsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ChunkServiceGetLogsResult(%+v)", *p)
}
