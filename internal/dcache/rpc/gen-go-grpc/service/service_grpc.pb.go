// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: service.proto

package service

import (
	context "context"
	models "github.com/Azure/azure-storage-fuse/v2/internal/dcache/rpc/gen-go-grpc/models"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ChunkService_Hello_FullMethodName       = "/dcache.service.ChunkService/Hello"
	ChunkService_GetChunk_FullMethodName    = "/dcache.service.ChunkService/GetChunk"
	ChunkService_PutChunk_FullMethodName    = "/dcache.service.ChunkService/PutChunk"
	ChunkService_PutChunkDC_FullMethodName  = "/dcache.service.ChunkService/PutChunkDC"
	ChunkService_RemoveChunk_FullMethodName = "/dcache.service.ChunkService/RemoveChunk"
	ChunkService_JoinMV_FullMethodName      = "/dcache.service.ChunkService/JoinMV"
	ChunkService_UpdateMV_FullMethodName    = "/dcache.service.ChunkService/UpdateMV"
	ChunkService_LeaveMV_FullMethodName     = "/dcache.service.ChunkService/LeaveMV"
	ChunkService_GetMVSize_FullMethodName   = "/dcache.service.ChunkService/GetMVSize"
)

// ChunkServiceClient is the client API for ChunkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Define the service with RPC methods
type ChunkServiceClient interface {
	// check if the node is reachable
	Hello(ctx context.Context, in *models.HelloRequest, opts ...grpc.CallOption) (*models.HelloResponse, error)
	// fetch the chunk from the node from the given rvID
	GetChunk(ctx context.Context, in *models.GetChunkRequest, opts ...grpc.CallOption) (*models.GetChunkResponse, error)
	// store the chunk on the node on the given rvID
	PutChunk(ctx context.Context, in *models.PutChunkRequest, opts ...grpc.CallOption) (*models.PutChunkResponse, error)
	PutChunkDC(ctx context.Context, in *models.PutChunkDCRequest, opts ...grpc.CallOption) (*models.PutChunkDCResponse, error)
	// delete the chunk from the node from the given rvID
	RemoveChunk(ctx context.Context, in *models.RemoveChunkRequest, opts ...grpc.CallOption) (*models.RemoveChunkResponse, error)
	// add RV to the given MV
	JoinMV(ctx context.Context, in *models.JoinMVRequest, opts ...grpc.CallOption) (*models.JoinMVResponse, error)
	// update the component RVs for the given MV
	// this call is sent after the JoinMV call to the online RVs to update their component RVs list
	UpdateMV(ctx context.Context, in *models.UpdateMVRequest, opts ...grpc.CallOption) (*models.UpdateMVResponse, error)
	// remove RV from the given MV
	LeaveMV(ctx context.Context, in *models.LeaveMVRequest, opts ...grpc.CallOption) (*models.LeaveMVResponse, error)
	// retrieve the size of the specified MV
	GetMVSize(ctx context.Context, in *models.GetMVSizeRequest, opts ...grpc.CallOption) (*models.GetMVSizeResponse, error)
}

type chunkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChunkServiceClient(cc grpc.ClientConnInterface) ChunkServiceClient {
	return &chunkServiceClient{cc}
}

func (c *chunkServiceClient) Hello(ctx context.Context, in *models.HelloRequest, opts ...grpc.CallOption) (*models.HelloResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.HelloResponse)
	err := c.cc.Invoke(ctx, ChunkService_Hello_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chunkServiceClient) GetChunk(ctx context.Context, in *models.GetChunkRequest, opts ...grpc.CallOption) (*models.GetChunkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.GetChunkResponse)
	err := c.cc.Invoke(ctx, ChunkService_GetChunk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chunkServiceClient) PutChunk(ctx context.Context, in *models.PutChunkRequest, opts ...grpc.CallOption) (*models.PutChunkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.PutChunkResponse)
	err := c.cc.Invoke(ctx, ChunkService_PutChunk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chunkServiceClient) PutChunkDC(ctx context.Context, in *models.PutChunkDCRequest, opts ...grpc.CallOption) (*models.PutChunkDCResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.PutChunkDCResponse)
	err := c.cc.Invoke(ctx, ChunkService_PutChunkDC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chunkServiceClient) RemoveChunk(ctx context.Context, in *models.RemoveChunkRequest, opts ...grpc.CallOption) (*models.RemoveChunkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.RemoveChunkResponse)
	err := c.cc.Invoke(ctx, ChunkService_RemoveChunk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chunkServiceClient) JoinMV(ctx context.Context, in *models.JoinMVRequest, opts ...grpc.CallOption) (*models.JoinMVResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.JoinMVResponse)
	err := c.cc.Invoke(ctx, ChunkService_JoinMV_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chunkServiceClient) UpdateMV(ctx context.Context, in *models.UpdateMVRequest, opts ...grpc.CallOption) (*models.UpdateMVResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.UpdateMVResponse)
	err := c.cc.Invoke(ctx, ChunkService_UpdateMV_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chunkServiceClient) LeaveMV(ctx context.Context, in *models.LeaveMVRequest, opts ...grpc.CallOption) (*models.LeaveMVResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.LeaveMVResponse)
	err := c.cc.Invoke(ctx, ChunkService_LeaveMV_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chunkServiceClient) GetMVSize(ctx context.Context, in *models.GetMVSizeRequest, opts ...grpc.CallOption) (*models.GetMVSizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.GetMVSizeResponse)
	err := c.cc.Invoke(ctx, ChunkService_GetMVSize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChunkServiceServer is the server API for ChunkService service.
// All implementations must embed UnimplementedChunkServiceServer
// for forward compatibility.
//
// Define the service with RPC methods
type ChunkServiceServer interface {
	// check if the node is reachable
	Hello(context.Context, *models.HelloRequest) (*models.HelloResponse, error)
	// fetch the chunk from the node from the given rvID
	GetChunk(context.Context, *models.GetChunkRequest) (*models.GetChunkResponse, error)
	// store the chunk on the node on the given rvID
	PutChunk(context.Context, *models.PutChunkRequest) (*models.PutChunkResponse, error)
	PutChunkDC(context.Context, *models.PutChunkDCRequest) (*models.PutChunkDCResponse, error)
	// delete the chunk from the node from the given rvID
	RemoveChunk(context.Context, *models.RemoveChunkRequest) (*models.RemoveChunkResponse, error)
	// add RV to the given MV
	JoinMV(context.Context, *models.JoinMVRequest) (*models.JoinMVResponse, error)
	// update the component RVs for the given MV
	// this call is sent after the JoinMV call to the online RVs to update their component RVs list
	UpdateMV(context.Context, *models.UpdateMVRequest) (*models.UpdateMVResponse, error)
	// remove RV from the given MV
	LeaveMV(context.Context, *models.LeaveMVRequest) (*models.LeaveMVResponse, error)
	// retrieve the size of the specified MV
	GetMVSize(context.Context, *models.GetMVSizeRequest) (*models.GetMVSizeResponse, error)
	mustEmbedUnimplementedChunkServiceServer()
}

// UnimplementedChunkServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChunkServiceServer struct{}

func (UnimplementedChunkServiceServer) Hello(context.Context, *models.HelloRequest) (*models.HelloResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hello not implemented")
}
func (UnimplementedChunkServiceServer) GetChunk(context.Context, *models.GetChunkRequest) (*models.GetChunkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChunk not implemented")
}
func (UnimplementedChunkServiceServer) PutChunk(context.Context, *models.PutChunkRequest) (*models.PutChunkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutChunk not implemented")
}
func (UnimplementedChunkServiceServer) PutChunkDC(context.Context, *models.PutChunkDCRequest) (*models.PutChunkDCResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutChunkDC not implemented")
}
func (UnimplementedChunkServiceServer) RemoveChunk(context.Context, *models.RemoveChunkRequest) (*models.RemoveChunkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveChunk not implemented")
}
func (UnimplementedChunkServiceServer) JoinMV(context.Context, *models.JoinMVRequest) (*models.JoinMVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinMV not implemented")
}
func (UnimplementedChunkServiceServer) UpdateMV(context.Context, *models.UpdateMVRequest) (*models.UpdateMVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMV not implemented")
}
func (UnimplementedChunkServiceServer) LeaveMV(context.Context, *models.LeaveMVRequest) (*models.LeaveMVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveMV not implemented")
}
func (UnimplementedChunkServiceServer) GetMVSize(context.Context, *models.GetMVSizeRequest) (*models.GetMVSizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMVSize not implemented")
}
func (UnimplementedChunkServiceServer) mustEmbedUnimplementedChunkServiceServer() {}
func (UnimplementedChunkServiceServer) testEmbeddedByValue()                      {}

// UnsafeChunkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChunkServiceServer will
// result in compilation errors.
type UnsafeChunkServiceServer interface {
	mustEmbedUnimplementedChunkServiceServer()
}

func RegisterChunkServiceServer(s grpc.ServiceRegistrar, srv ChunkServiceServer) {
	// If the following call pancis, it indicates UnimplementedChunkServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChunkService_ServiceDesc, srv)
}

func _ChunkService_Hello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChunkServiceServer).Hello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChunkService_Hello_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChunkServiceServer).Hello(ctx, req.(*models.HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChunkService_GetChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.GetChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChunkServiceServer).GetChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChunkService_GetChunk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChunkServiceServer).GetChunk(ctx, req.(*models.GetChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChunkService_PutChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.PutChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChunkServiceServer).PutChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChunkService_PutChunk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChunkServiceServer).PutChunk(ctx, req.(*models.PutChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChunkService_PutChunkDC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.PutChunkDCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChunkServiceServer).PutChunkDC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChunkService_PutChunkDC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChunkServiceServer).PutChunkDC(ctx, req.(*models.PutChunkDCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChunkService_RemoveChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.RemoveChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChunkServiceServer).RemoveChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChunkService_RemoveChunk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChunkServiceServer).RemoveChunk(ctx, req.(*models.RemoveChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChunkService_JoinMV_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.JoinMVRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChunkServiceServer).JoinMV(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChunkService_JoinMV_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChunkServiceServer).JoinMV(ctx, req.(*models.JoinMVRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChunkService_UpdateMV_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.UpdateMVRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChunkServiceServer).UpdateMV(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChunkService_UpdateMV_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChunkServiceServer).UpdateMV(ctx, req.(*models.UpdateMVRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChunkService_LeaveMV_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.LeaveMVRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChunkServiceServer).LeaveMV(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChunkService_LeaveMV_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChunkServiceServer).LeaveMV(ctx, req.(*models.LeaveMVRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChunkService_GetMVSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.GetMVSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChunkServiceServer).GetMVSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChunkService_GetMVSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChunkServiceServer).GetMVSize(ctx, req.(*models.GetMVSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChunkService_ServiceDesc is the grpc.ServiceDesc for ChunkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChunkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dcache.service.ChunkService",
	HandlerType: (*ChunkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Hello",
			Handler:    _ChunkService_Hello_Handler,
		},
		{
			MethodName: "GetChunk",
			Handler:    _ChunkService_GetChunk_Handler,
		},
		{
			MethodName: "PutChunk",
			Handler:    _ChunkService_PutChunk_Handler,
		},
		{
			MethodName: "PutChunkDC",
			Handler:    _ChunkService_PutChunkDC_Handler,
		},
		{
			MethodName: "RemoveChunk",
			Handler:    _ChunkService_RemoveChunk_Handler,
		},
		{
			MethodName: "JoinMV",
			Handler:    _ChunkService_JoinMV_Handler,
		},
		{
			MethodName: "UpdateMV",
			Handler:    _ChunkService_UpdateMV_Handler,
		},
		{
			MethodName: "LeaveMV",
			Handler:    _ChunkService_LeaveMV_Handler,
		},
		{
			MethodName: "GetMVSize",
			Handler:    _ChunkService_GetMVSize_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
