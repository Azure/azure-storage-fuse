Only in cpplite/: adls
Only in cpplite/: azure-pipelines.yml
Only in cpplite/: build.release
Only in cpplite/: cgmanifest.json
Only in cpplite/: Changelog.txt
diff -r azure-storage-cpp-lite-org/CMakeLists.txt cpplite/CMakeLists.txt
1c1,5
< cmake_minimum_required(VERSION 2.8)
---
> cmake_minimum_required(VERSION 3.6)
> 
> project(azurestoragelite)
> set(CMAKE_CXX_STANDARD 11)
> 
5c9,15
< set(AZURE_STORAGE_HEADER
---
> option(BUILD_ADLS        "Build ADLS Gen2 codes"             OFF)
> 
> set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
> set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
> set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
> 
> set(AZURE_STORAGE_LITE_HEADER
17a28
>   include/mstream.h
23a35,36
>   include/json_parser_base.h
> 
37a51
>   include/set_container_metadata_request_base.h
42a57
>   include/set_blob_metadata_request_base.h
45d59
<   include/get_container_property_request_base.h
59a74
>   include/blob/set_container_metadata_request.h
62a78
>   include/blob/set_blob_metadata_request.h
70,74d85
< 
<   include/todo/get_blob_metadata_request.h
<   include/todo/get_blob_properties_request.h
<   include/todo/query_entities_request.h
<   include/todo/set_blob_metadata_request.h
77c88
< set(AZURE_STORAGE_SOURCE
---
> set(AZURE_STORAGE_LITE_SOURCE
96a108
>   src/set_container_metadata_request_base.cpp
99a112
>   src/set_blob_metadata_request_base.cpp
114c127,137
< if(APPLE)
---
> set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
> set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
> set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
> 
> add_library(azure-storage-lite ${AZURE_STORAGE_LITE_HEADER} ${AZURE_STORAGE_LITE_SOURCE})
> 
> set(CMAKE_THREAD_PREFER_PTHREAD TRUE)
> set(THREADS_PREFER_PTHREAD_FLAG TRUE)
> find_package(Threads REQUIRED)
> find_package(CURL REQUIRED)
> if (UNIX)
116,136c139,141
<   add_definitions(-DUSE_OPENSSL)
<   find_package(CURL REQUIRED)
<   # Adding default brew install DIR for openssl
<   set(OPENSSL_ROOT_DIR ${OPENSSL_ROOT_DIR} "/usr/local/opt/openssl/")
<   find_package(OpenSSL REQUIRED)
<   include_directories(${PROJECT_SOURCE_DIR}/include ${CURL_INCLUDE_DIRS} ${OPENSSL_INCLUDE_DIR} ${EXTRA_INCLUDE})
<   set(EXTRA_LIBRARIES ${EXTRA_LIBRARIES} system)
<   set(CMAKE_MACOSX_RPATH ON)
< elseif (UNIX)
<   option(USE_OPENSSL "Use OpenSSL instead of GnuTLS" OFF)
<   find_package(Threads REQUIRED)
<   find_package(CURL REQUIRED)
<   include(FindPkgConfig)
<   pkg_search_module(UUID REQUIRED uuid)
<   if (NOT ${USE_OPENSSL})
<     find_package(GnuTLS REQUIRED)
<     set(EXTRA_INCLUDE ${GNUTLS_INCLUDE_DIR})
<     set(EXTRA_LIBRARIES ${GNUTLS_LIBRARIES})
<     include_directories(${PROJECT_SOURCE_DIR}/include ${CURL_INCLUDE_DIRS} ${UUID_INCLUDE_DIR} ${EXTRA_INCLUDE})
<   else()
<     add_definitions(-DUSE_OPENSSL)
---
>   if(USE_OPENSSL)
>     target_compile_definitions(azure-storage-lite PRIVATE -DUSE_OPENSSL)
>     set(OPENSSL_ROOT_DIR ${OPENSSL_ROOT_DIR} /usr/local/opt/openssl)
138,184c143
<     include_directories(${PROJECT_SOURCE_DIR}/include ${CURL_INCLUDE_DIRS} ${OPENSSL_INCLUDE_DIR} ${UUID_INCLUDE_DIR} ${EXTRA_INCLUDE})
<   endif()
< else()
<   # Add the parameter/definition specifically for Windows.
<   option(USE_OPENSSL "Use OpenSSL instead of GnuTLS" ON)
<   option(CMAKE_BUILD_TYPE "The default build type" "Debug")
<   option(CMAKE_GENERATOR_PLATFORM "The Generator platform used for CMake" "x86")
<   #Construct the libcurl folder path
<   #This is because the cmake's FindCurl.cmake not being compatible with libcurl's buildscript on Windows.
<   #e.g. libcurl-vc15-x64-debug-static-ssl-static-ipv6-sspi
<   if((DEFINED CURL_ROOT_DIR) AND (NOT (CURL_ROOT_DIR STREQUAL "")))
<     if(CMAKE_CL_64)
<       set(INHERIT_ENV "x64")
<     else()
<       set(INHERIT_ENV "x86")
<     endif()
< 
<     if(CMAKE_BUILD_TYPE STREQUAL "Debug")
<       set(LIBRARY_BUILD_TYPE "debug")
<     else()
<       set(LIBRARY_BUILD_TYPE "release")
<     endif()
< 
<     if(CURL_LINK_TYPE STREQUAL "static")
<       add_definitions(-DCURL_STATICLIB)
<       if(CMAKE_BUILD_TYPE STREQUAL "Debug")
<         set(CURL_LIBRARY_NAME "lib\\libcurl_a_debug.lib")
<       else()
<         set(CURL_LIBRARY_NAME "lib\\libcurl_a.lib")
<       endif()
<     else()
<       if(CMAKE_BUILD_TYPE STREQUAL "Debug")
<         set(CURL_LIBRARY_NAME "bin\\libcurl_debug.dll")
<       else()
<         set(CURL_LIBRARY_NAME "bin\\libcurl.dll")
<       endif()
<     endif()
< 
<     set(CURL_LIBRARIES "${CURL_ROOT_DIR}\\builds\\libcurl-vc15-${INHERIT_ENV}-${LIBRARY_BUILD_TYPE}-${CURL_LINK_TYPE}-ssl-${OPENSSL_LINK_TYPE}-ipv6-sspi\\${CURL_LIBRARY_NAME}")
<     set(CURL_INCLUDE_DIRS "${CURL_ROOT_DIR}\\builds\\libcurl-vc15-${INHERIT_ENV}-${LIBRARY_BUILD_TYPE}-${CURL_LINK_TYPE}-ssl-${OPENSSL_LINK_TYPE}-ipv6-sspi\\include\\")
< 
<     message (STATUS "Constructed curl library path: ${CURL_LIBRARIES}")
<     message (STATUS "Constructed curl include path: ${CURL_INCLUDE_DIRS}")
< 
<     unset(INHERIT_ENV)
<     unset(LIBRARY_BUILD_TYPE)
<     unset(CURL_LIBRARY_NAME)
---
>     list(APPEND EXTRA_LIBRARIES OpenSSL::SSL OpenSSL::Crypto)
186,193c145,147
<     if(CURL_LINK_TYPE STREQUAL "static")
<       add_definitions(-DCURL_STATICLIB)
<     endif()
< 
<         #if there isn't a customized openssl library and include, then use FindOpenSSL.cmake to find Openssl on Windows
<     if(NOT((DEFINED CURL_INCLUDE_DIRS) OR (DEFINED CURL_LIBRARIES)))
<       find_package(CURL REQUIRED)
<     endif()
---
>     find_package(GnuTLS REQUIRED)
>     list(APPEND EXTRA_INCLUDE_DIRS ${GNUTLS_INCLUDE_DIR})
>     list(APPEND EXTRA_LIBRARIES ${GNUTLS_LIBRARIES})
196,231c150,153
<   #Constructing OPENSSL path on windows.
<   if((DEFINED OPENSSL_ROOT_DIR) AND (NOT (OPENSSL_ROOT_DIR STREQUAL "")))
<     if(CMAKE_CL_64)
<       set(INHERIT_ENV "x64")
<     else()
<       set(INHERIT_ENV "x86")
<     endif()
< 
<     if(OPENSSL_LINK_TYPE STREQUAL "static")
<       add_definitions(-DOPENSSL_STATICLIB)
<       set(OPENSSL_LIBRARY_NAME "ssleay32.lib")
<       set(OPENSSL_CRYPTO_LIBRARY_NAME "libeay32.lib")
<     else()
<       set(OPENSSL_LIBRARY_NAME "ssleay32.dll")
<       set(OPENSSL_CRYPTO_LIBRARY_NAME "libeay32.dll")
<     endif()
< 
<     set(OPENSSL_SSL_LIBRARY "${OPENSSL_ROOT_DIR}\\lib\\${CMAKE_BUILD_TYPE}\\${OPENSSL_LIBRARY_NAME}")
<     set(OPENSSL_CRYPTO_LIBRARY "${OPENSSL_ROOT_DIR}\\lib\\${CMAKE_BUILD_TYPE}\\${OPENSSL_CRYPTO_LIBRARY_NAME}")
<     set(OPENSSL_INCLUDE_DIR "${OPENSSL_ROOT_DIR}\\include\\openssl\\")
<     message (STATUS "Constructed openssl library path: ${OPENSSL_SSL_LIBRARY}")
<     message (STATUS "Constructed openssl include path: ${OPENSSL_INCLUDE_DIR}")
<     message (STATUS "Constructed openssl crypto library path: ${OPENSSL_CRYPTO_LIBRARY}")
<     unset(INHERIT_ENV)
<     unset(OPENSSL_LIBRARY_NAME)
<     unset(OPENSSL_CRYPTO_LIBRARY_NAME)
<   else()
<     if(OPENSSL_LINK_TYPE STREQUAL "static")
<       add_definitions(-DOPENSSL_STATICLIB)
<     endif()
< 
<     #if there isn't a customized openssl library and include, then use FindOpenSSL.cmake to find Openssl on Windows
<     if(NOT((DEFINED OPENSSL_INCLUDE_DIR) AND (DEFINED OPENSSL_CRYPTO_LIBRARY) AND (DEFINED OPENSSL_SSL_LIBRARY)))
<       message(STATUS "OpenSSL folder is not specified, need to find it automatically.")
<       find_package(OpenSSL REQUIRED)
<     endif()
---
>   if(NOT APPLE)
>     find_package(PkgConfig REQUIRED)
>     pkg_check_modules(uuid REQUIRED IMPORTED_TARGET uuid)
>     list(APPEND EXTRA_LIBRARIES PkgConfig::uuid)
232a155,158
> elseif(WIN32)
>   list(APPEND EXTRA_LIBRARIES rpcrt4 bcrypt)
>   target_compile_definitions(azure-storage-lite PRIVATE azure_storage_lite_EXPORTS NOMINMAX)
> endif()
234,241c160,166
<   if(OPENSSL_LINK_TYPE STREQUAL "static")
<     add_definitions(-DOPENSSL_STATICLIB)
<   endif()
<   add_definitions(-DUSE_OPENSSL)
<   set(OPENSSL_MSVC_STATIC_RT "true")
<   if (BUILD_WITH_MT)
<     set(CMAKE_CXX_FLAGS_RELEASE "/MT")
<     set(CMAKE_CXX_FLAGS_DEBUG "/MT")
---
> if(BUILD_TESTS)
>   find_package(Catch2)
>   if(NOT Catch2_FOUND)
>     find_path(SINGLE_HEADER_CATCH2_INCLUDE_DIR catch2/catch.hpp PATHS ${CATCH2_INCLUDE_DIR})
>     message("Found single-header Catch2: ${SINGLE_HEADER_CATCH2_INCLUDE_DIR}/catch2/catch.hpp")
>     add_library(Catch2::Catch2 INTERFACE IMPORTED)
>     set_target_properties(Catch2::Catch2 PROPERTIES INTERFACE_INCLUDE_DIRECTORIES ${SINGLE_HEADER_CATCH2_INCLUDE_DIR})
243,245d167
<   #adding extra dependency libraries for windows
<   set(EXTRA_LIBRARIES ${EXTRA_LIBRARIES} rpcrt4 ws2_32 wldap32 crypt32 normaliz)
<   include_directories(${PROJECT_SOURCE_DIR}/include ${CURL_INCLUDE_DIRS} ${OPENSSL_INCLUDE_DIR} ${EXTRA_INCLUDE})
248,252c170,171
< if (("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang") OR ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU"))
<   add_definitions(-std=c++11)
<   set(WARNING "-Wall -Wextra -Werror -pedantic -pedantic-errors")
<   set(CMAKE_CXX_FLAGS "${CMAKE_THREAD_LIBS_INIT} ${WARNING} ${CMAKE_CXX_FLAGS}")
< endif()
---
> target_include_directories(azure-storage-lite PUBLIC ${PROJECT_SOURCE_DIR}/include ${CURL_INCLUDE_DIRS} PRIVATE ${EXTRA_INCLUDE_DIRS})
> target_link_libraries(azure-storage-lite Threads::Threads ${CURL_LIBRARIES} ${EXTRA_LIBRARIES})
254c173,177
< add_library(azure-storage-lite ${AZURE_STORAGE_LITE_HEADER} ${AZURE_STORAGE_LITE_SOURCE})
---
> if(MSVC)
>   target_compile_options(azure-storage-lite PRIVATE /W4 /WX /MP)
> elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
>   target_compile_options(azure-storage-lite PRIVATE -Wall -Wextra -Werror -pedantic)
> endif()
256,259c179,180
< if (NOT ${USE_OPENSSL})
<   target_link_libraries(azure-storage-lite ${CURL_LIBRARIES} ${UUID_LIBRARIES} ${EXTRA_LIBRARIES})
< else()
<   target_link_libraries(azure-storage-lite ${CURL_LIBRARIES} ${OPENSSL_CRYPTO_LIBRARY} ${OPENSSL_SSL_LIBRARY} ${UUID_LIBRARIES} ${EXTRA_LIBRARIES})
---
> if(BUILD_ADLS)
>   add_subdirectory(adls)
270,291d190
< if (WIN32 OR UNIX)
<   file(GLOB BLOB_HEADERS includes/blob/*.h)
<   install(FILES ${BLOB_HEADERS} DESTINATION include/blob)
< 
<   file(GLOB HTTP_HEADERS includes/http/*.h)
<   install(FILES ${HTTP_HEADERS} DESTINATION include/http)
< 
<   file(GLOB TODO_HEADERS includes/todo/*.h)
<   install(FILES ${HTTP_HEADERS} DESTINATION todo/http)
< 
<   file(GLOB GENERAL_HEADERS includes/*.h)
<   install(FILES ${GENERAL_HEADERS} DESTINATION include)
< 
<   file(GLOB GENERAL_DATA includes/*.dat)
<   install(FILES ${GENERAL_DATA} DESTINATION include)
< endif()
< 
< # Reconfigure final output directory
< set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/Binaries)
< set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/Binaries)
< set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/Binaries)
< 
293,304c192,200
< set (AZURE_STORAGE_LITE_VERSION_MAJOR 0)
< set (AZURE_STORAGE_LITE_VERSION_MINOR 1)
< set (AZURE_STORAGE_LITE_VERSION_REVISION 0)
< 
< # Set output directories.
< if(NOT DEFINED CMAKE_INSTALL_BINDIR)
<   set(CMAKE_INSTALL_BINDIR bin)
< endif()
< 
< if(NOT DEFINED CMAKE_INSTALL_LIBDIR)
<   set(CMAKE_INSTALL_LIBDIR lib)
< endif()
---
> set(AZURE_STORAGE_LITE_VERSION_MAJOR 0)
> set(AZURE_STORAGE_LITE_VERSION_MINOR 3)
> set(AZURE_STORAGE_LITE_VERSION_REVISION 0)
> 
> install(DIRECTORY include/ DESTINATION include)
> install(TARGETS azure-storage-lite
>     ARCHIVE DESTINATION lib
>     LIBRARY DESTINATION lib
>     RUNTIME DESTINATION bin)
Only in cpplite/: CMakeSettings.json
Only in cpplite/: .gitignore
diff -r azure-storage-cpp-lite-org/include/append_block_request_base.h cpplite/include/append_block_request_base.h
12,13c12
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
15,18c14,18
<         class append_block_request_base : public blob_request_base {
<         public:
<             virtual std::string container() const = 0;
<             virtual std::string blob() const = 0;
---
>     class append_block_request_base : public blob_request_base
>     {
>     public:
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
20,21c20,21
<             virtual unsigned int content_length() const = 0;
<             virtual std::string content_md5() const { return std::string(); }
---
>         virtual unsigned int content_length() const = 0;
>         virtual std::string content_md5() const { return std::string(); }
23,24c23,24
<             virtual unsigned long long ms_blob_condition_maxsize() const { return 0; }
<             virtual unsigned long long ms_blob_condition_appendpos() const { return 0; }
---
>         virtual unsigned long long ms_blob_condition_maxsize() const { return 0; }
>         virtual unsigned long long ms_blob_condition_appendpos() const { return 0; }
26,27c26,27
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
29,30c29
<     }
< }
---
> }}
diff -r azure-storage-cpp-lite-org/include/base64.h cpplite/include/base64.h
8,9c8
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
15,16c14
<     }
< }
---
> }}
diff -r azure-storage-cpp-lite-org/include/blob/append_block_request.h cpplite/include/blob/append_block_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
8,40c7,42
<         class append_block_request : public append_block_request_base {
<         public:
<             append_block_request(const std::string &container, const std::string &blob)
<                 : m_container(container),
<                 m_blob(blob),
<                 m_content_length(0) {}
< 
<             std::string container() const override {
<                 return m_container;
<             }
< 
<             std::string blob() const override {
<                 return m_blob;
<             }
< 
<             unsigned int content_length() const override {
<                 return m_content_length;
<             }
< 
<             append_block_request &set_content_length(unsigned int content_length) {
<                 m_content_length = content_length;
<                 return *this;
<             }
< 
<         private:
<             std::string m_container;
<             std::string m_blob;
< 
<             unsigned int m_content_length;
<         };
< 
<     }
< }
---
>     class append_block_request final : public append_block_request_base 
>     {
>     public:
>         append_block_request(const std::string &container, const std::string &blob)
>             : m_container(container),
>             m_blob(blob),
>             m_content_length(0) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string blob() const override
>         {
>             return m_blob;
>         }
> 
>         unsigned int content_length() const override
>         {
>             return m_content_length;
>         }
> 
>         append_block_request &set_content_length(unsigned int content_length)
>         {
>             m_content_length = content_length;
>             return *this;
>         }
> 
>     private:
>         std::string m_container;
>         std::string m_blob;
> 
>         unsigned int m_content_length;
>     };
> }} // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/blob_client.h cpplite/include/blob/blob_client.h
6,7c6
< #include <mutex>
< #include <boost/thread/shared_mutex.hpp>
---
> #ifdef __linux__
8a8
> #endif
22c22
< namespace microsoft_azure { namespace storage {
---
> namespace azure { namespace storage_lite {
28c28,29
<     class blob_client {
---
>     class blob_client final
>     {
31c32
<         /// Initializes a new instance of the <see cref="microsoft_azure::storage::blob_client" /> class.
---
>         /// Initializes a new instance of the <see cref="azure::storage_lite::blob_client" /> class.
33c34
<         /// <param name="account">An existing <see crefmicrosoft_azure::storage::storage_account" /> object.</param>
---
>         /// <param name="account">An existing <see cref="azure::storage_lite::storage_account" /> object.</param>
58,59c59,61
<         /// <returns>The <see cref="microsoft_azure::storage::CurlEasyClient"> object</returns>
<         std::shared_ptr<CurlEasyClient> client() const {
---
>         /// <returns>The <see cref="azure::storage_lite::CurlEasyClient"> object</returns>
>         std::shared_ptr<CurlEasyClient> client() const
>         {
66c68,69
<         std::shared_ptr<storage_account> account() const {
---
>         std::shared_ptr<storage_account> account() const
>         {
73c76,77
<         unsigned int concurrency() const {
---
>         unsigned int concurrency() const
>         {
77a82,89
>         /// Gets the executor context.
>         /// </summary>
>         std::shared_ptr<executor_context> context() const
>         {
>             return m_context;
>         }
> 
>         /// <summary>
89c101
<         /// Intitiates an asynchronous operation  to download the contents of a blob to a stream.
---
>         /// Intitiates an asynchronous operation to download the contents of a blob to a stream.
100c112,124
<         /// Intitiates an asynchronous operation  to upload the contents of a blob from a stream.
---
>         /// Intitiates an asynchronous operation to download the contents of a blob to a buffer.
>         /// </summary>
>         /// <param name="container">The container name.</param>
>         /// <param name="blob">The blob name.</param>
>         /// <param name="offset">The offset at which to begin downloading the blob, in bytes.</param>
>         /// <param name="size">The size of the data to download from the blob, in bytes.</param>
>         /// <param name="buffer">The target buffer, must not be less than download size.</param>
>         /// <param name="parallelism">A int value indicates the maximum parallelism can be used in this request.</param>
>         /// <returns>A <see cref="std::future" /> object that represents the current operation.</returns>
>         AZURE_STORAGE_API std::future<storage_outcome<void>> download_blob_to_buffer(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, char* buffer, int parallelism);
> 
>         /// <summary>
>         /// Intitiates an asynchronous operation to upload the contents of a blob from a stream.
109a134,156
>         /// Intitiates an asynchronous operation to upload the contents of a blob from a stream.
>         /// </summary>
>         /// <param name="container">The container name.</param>
>         /// <param name="blob">The blob name.</param>
>         /// <param name="is">The source stream.</param>
>         /// <param name="metadata">A <see cref="std::vector"> that respresents metadatas.</param>
>         /// <param name="streamlen">Length of the stream. Used only when the stream does not support tellg/seekg</param>
>         /// <returns>A <see cref="std::future" /> object that represents the current operation.</returns>
>         AZURE_STORAGE_API std::future<storage_outcome<void>> upload_block_blob_from_stream(const std::string &container, const std::string &blob, std::istream &is, const std::vector<std::pair<std::string, std::string>> &metadata, uint64_t streamlen);
> 
>         /// <summary>
>         /// Intitiates an asynchronous operation to upload the contents of a blob from a buffer.
>         /// </summary>
>         /// <param name="container">The container name.</param>
>         /// <param name="blob">The blob name.</param>
>         /// <param name="buffer">The source buffer.</param>
>         /// <param name="metadata">A <see cref="std::vector"> that respresents metadatas.</param>
>         /// <param name="bufferlen">Length of the buffer.</param>
>         /// <returns>A <see cref="std::future" /> object that represents the current operation.</returns>
>         /// <param name="parallelism">A int value indicates the maximum parallelism can be used in this request.</param>
>         AZURE_STORAGE_API std::future<storage_outcome<void>> upload_block_blob_from_buffer(const std::string &container, const std::string &blob, const char* buffer, const std::vector<std::pair<std::string, std::string>> &metadata, uint64_t bufferlen, int parallelism = 1);
> 
>         /// <summary>
133c180
<         /// Intitiates an asynchronous operation  to get the container property.
---
>         /// Intitiates a synchronous operation  to get the container property.
136,137c183,184
<         /// <returns>A <see cref="std::future" /> object that represents the current operation.</returns>
<         AZURE_STORAGE_API storage_outcome<container_property> get_container_property(const std::string &container);
---
>         /// <returns>A <see cref="std::future" /> object that represents the current operation's result.</returns>
>         AZURE_STORAGE_API std::future<storage_outcome<container_property>> get_container_properties(const std::string &container);
140c187
<         /// Intitiates an asynchronous operation  to list containers.
---
>         /// Intitiates a synchronous operation to set the container metadata.
142,145c189,192
<         /// <param name="prefix">The container name prefix.</param>
<         /// <param name="include_metadata">A bool value, return metadatas if it is true.</param>
<         /// <returns>A <see cref="std::future" /> object that represents the current operation.</returns>
<         AZURE_STORAGE_API std::future<storage_outcome<list_containers_response>> list_containers(const std::string &prefix, const std::string& continuation_token, const int max_result = 5, bool include_metadata = false);
---
>         /// <param name="container">The container name.</param>
>         /// <param name="metadata">A <see cref="std::vector"> that respresents metadatas.</param>
>         /// <returns>A <see cref="std::future" /> object that represents the current operation's result.</returns>
>         AZURE_STORAGE_API std::future<storage_outcome<void>> set_container_metadata(const std::string &container, const std::vector<std::pair<std::string, std::string>>& metadata);
148c195
<         /// Intitiates an asynchronous operation  to list all blobs.
---
>         /// Intitiates an asynchronous operation  to list containers.
150,151c197,198
<         /// <param name="container">The container name.</param>
<         /// <param name="prefix">The blob name prefix.</param>
---
>         /// <param name="prefix">The container name prefix.</param>
>         /// <param name="include_metadata">A bool value, return metadatas if it is true.</param>
153c200
<         AZURE_STORAGE_API std::future<storage_outcome<list_blobs_response>> list_blobs(const std::string &container, const std::string &prefix);
---
>         AZURE_STORAGE_API std::future<storage_outcome<list_constainers_segmented_response>> list_containers_segmented(const std::string &prefix, const std::string& continuation_token, const int max_result = 5, bool include_metadata = false);
163c210
<         AZURE_STORAGE_API std::future<storage_outcome<list_blobs_hierarchical_response>> list_blobs_hierarchical(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix, int max_results = 10000);
---
>         AZURE_STORAGE_API std::future<storage_outcome<list_blobs_segmented_response>> list_blobs_segmented(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix, int max_results = 10000);
171c218,227
<         AZURE_STORAGE_API storage_outcome<blob_property> get_blob_property(const std::string &container, const std::string &blob);
---
>         AZURE_STORAGE_API std::future<storage_outcome<blob_property>> get_blob_properties(const std::string &container, const std::string &blob);
> 
>         /// <summary>
>         /// Intitiates a synchronous operation to set the blob metadata.
>         /// </summary>
>         /// <param name="container">The container name.</param>
>         /// <param name="blob">The blob name.</param>
>         /// <param name="metadata">A <see cref="std::vector"> that respresents metadatas.</param>
>         /// <returns>A <see cref="std::future" /> object that represents the current operation's result.</returns>
>         AZURE_STORAGE_API std::future<storage_outcome<void>> set_blob_metadata(const std::string &container, const std::string& blob, const std::vector<std::pair<std::string, std::string>>& metadata);
191a248,269
>         /// Intitiates an asynchronous operation  to upload a block of a blob from a stream.
>         /// </summary>
>         /// <param name="container">The container name.</param>
>         /// <param name="blob">The blob name.</param>
>         /// <param name="blockid">A Base64-encoded block ID that identifies the block.</param>
>         /// <param name="is">The source stream.</param>
>         /// <param name="streamlen">Length of the stream. Used only when the stream does not support tellg/seekg</param>
>         /// <returns>A <see cref="std::future" /> object that represents the current operation.</returns>
>         AZURE_STORAGE_API std::future<storage_outcome<void>> upload_block_from_stream(const std::string &container, const std::string &blob, const std::string &blockid, std::istream &is, uint64_t streamlen);
> 
>         /// <summary>
>         /// Intitiates an asynchronous operation  to upload a block of a blob from a char* buffer.
>         /// </summary>
>         /// <param name="container">The container name.</param>
>         /// <param name="blob">The blob name.</param>
>         /// <param name="blockid">A Base64-encoded block ID that identifies the block.</param>
>         /// <param name="buffer">The input buffer.</param>
>         /// <param name="streamlen">Length of the buffer.</param>
>         /// <returns>A <see cref="std::future" /> object that represents the current operation.</returns>
>         AZURE_STORAGE_API std::future<storage_outcome<void>> upload_block_from_buffer(const std::string &container, const std::string &blob, const std::string &blockid, const char* buffer, uint64_t bufferlen);
> 
>         /// <summary>
275,379d352
<     /// Abstract layer of the blob_client class for the attribute cache layer,
<     /// Provides a client-side logical representation of blob storage service on Windows Azure.
<     //// This client is used to configure and execute requests against the service with caching the attributes in mind.
<     /// </summary>
<     /// <remarks>The service client encapsulates the base URI for the service. If the service client will be used for authenticated access, it also encapsulates the credentials for accessing the storage account.</remarks>
<     class sync_blob_client
<     {
<     public:
< 
<         virtual ~sync_blob_client() = 0;
<         virtual bool is_valid() const = 0;
< 
<         /// <summary>
<         /// List blobs in segments.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="delimiter">The delimiter used to designate the virtual directories.</param>
<         /// <param name="continuation_token">A continuation token returned by a previous listing operation.</param>
<         /// <param name="prefix">The blob name prefix.</param>
<         /// <param name="maxresults">Maximum amount of results to receive</param>
<         /// <returns>A response from list_blobs_hierarchical that contains a list of blobs and their details</returns>
<         virtual list_blobs_hierarchical_response list_blobs_hierarchical(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix, int maxresults = 10000) = 0;
< 
<         /// <summary>
<         /// Uploads the contents of a blob from a local file, file size need to be equal or smaller than 64MB.
<         /// </summary>
<         /// <param name="sourcePath">The source file path.</param>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <param name="metadata">A <see cref="std::vector"> that respresents metadatas.</param>
<         virtual void put_blob(const std::string &sourcePath, const std::string &container, const std::string blob, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>()) = 0;
<  
<         /// <summary>
<         /// Uploads the contents of a blob from a stream.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <param name="is">The source stream.</param>
<         /// <param name="metadata">A <see cref="std::vector"> that respresents metadatas.</param>
<         virtual void upload_block_blob_from_stream(const std::string &container, const std::string blob, std::istream &is, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>()) = 0;
< 
<         /// <summary>
<         /// Uploads the contents of a blob from a local file.
<         /// </summary>
<         /// <param name="sourcePath">The source file path.</param>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <param name="metadata">A <see cref="std::vector"> that respresents metadatas.</param>
<         /// <param name="parallel">A size_t value indicates the maximum parallelism can be used in this request.</param>
<         virtual void upload_file_to_blob(const std::string &sourcePath, const std::string &container, const std::string blob, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>(), size_t parallel = 8) = 0;
< 
<         /// <summary>
<         /// Downloads the contents of a blob to a stream.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <param name="offset">The offset at which to begin downloading the blob, in bytes.</param>
<         /// <param name="size">The size of the data to download from the blob, in bytes.</param>
<         /// <param name="os">The target stream.</param>
<         virtual void download_blob_to_stream(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, std::ostream &os) = 0;
< 
<         /// <summary>
<         /// Downloads the contents of a blob to a local file.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <param name="offset">The offset at which to begin downloading the blob, in bytes.</param>
<         /// <param name="size">The size of the data to download from the blob, in bytes.</param>
<         /// <param name="destPath">The target file path.</param>
<         /// <param name="parallel">A size_t value indicates the maximum parallelism can be used in this request.</param>
<         virtual void download_blob_to_file(const std::string &container, const std::string &blob, const std::string &destPath, time_t &returned_last_modified, size_t parallel = 9) = 0;
< 
<         /// <summary>
<         /// Gets the property of a blob.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         virtual blob_property get_blob_property(const std::string &container, const std::string &blob) = 0;
< 
<         /// <summary>
<         /// Examines the existance of a blob.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <returns>Return true if the blob does exist, otherwise, return false.</returns>
<         virtual bool blob_exists(const std::string &container, const std::string &blob) = 0;
< 
<         /// <summary>
<         /// Deletes a blob.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         virtual void delete_blob(const std::string &container, const std::string &blob) = 0;
< 
<         /// <summary>
<         /// Copy a blob to another.
<         /// </summary>
<         /// <param name="sourceContainer">The source container name.</param>
<         /// <param name="sourceBlob">The source blob name.</param>
<         /// <param name="destContainer">The destination container name.</param>
<         /// <param name="destBlob">The destination blob name.</param>
<         virtual void start_copy(const std::string &sourceContainer, const std::string &sourceBlob, const std::string &destContainer, const std::string &destBlob) = 0;
<     };
< 
<     /// <summary>
383c356
<     class blob_client_wrapper : public sync_blob_client
---
>     class blob_client_wrapper
389c362
<         /// <param name="blobClient">A <see cref="microsoft_azure::storage::blob_client"> object stored in shared_ptr.</param>
---
>         /// <param name="blobClient">A <see cref="azure::storage_lite::blob_client"> object stored in shared_ptr.</param>
412c385
<         /// <param name="other">A <see cref="microsoft_azure::storage::blob_client_wrapper"> object.</param>
---
>         /// <param name="other">A <see cref="azure::storage_lite::blob_client_wrapper"> object.</param>
431a405,427
> 
>         /// <summary>
>         /// Constructs a blob client wrapper from storage account credential.
>         /// </summary>
>         /// <param name="account_name">The storage account name.</param>
>         /// <param name="account_key">The storage account key.</param>
> 	/// <param name="sas_token">A sas token for the container.</param>
>         /// <param name="concurrency">The maximum number requests could be executed in the same time.</param>
>         /// <returns>Return a <see cref="azure::storage_lite::blob_client_wrapper"> object.</returns>
>         AZURE_STORAGE_API static blob_client_wrapper blob_client_wrapper_init(const std::string &account_name, const std::string &account_key, const std::string &sas_token, const unsigned int concurrency);
> 
>         /// <summary>
>         /// Constructs a blob client wrapper from storage account credential.
>         /// </summary>
>         /// <param name="account_name">The storage account name.</param>
>         /// <param name="account_key">The storage account key.</param>
> 	/// <param name="sas_token">A sas token for the container.</param>
>         /// <param name="concurrency">The maximum number requests could be executed in the same time.</param>
>         /// <param name="use_https">True if https should be used (instead of HTTP).  Note that this may cause a sizable perf loss, due to issues in libcurl.</param>
>         /// <param name="blob_endpoint">Blob endpoint URI to allow non-public clouds as well as custom domains.</param>
>         /// <returns>Return a <see cref="azure::storage_lite::blob_client_wrapper"> object.</returns>
>         AZURE_STORAGE_API static blob_client_wrapper blob_client_wrapper_init(const std::string &account_name, const std::string &account_key, const std::string &sas_token, const unsigned int concurrency, bool use_https,
> 							    const std::string &blob_endpoint);
440c436
<         void create_container(const std::string &container);
---
>         AZURE_STORAGE_API void create_container(const std::string &container);
446c442
<         void delete_container(const std::string &container);
---
>         AZURE_STORAGE_API void delete_container(const std::string &container);
453c449
<         bool container_exists(const std::string &container);
---
>         AZURE_STORAGE_API bool container_exists(const std::string &container);
460c456
<         std::vector<list_containers_item> list_containers(const std::string &prefix, const std::string& continuation_token, const int max_result = 5, bool include_metadata = false);
---
>         AZURE_STORAGE_API std::vector<list_containers_item> list_containers_segmented(const std::string &prefix, const std::string& continuation_token, const int max_result = 5, bool include_metadata = false);
471c467
<         list_blobs_hierarchical_response list_blobs_hierarchical(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix, int maxresults = 10000);
---
>         AZURE_STORAGE_API list_blobs_segmented_response list_blobs_segmented(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix, int maxresults = 10000);
480c476
<         void put_blob(const std::string &sourcePath, const std::string &container, const std::string blob, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>());
---
>         AZURE_STORAGE_API void put_blob(const std::string &sourcePath, const std::string &container, const std::string blob, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>());
489c485,486
<         void upload_block_blob_from_stream(const std::string &container, const std::string blob, std::istream &is, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>());
---
>         /// <param name="streamlen">Length of the stream. Used only when the stream does not support tellg/seekg</param>
>         AZURE_STORAGE_API void upload_block_blob_from_stream(const std::string &container, const std::string blob, std::istream &is, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>(), size_t streamlen = NOT_USER_DEFINED_STREAMLEN);
499c496
<         void upload_file_to_blob(const std::string &sourcePath, const std::string &container, const std::string blob, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>(), size_t parallel = 8);
---
>         AZURE_STORAGE_API void upload_file_to_blob(const std::string &sourcePath, const std::string &container, const std::string blob, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>(), size_t parallel = 8);
509c506
<         void download_blob_to_stream(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, std::ostream &os);
---
>         AZURE_STORAGE_API void download_blob_to_stream(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, std::ostream &os);
521c518
<         void download_blob_to_file(const std::string &container, const std::string &blob, const std::string &destPath, time_t &returned_last_modified, size_t parallel = 9);
---
>         AZURE_STORAGE_API void download_blob_to_file(const std::string &container, const std::string &blob, const std::string &destPath, time_t &returned_last_modified, size_t parallel = 9);
528,529c525
<         /// <returns> A <see cref="blob_property"/> object that represents the proerty of a particular blob
<         blob_property get_blob_property(const std::string &container, const std::string &blob);
---
>         AZURE_STORAGE_API blob_property get_blob_property(const std::string &container, const std::string &blob);
537c533
<         bool blob_exists(const std::string &container, const std::string &blob);
---
>         AZURE_STORAGE_API bool blob_exists(const std::string &container, const std::string &blob);
544c540
<         void delete_blob(const std::string &container, const std::string &blob);
---
>         AZURE_STORAGE_API void delete_blob(const std::string &container, const std::string &blob);
553c549
<         void start_copy(const std::string &sourceContainer, const std::string &sourceBlob, const std::string &destContainer, const std::string &destBlob);
---
>         AZURE_STORAGE_API void start_copy(const std::string &sourceContainer, const std::string &sourceBlob, const std::string &destContainer, const std::string &destBlob);
560a557
>         static const size_t NOT_USER_DEFINED_STREAMLEN = (std::numeric_limits<size_t>::max)();
563,850c560
<         /// <summary>
<         /// Constructs a blob client wrapper from storage account credential.
<         /// </summary>
<         /// <param name="account_name">The storage account name.</param>
<         /// <param name="account_key">The storage account key.</param>
<         /// <param name="concurrency">The maximum number requests could be executed in the same time.</param>
<         /// <param name="use_https">True if https should be used (instead of HTTP).  Note that this may cause a sizable perf loss, due to issues in libcurl.</param>
<         /// <param name="blob_endpoint">Blob endpoint URI to allow non-public clouds as well as custom domains.</param>
<         /// <returns>Return a <see cref="microsoft_azure::storage::blob_client_wrapper"> object.</returns>
<         std::shared_ptr<blob_client_wrapper> blob_client_wrapper_init_accountkey(
<             const std::string &account_name,
<             const std::string &account_key,
<             const unsigned int concurrency,
<             bool use_https = true,
<             const std::string &blob_endpoint = "");
< 
<         /// <summary>
<         /// Constructs a blob client wrapper from storage account credential.
<         /// </summary>
<         /// <param name="account_name">The storage account name.</param>
<         /// <param name="sas_token">A sas token for the container.</param>
<         /// <param name="concurrency">The maximum number requests could be executed in the same time.</param>
<         /// <param name="use_https">True if https should be used (instead of HTTP).  Note that this may cause a sizable perf loss, due to issues in libcurl.</param>
<         /// <param name="blob_endpoint">Blob endpoint URI to allow non-public clouds as well as custom domains.</param>
<         /// <returns>Return a <see cref="microsoft_azure::storage::blob_client_wrapper"> object.</returns>
<         std::shared_ptr<blob_client_wrapper> blob_client_wrapper_init_sastoken(
<         const std::string &account_name,
<         const std::string &sas_token,
<         const unsigned int concurrency,
<         bool use_https = true,
<         const std::string &blob_endpoint = "");
< 
<         /// <summary>
<         /// Constructs a blob client wrapper from storage account credential.
<         /// </summary>
<         /// <param name="account_name">The storage account name.</param>
<         /// <param name="account_key">The storage account key.</param>
<         /// <param name="sas_token">A sas token for the container.</param>
<         /// <param name="concurrency">The maximum number requests could be executed in the same time.</param>
<         /// <param name="blob_endpoint">Blob endpoint URI to allow non-public clouds as well as custom domains.</param>
<         /// <returns>Return a <see cref="microsoft_azure::storage::blob_client_wrapper"> object.</returns>
<         std::shared_ptr<blob_client_wrapper> blob_client_wrapper_init_oauth(
<         const std::string &account_name,
<         const unsigned int concurrency,
<         const std::string &blob_endpoint = "");
< 
<     // A wrapper around the "blob_client_wrapper" that provides in-memory caching for "get_blob_properties" calls.
<     class blob_client_attr_cache_wrapper : public sync_blob_client
<     {
<     public:
<         /// <summary>
<         /// Constructs a blob client wrapper from a blob client instance.
<         /// </summary>
<         /// <param name="blobClient">A <see cref="microsoft_azure::storage::blob_client"> object stored in shared_ptr.</param>
<         explicit blob_client_attr_cache_wrapper(std::shared_ptr<sync_blob_client> blob_client_wrapper)
<             : m_blob_client_wrapper(blob_client_wrapper), attr_cache()
<         {
<         }
< 
<         /// <summary>
<         /// Constructs a blob client wrapper from another blob client wrapper instance.
<         /// </summary>
<         /// <param name="other">A <see cref="microsoft_azure::storage::blob_client_attr_cache_wrapper"> object.</param>
<         blob_client_attr_cache_wrapper(blob_client_attr_cache_wrapper &&other)
<         {
<             m_blob_client_wrapper = other.m_blob_client_wrapper;
<         }
< 
<         blob_client_attr_cache_wrapper& operator=(blob_client_attr_cache_wrapper&& other)
<         {
<             m_blob_client_wrapper = other.m_blob_client_wrapper;
<             return *this;
<         }
< 
<         bool is_valid() const
<         {
<             return m_blob_client_wrapper != NULL;
<         }
< 
<         // Represents a blob on the service
<         class blob_cache_item
<         {
<         public:
<             blob_cache_item(std::string name, blob_property props) : m_confirmed(false), m_mutex(), m_name(name), m_props(props)
<             {
< 
<             }
< 
< 
<             // True if this item should accurately represent a blob on the service.
<             // False if not (or unknown).  Marking an item as not confirmed is invalidating the cache.
<             bool m_confirmed;
< 
<             // A mutex that can be locked in shared or unique mode (reader/writer lock)
<             // TODO: Consider switching this to be a regular mutex
<             boost::shared_mutex m_mutex;
< 
<             // Name of the blob
<             std::string m_name;
< 
<             // The (cached) properties of the blob
<             blob_property m_props;
<         };
< 
<         // A thread-safe cache of the properties of the blobs in a container on the service.
<         // In order to access or update a single cache item, you must lock on the mutex in the relevant blob_cache_item, and also on the mutex representing the parent directory.
<         // This is due to the single cache item being linked to the directory
<         // The directory mutex must always be locked before the blob mutex, and no thread should ever have more than one blob mutex (or directory) held at once - this will prevent deadlocks.
<         // For example, to access the properties of a blob "dir1/dir2/blobname", you need to access and lock the mutex returned by get_dir_item("dir1/dir2"), and then the mutex in the blob_cache_item
<         // returned by get_blob_item("dir1/dir2/blobname").
<         // 
<         // To read the properties of the blob from the cache, lock both mutexes in shared mode.
<         // To update the properties of a single blob (or to invalidate a cache item), grab the directory mutex in shared mode, and the blob mutex in unique mode.  The mutexes must be held during both the
<         // relevant service call and the following cache update.
<         // For a 'list blobs' request, first grab the mutex for the directory in unique mode.  Then, make the request and parse the response.  For each blob in the response, grab the blob mutex for that item in unique mode 
<         // before updating it.  Don't release the directory mutex until all blobs have been updated.
<         // 
<         // TODO: Currently, the maps holding the cached information grow without bound; this should be fixed.
<         // TODO: Implement a cache timeout
<         // TODO: When we no longer use an internal copy of cpplite, the attrib cache code should stay with blobfuse - it's not really applicable in the general cpplite use case.
<         class attribute_cache
<         {
<         public:
<             attribute_cache() : blob_cache(), blobs_mutex(), dir_cache(), dirs_mutex()
<             {
<             }
< 
<             std::shared_ptr<boost::shared_mutex> get_dir_item(const std::string& path);
<             std::shared_ptr<blob_cache_item> get_blob_item(const std::string& path);
< 
<         private:
<             std::map<std::string, std::shared_ptr<blob_cache_item>> blob_cache;
<             std::mutex blobs_mutex; // Used to protect the blob_cache map itself, not items in the map.
<             std::map<std::string, std::shared_ptr<boost::shared_mutex>> dir_cache;
<             std::mutex dirs_mutex;// Used to protect the dir_cache map itself, not items in the map.
<         };
< 
<         /// <summary>
<         /// Constructs a blob client wrapper from storage account credential.
<         /// </summary>
<         /// <param name="account_name">The storage account name.</param>
<         /// <param name="account_key">The storage account key.</param>
<         /// <param name="sas_token">A sas token for the container.</param>
<         /// <param name="concurrency">The maximum number requests could be executed in the same time.</param>
<         /// <returns>Return a <see cref="microsoft_azure::storage::blob_client_wrapper"> object.</returns>
<         static blob_client_attr_cache_wrapper blob_client_attr_cache_wrapper_init_accountkey(
<             const std::string &account_name,
<             const std::string &account_key,
<             const unsigned int concurrency,
<             bool use_https = true,
<             const std::string &blob_endpoint = "");
< 
<         /// <summary>
<         /// Constructs a blob client wrapper from storage account credential.
<         /// </summary>
<         /// <param name="account_name">The storage account name.</param>
<         /// <param name="account_key">The storage account key.</param>
<         /// <param name="sas_token">A sas token for the container.</param>
<         /// <param name="concurrency">The maximum number requests could be executed in the same time.</param>
<         /// <param name="use_https">True if https should be used (instead of HTTP).  Note that this may cause a sizable perf loss, due to issues in libcurl.</param>
<         /// <param name="blob_endpoint">Blob endpoint URI to allow non-public clouds as well as custom domains.</param>
<         /// <returns>Return a <see cref="microsoft_azure::storage::blob_client_wrapper"> object.</returns>
<         static blob_client_attr_cache_wrapper blob_client_attr_cache_wrapper_init_sastoken(
<             const std::string &account_name,
<             const std::string &sas_token,
<             const unsigned int concurrency,
<             bool use_https = true,
<             const std::string &blob_endpoint = "");
< 
<         /// <summary>
<         /// Constructs a blob client wrapper from storage account credential.
<         /// </summary>
<         /// <param name="account_name">The storage account name.</param>
<         /// <param name="account_key">The storage account key.</param>
<         /// <param name="sas_token">A sas token for the container.</param>
<         /// <param name="concurrency">The maximum number requests could be executed in the same time.</param>
<         /// <returns>Return a <see cref="microsoft_azure::storage::blob_client_wrapper"> object.</returns>
<         static blob_client_attr_cache_wrapper blob_client_attr_cache_wrapper_oauth(
<         const std::string &account_name,
<         const unsigned int concurrency,
<         const std::string &blob_endpoint = "");
< 
<         /// <summary>
<         /// List blobs in segments.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="delimiter">The delimiter used to designate the virtual directories.</param>
<         /// <param name="continuation_token">A continuation token returned by a previous listing operation.</param>
<         /// <param name="prefix">The blob name prefix.</param>
<         /// <param name="maxresults">Maximum amount of results to receive</param>
<         /// <returns>A response from list_blobs_hierarchical that contains a list of blobs and their details</returns>
<         list_blobs_hierarchical_response list_blobs_hierarchical(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix, int maxresults = 10000);
< 
<         /// <summary>
<         /// Uploads the contents of a blob from a local file, file size need to be equal or smaller than 64MB.
<         /// </summary>
<         /// <param name="sourcePath">The source file path.</param>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <param name="metadata">A <see cref="std::vector"> that respresents metadatas.</param>
<         void put_blob(const std::string &sourcePath, const std::string &container, const std::string blob, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>());
< 
<         /// <summary>
<         /// Uploads the contents of a blob from a stream.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <param name="is">The source stream.</param>
<         /// <param name="metadata">A <see cref="std::vector"> that respresents metadatas.</param>
<         void upload_block_blob_from_stream(const std::string &container, const std::string blob, std::istream &is, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>());
< 
<         /// <summary>
<         /// Uploads the contents of a blob from a local file.
<         /// </summary>
<         /// <param name="sourcePath">The source file path.</param>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <param name="metadata">A <see cref="std::vector"> that respresents metadatas.</param>
<         /// <param name="parallel">A size_t value indicates the maximum parallelism can be used in this request.</param>
<         void upload_file_to_blob(const std::string &sourcePath, const std::string &container, const std::string blob, const std::vector<std::pair<std::string, std::string>> &metadata = std::vector<std::pair<std::string, std::string>>(), size_t parallel = 8);
< 
<         /// <summary>
<         /// Downloads the contents of a blob to a stream.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <param name="offset">The offset at which to begin downloading the blob, in bytes.</param>
<         /// <param name="size">The size of the data to download from the blob, in bytes.</param>
<         /// <param name="os">The target stream.</param>
<         void download_blob_to_stream(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, std::ostream &os);
< 
<         /// <summary>
<         /// Downloads the contents of a blob to a local file.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <param name="offset">The offset at which to begin downloading the blob, in bytes.</param>
<         /// <param name="size">The size of the data to download from the blob, in bytes.</param>
<         /// <param name="destPath">The target file path.</param>
<         /// <param name="parallel">A size_t value indicates the maximum parallelism can be used in this request.</param>
<         /// <returns>A <see cref="storage_outcome" /> object that represents the properties (etag, last modified time and size) from the first chunk retrieved.</returns>
<         void download_blob_to_file(const std::string &container, const std::string &blob, const std::string &destPath, time_t &returned_last_modified, size_t parallel = 8);
< 
<         /// <summary>
<         /// Gets the property of a blob.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <returns> A <see cref="blob_property"/> object that represents the proerty of a particular blob
<         blob_property get_blob_property(const std::string &container, const std::string &blob);
< 
<         /// <summary>
<         /// Gets the property of a blob.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <returns> A <see cref="blob_property"/> object that represents the proerty of a particular blob
<         blob_property get_blob_property(const std::string &container, const std::string &blob, bool assume_cache_invalid);
< 
<         /// <summary>
<         /// Examines the existance of a blob.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         /// <returns>Return true if the blob does exist, otherwise, return false.</returns>
<         bool blob_exists(const std::string &container, const std::string &blob);
< 
<         /// <summary>
<         /// Deletes a blob.
<         /// </summary>
<         /// <param name="container">The container name.</param>
<         /// <param name="blob">The blob name.</param>
<         void delete_blob(const std::string &container, const std::string &blob);
< 
<         /// <summary>
<         /// Copy a blob to another.
<         /// </summary>
<         /// <param name="sourceContainer">The source container name.</param>
<         /// <param name="sourceBlob">The source blob name.</param>
<         /// <param name="destContainer">The destination container name.</param>
<         /// <param name="destBlob">The destination blob name.</param>
<         void start_copy(const std::string &sourceContainer, const std::string &sourceBlob, const std::string &destContainer, const std::string &destBlob);
<         
<         private:
<         std::shared_ptr<sync_blob_client> m_blob_client_wrapper;
<         attribute_cache attr_cache;
<     };
< } } // microsoft_azure::storage
---
> } } // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/copy_blob_request.h cpplite/include/blob/copy_blob_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure { namespace storage_lite {
8,37c7,41
<         class copy_blob_request final: public copy_blob_request_base {
<         public:
<             copy_blob_request(const std::string &container, const std::string &blob, const std::string &destContainer, const std::string &destBlob)
<                 : m_container(container),
<                 m_blob(blob),
<                 m_destContainer(destContainer),
<                 m_destBlob(destBlob) {}
< 
<             std::string container() const override {
<                 return m_container;
<             }
< 
<             std::string blob() const override {
<                 return m_blob;
<             }
< 
<             std::string destContainer() const override {
<                 return m_destContainer;
<             }
< 
<             std::string destBlob() const override {
<                 return m_destBlob;
<             }
< 
<         private:
<             std::string m_container;
<             std::string m_blob;
<             std::string m_destContainer;
<             std::string m_destBlob;
<         };
---
>     class copy_blob_request final : public copy_blob_request_base 
>     {
>     public:
>         copy_blob_request(const std::string &container, const std::string &blob, const std::string &destContainer, const std::string &destBlob)
>             : m_container(container),
>             m_blob(blob),
>             m_destContainer(destContainer),
>             m_destBlob(destBlob) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string blob() const override
>         {
>             return m_blob;
>         }
> 
>         std::string destContainer() const override
>         {
>             return m_destContainer;
>         }
> 
>         std::string destBlob() const override
>         {
>             return m_destBlob;
>         }
> 
>     private:
>         std::string m_container;
>         std::string m_blob;
>         std::string m_destContainer;
>         std::string m_destBlob;
>     };
39,40c43
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/create_block_blob_request.h cpplite/include/blob/create_block_blob_request.h
5,6c5
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure { namespace storage_lite {
8,88c7,101
< class create_block_blob_request : public put_blob_request_base {
< public:
<     create_block_blob_request(const std::string &container, const std::string &blob)
<         : m_container(container),
<           m_blob(blob),
<           m_content_length(0) {}
< 
<     std::string container() const override {
<         return m_container;
<     }
< 
<     std::string blob() const override {
<         return m_blob;
<     }
< 
<     blob_type ms_blob_type() const override {
<         return blob_type::block_blob;
<     }
< 
<     unsigned int content_length() const override {
<         return m_content_length;
<     }
< 
<     create_block_blob_request &set_content_length(unsigned int content_length) {
<         m_content_length = content_length;
<         return *this;
<     }
< 
<     std::vector<std::pair<std::string, std::string>> metadata() const override {
<         return m_metadata;
<     }
< 
<     create_block_blob_request &set_metadata(const std::vector<std::pair<std::string, std::string>> &metadata) {
<         m_metadata = metadata;
<         return *this;
<     }
< 
< 
< private:
<     std::string m_container;
<     std::string m_blob;
< 
<     unsigned int m_content_length;
<     std::vector<std::pair<std::string, std::string>> m_metadata;
< };
< 
< class create_append_blob_request final : public create_block_blob_request {
< public:
<     create_append_blob_request(const std::string &container, const std::string &blob)
<         : create_block_blob_request(container, blob) {}
< 
<     blob_type ms_blob_type() const override {
<         return blob_type::append_blob;
<     }
< 
<     unsigned int content_length() const override {
<         return 0;
<     }
< };
< 
< class create_page_blob_request final : public create_block_blob_request {
< public:
<     create_page_blob_request(const std::string &container, const std::string &blob, unsigned long long size)
<         : create_block_blob_request(container, blob),
<           m_ms_blob_content_length(size) {}
< 
<     blob_type ms_blob_type() const override {
<         return blob_type::page_blob;
<     }
< 
<     unsigned int content_length() const override {
<         return 0;
<     }
< 
<     unsigned long long ms_blob_content_length() const override {
<         return m_ms_blob_content_length;
<     }
< 
< private:
<     unsigned long long m_ms_blob_content_length;
< };
---
>     class create_block_blob_request : public put_blob_request_base
>     {
>     public:
>         create_block_blob_request(const std::string &container, const std::string &blob)
>             : m_container(container),
>               m_blob(blob),
>               m_content_length(0) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string blob() const override
>         {
>             return m_blob;
>         }
> 
>         blob_type ms_blob_type() const override
>         {
>             return blob_type::block_blob;
>         }
> 
>         unsigned int content_length() const override
>         {
>             return m_content_length;
>         }
> 
>         create_block_blob_request &set_content_length(unsigned int content_length)
>         {
>             m_content_length = content_length;
>             return *this;
>         }
> 
>         std::vector<std::pair<std::string, std::string>> metadata() const override
>         {
>             return m_metadata;
>         }
> 
>         create_block_blob_request &set_metadata(const std::vector<std::pair<std::string, std::string>> &metadata)
>         {
>             m_metadata = metadata;
>             return *this;
>         }
> 
> 
>     private:
>         std::string m_container;
>         std::string m_blob;
> 
>         unsigned int m_content_length;
>         std::vector<std::pair<std::string, std::string>> m_metadata;
>     };
> 
>     class create_append_blob_request final : public create_block_blob_request
>     {
>     public:
>         create_append_blob_request(const std::string &container, const std::string &blob)
>             : create_block_blob_request(container, blob) {}
> 
>         blob_type ms_blob_type() const override
>         {
>             return blob_type::append_blob;
>         }
> 
>         unsigned int content_length() const override
>         {
>             return 0;
>         }
>     };
> 
>     class create_page_blob_request final : public create_block_blob_request {
>     public:
>         create_page_blob_request(const std::string &container, const std::string &blob, unsigned long long size)
>             : create_block_blob_request(container, blob),
>               m_ms_blob_content_length(size) {}
> 
>         blob_type ms_blob_type() const override
>         {
>             return blob_type::page_blob;
>         }
> 
>         unsigned int content_length() const override
>         {
>             return 0;
>         }
> 
>         unsigned long long ms_blob_content_length() const override
>         {
>             return m_ms_blob_content_length;
>         }
> 
>     private:
>         unsigned long long m_ms_blob_content_length;
>     };
90,91c103
< }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/create_container_request.h cpplite/include/blob/create_container_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure { namespace storage_lite {
8,12c7,12
<         class create_container_request final : public create_container_request_base {
<         public:
<             create_container_request(const std::string &container, blob_public_access public_access = blob_public_access::unspecified)
<                 : m_container(container),
<                 m_blob_public_access(public_access) {}
---
>     class create_container_request final : public create_container_request_base
>     {
>     public:
>         create_container_request(const std::string &container, blob_public_access public_access = blob_public_access::unspecified)
>             : m_container(container),
>             m_blob_public_access(public_access) {}
14,16c14,17
<             std::string container() const override {
<                 return m_container;
<             }
---
>         std::string container() const override
>         {
>             return m_container;
>         }
18,20c19,22
<             blob_public_access ms_blob_public_access() const override {
<                 return m_blob_public_access;
<             }
---
>         blob_public_access ms_blob_public_access() const override
>         {
>             return m_blob_public_access;
>         }
22,25c24,27
<         private:
<             std::string m_container;
<             blob_public_access m_blob_public_access;
<         };
---
>     private:
>         std::string m_container;
>         blob_public_access m_blob_public_access;
>     };
27,28c29
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/delete_blob_request.h cpplite/include/blob/delete_blob_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure { namespace storage_lite {
8,20c7,28
<         class delete_blob_request final : public delete_blob_request_base {
<         public:
<             delete_blob_request(const std::string &container, const std::string &blob, bool delete_snapshots_only = false)
<                 : m_container(container),
<                 m_blob(blob),
<                 m_delete_snapshots_only(delete_snapshots_only) {}
< 
<             std::string container() const override {
<                 return m_container;
<             }
< 
<             std::string blob() const override {
<                 return m_blob;
---
>     class delete_blob_request final : public delete_blob_request_base
>     {
>     public:
>         delete_blob_request(const std::string &container, const std::string &blob, bool delete_snapshots_only = false)
>             : m_container(container),
>             m_blob(blob),
>             m_delete_snapshots_only(delete_snapshots_only) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string blob() const override
>         {
>             return m_blob;
>         }
> 
>         delete_snapshots ms_delete_snapshots() const override
>         {
>             if (m_delete_snapshots_only) {
>                 return delete_snapshots::only;
22,29c30,31
< 
<             delete_snapshots ms_delete_snapshots() const override {
<                 if (m_delete_snapshots_only) {
<                     return delete_snapshots::only;
<                 }
<                 else {
<                     return delete_snapshots::include;
<                 }
---
>             else {
>                 return delete_snapshots::include;
30a33
>         }
32,36c35,39
<         private:
<             std::string m_container;
<             std::string m_blob;
<             bool m_delete_snapshots_only;
<         };
---
>     private:
>         std::string m_container;
>         std::string m_blob;
>         bool m_delete_snapshots_only;
>     };
38,39c41
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/delete_container_request.h cpplite/include/blob/delete_container_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
8,11c7,11
<         class delete_container_request final : public delete_container_request_base {
<         public:
<             delete_container_request(const std::string &container)
<                 : m_container(container) {}
---
>     class delete_container_request final : public delete_container_request_base
>     {
>     public:
>         delete_container_request(const std::string &container)
>             : m_container(container) {}
13,15c13,15
<             std::string container() const override {
<                 return m_container;
<             }
---
>         std::string container() const override {
>             return m_container;
>         }
17,19c17,19
<         private:
<             std::string m_container;
<         };
---
>     private:
>         std::string m_container;
>     };
21,22c21
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/download_blob_request.h cpplite/include/blob/download_blob_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure { namespace storage_lite {
8,49c7,54
<         class download_blob_request final : public get_blob_request_base {
<         public:
<             download_blob_request(const std::string &container, const std::string &blob)
<                 : m_container(container),
<                 m_blob(blob),
<                 m_start_byte(0),
<                 m_end_byte(0) {}
< 
<             std::string container() const override {
<                 return m_container;
<             }
< 
<             std::string blob() const override {
<                 return m_blob;
<             }
< 
<             unsigned long long start_byte() const override {
<                 return m_start_byte; 
<             }
< 
<             unsigned long long end_byte() const override { 
<                 return m_end_byte; 
<             }
< 
<             download_blob_request &set_start_byte(unsigned long long start_byte) {
<                 m_start_byte = start_byte;
<                 return *this;
<             }
< 
<             download_blob_request &set_end_byte(unsigned long long end_byte) {
<                 m_end_byte = end_byte;
<                 return *this;
<             }
< 
<         private:
<             std::string m_container;
<             std::string m_blob;
<             unsigned long long m_start_byte;
<             unsigned long long m_end_byte;
<         };
<     }
< }
---
>     class download_blob_request final : public get_blob_request_base
>     {
>     public:
>         download_blob_request(const std::string &container, const std::string &blob)
>             : m_container(container),
>             m_blob(blob),
>             m_start_byte(0),
>             m_end_byte(0) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string blob() const override
>         {
>             return m_blob;
>         }
> 
>         unsigned long long start_byte() const override
>         {
>             return m_start_byte; 
>         }
> 
>         unsigned long long end_byte() const override
>         { 
>             return m_end_byte; 
>         }
> 
>         download_blob_request &set_start_byte(unsigned long long start_byte)
>         {
>             m_start_byte = start_byte;
>             return *this;
>         }
> 
>         download_blob_request &set_end_byte(unsigned long long end_byte)
>         {
>             m_end_byte = end_byte;
>             return *this;
>         }
> 
>     private:
>         std::string m_container;
>         std::string m_blob;
>         unsigned long long m_start_byte;
>         unsigned long long m_end_byte;
>     };
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/get_blob_property_request.h cpplite/include/blob/get_blob_property_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
8,12c7,12
<         class get_blob_property_request final : public get_blob_property_request_base {
<         public:
<             get_blob_property_request(const std::string &container, const std::string &blob)
<                 : m_container(container),
<                 m_blob(blob) {}
---
>     class get_blob_property_request final : public get_blob_property_request_base
>     {
>     public:
>         get_blob_property_request(const std::string &container, const std::string &blob)
>             : m_container(container),
>             m_blob(blob) {}
14,16c14,17
<             std::string container() const override {
<                 return m_container;
<             }
---
>         std::string container() const override
>         {
>             return m_container;
>         }
18,20c19,22
<             std::string blob() const override {
<                 return m_blob;
<             }
---
>         std::string blob() const override
>         {
>             return m_blob;
>         }
22,25c24,27
<         private:
<             std::string m_container;
<             std::string m_blob;
<         };
---
>     private:
>         std::string m_container;
>         std::string m_blob;
>     };
27,28c29
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/get_block_list_request.h cpplite/include/blob/get_block_list_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
8,12c7,12
<         class get_block_list_request final : public get_block_list_request_base {
<         public:
<             get_block_list_request(const std::string &container, const std::string &blob)
<                 : m_container(container),
<                 m_blob(blob) {}
---
>     class get_block_list_request final : public get_block_list_request_base
>     {
>     public:
>         get_block_list_request(const std::string &container, const std::string &blob)
>             : m_container(container),
>             m_blob(blob) {}
14,16c14,17
<             std::string container() const override {
<                 return m_container;
<             }
---
>         std::string container() const override
>         {
>             return m_container;
>         }
18,20c19,22
<             std::string blob() const override {
<                 return m_blob;
<             }
---
>         std::string blob() const override
>         {
>             return m_blob;
>         }
22,25c24,27
<         private:
<             std::string m_container;
<             std::string m_blob;
<         };
---
>     private:
>         std::string m_container;
>         std::string m_blob;
>     };
27,28c29
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/get_container_property_request.h cpplite/include/blob/get_container_property_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
8,12c7,12
<         class get_container_property_request final : public get_container_property_request_base {
<         public:
<             get_container_property_request(const std::string &container)
<                 : m_container(container)
<             {}
---
>     class get_container_property_request final : public get_container_property_request_base
>     {
>     public:
>         get_container_property_request(const std::string &container)
>             : m_container(container)
>         {}
14,16c14,17
<             std::string container() const override {
<                 return m_container;
<             }
---
>         std::string container() const override
>         {
>             return m_container;
>         }
18,22c19,23
<         private:
<             std::string m_container;
<         };
<     }
< }
---
>     private:
>         std::string m_container;
>     };
> 
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/get_page_ranges_request.h cpplite/include/blob/get_page_ranges_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
8,47c7,53
<         class get_page_ranges_request final : public get_page_ranges_request_base {
<         public:
<             get_page_ranges_request(const std::string &container, const std::string &blob)
<                 : m_container(container),
<                 m_blob(blob),
<                 m_start_byte(0),
<                 m_end_byte(0) {}
< 
<             std::string container() const override {
<                 return m_container;
<             }
< 
<             std::string blob() const override {
<                 return m_blob;
<             }
< 
<             unsigned long long start_byte() const override {
<                 return m_start_byte;
<             }
< 
<             unsigned long long end_byte() const override {
<                 return m_end_byte;
<             }
< 
<             get_page_ranges_request &set_start_byte(unsigned long long start_byte) {
<                 m_start_byte = start_byte;
<                 return *this;
<             }
< 
<             get_page_ranges_request &set_end_byte(unsigned long long end_byte) {
<                 m_end_byte = end_byte;
<                 return *this;
<             }
< 
<         private:
<             std::string m_container;
<             std::string m_blob;
<             unsigned long long m_start_byte;
<             unsigned long long m_end_byte;
<         };
---
>     class get_page_ranges_request final : public get_page_ranges_request_base
>     {
>     public:
>         get_page_ranges_request(const std::string &container, const std::string &blob)
>             : m_container(container),
>             m_blob(blob),
>             m_start_byte(0),
>             m_end_byte(0) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string blob() const override
>         {
>             return m_blob;
>         }
> 
>         unsigned long long start_byte() const override
>         {
>             return m_start_byte;
>         }
> 
>         unsigned long long end_byte() const override
>         {
>             return m_end_byte;
>         }
> 
>         get_page_ranges_request &set_start_byte(unsigned long long start_byte)
>         {
>             m_start_byte = start_byte;
>             return *this;
>         }
> 
>         get_page_ranges_request &set_end_byte(unsigned long long end_byte)
>         {
>             m_end_byte = end_byte;
>             return *this;
>         }
> 
>     private:
>         std::string m_container;
>         std::string m_blob;
>         unsigned long long m_start_byte;
>         unsigned long long m_end_byte;
>     };
49,50c55
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/list_blobs_request.h cpplite/include/blob/list_blobs_request.h
5,6c5
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
8,105c7,120
< class list_blobs_request final : public list_blobs_request_base {
< public:
<     list_blobs_request(const std::string &container, const std::string &prefix)
<         : m_container(container),
<           m_prefix(prefix) {}
< 
<     std::string container() const override {
<         return m_container;
<     }
< 
<     std::string prefix() const override {
<         return m_prefix;
<     }
< 
<     std::string marker() const override {
<         return m_marker;
<     }
< 
<     int maxresults() const override {
<         return m_maxresults;
<     }
< 
<     list_blobs_request &set_marker(const std::string &marker) {
<         m_marker = marker;
<         return *this;
<     }
< 
<     list_blobs_request &set_maxresults(int maxresults) {
<         m_maxresults = maxresults;
<         return *this;
<     }
< 
< private:
<     std::string m_container;
<     std::string m_prefix;
<     std::string m_marker;
<     int m_maxresults;
< };
< 
< class list_blobs_hierarchical_request : public list_blobs_hierarchical_request_base {
< public:
<     list_blobs_hierarchical_request(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix)
<         : m_container(container),
<           m_prefix(prefix),
<           m_marker(continuation_token),
<           m_delimiter(delimiter),
<           m_maxresults(0) {}
< 
<     std::string container() const override {
<         return m_container;
<     }
< 
<     std::string prefix() const override {
<         return m_prefix;
<     }
< 
<     std::string marker() const override {
<         return m_marker;
<     }
< 
<     std::string delimiter() const override {
<         return m_delimiter;
<     }
< 
<     int maxresults() const override {
<         return m_maxresults;
<     }
< 
<     list_blobs_request_base::include includes() const override{ 
<         return m_includes; 
<     }
< 
< 
<     list_blobs_hierarchical_request &set_marker(const std::string &marker) {
<         m_marker = marker;
<         return *this;
<     }
< 
<     list_blobs_hierarchical_request &set_maxresults(int maxresults) {
<         m_maxresults = maxresults;
<         return *this;
<     }
< 
<     list_blobs_hierarchical_request &set_includes(list_blobs_request_base::include includes) {
<         m_includes = includes;
<         return *this;
<     }
< 
< private:
<     std::string m_container;
<     std::string m_prefix;
<     std::string m_marker;
<     std::string m_delimiter;
<     int m_maxresults;
<     list_blobs_request_base::include m_includes;
< };
< }
< }
---
>     class list_blobs_request final : public list_blobs_request_base
>     {
>     public:
>         list_blobs_request(const std::string &container, const std::string &prefix)
>             : m_container(container),
>               m_prefix(prefix) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string prefix() const override
>         {
>             return m_prefix;
>         }
> 
>         std::string marker() const override
>         {
>             return m_marker;
>         }
> 
>         int maxresults() const override
>         {
>             return m_maxresults;
>         }
> 
>         list_blobs_request &set_marker(const std::string &marker)
>         {
>             m_marker = marker;
>             return *this;
>         }
> 
>         list_blobs_request &set_maxresults(int maxresults)
>         {
>             m_maxresults = maxresults;
>             return *this;
>         }
> 
>     private:
>         std::string m_container;
>         std::string m_prefix;
>         std::string m_marker;
>         int m_maxresults;
>     };
> 
>     class list_blobs_segmented_request final : public list_blobs_segmented_request_base
>     {
>     public:
>         list_blobs_segmented_request(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix)
>             : m_container(container),
>               m_prefix(prefix),
>               m_marker(continuation_token),
>               m_delimiter(delimiter),
>               m_maxresults(0) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string prefix() const override
>         {
>             return m_prefix;
>         }
> 
>         std::string marker() const override
>         {
>             return m_marker;
>         }
> 
>         std::string delimiter() const override
>         {
>             return m_delimiter;
>         }
> 
>         int maxresults() const override
>         {
>             return m_maxresults;
>         }
> 
>         list_blobs_request_base::include includes() const override
>         { 
>             return m_includes; 
>         }
> 
> 
>         list_blobs_segmented_request &set_marker(const std::string &marker)
>         {
>             m_marker = marker;
>             return *this;
>         }
> 
>         list_blobs_segmented_request &set_maxresults(int maxresults)
>         {
>             m_maxresults = maxresults;
>             return *this;
>         }
> 
>         list_blobs_segmented_request &set_includes(list_blobs_request_base::include includes)
>         {
>             m_includes = includes;
>             return *this;
>         }
> 
>     private:
>         std::string m_container;
>         std::string m_prefix;
>         std::string m_marker;
>         std::string m_delimiter;
>         int m_maxresults;
>         list_blobs_request_base::include m_includes;
>     };
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/list_containers_request.h cpplite/include/blob/list_containers_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
8,45c7,51
<         class list_containers_request final : public list_containers_request_base {
<         public:
<             list_containers_request(const std::string &prefix, bool include_metadata = false)
<                 : m_prefix(prefix),
<                 m_include_metadata(include_metadata) {}
< 
<             std::string prefix() const override {
<                 return m_prefix;
<             }
< 
<             std::string marker() const override {
<                 return m_marker;
<             }
< 
<             int maxresults() const override {
<                 return m_maxresults;
<             }
< 
<             bool include_metadata() const override {
<                 return m_include_metadata;
<             }
< 
<             list_containers_request &set_marker(const std::string &marker) {
<                 m_marker = marker;
<                 return *this;
<             }
< 
<             list_containers_request &set_maxresults(int maxresults) {
<                 m_maxresults = maxresults;
<                 return *this;
<             }
< 
<         private:
<             std::string m_prefix;
<             std::string m_marker;
<             int m_maxresults;
<             bool m_include_metadata;
<         };
---
>     class list_containers_request final : public list_containers_request_base
>     {
>     public:
>         list_containers_request(const std::string &prefix, bool include_metadata = false)
>             : m_prefix(prefix),
>             m_include_metadata(include_metadata) {}
> 
>         std::string prefix() const override
>         {
>             return m_prefix;
>         }
> 
>         std::string marker() const override
>         {
>             return m_marker;
>         }
> 
>         int maxresults() const override
>         {
>             return m_maxresults;
>         }
> 
>         bool include_metadata() const override
>         {
>             return m_include_metadata;
>         }
> 
>         list_containers_request &set_marker(const std::string &marker)
>         {
>             m_marker = marker;
>             return *this;
>         }
> 
>         list_containers_request &set_maxresults(int maxresults)
>         {
>             m_maxresults = maxresults;
>             return *this;
>         }
> 
>     private:
>         std::string m_prefix;
>         std::string m_marker;
>         int m_maxresults;
>         bool m_include_metadata;
>     };
47,48c53
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/put_block_list_request.h cpplite/include/blob/put_block_list_request.h
5,6c5
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
8,45c7,51
< class put_block_list_request final : public put_block_list_request_base {
< public:
<     put_block_list_request(const std::string &container, const std::string &blob)
<         : m_container(container),
<           m_blob(blob) {}
< 
<     std::string container() const override {
<         return m_container;
<     }
< 
<     std::string blob() const override {
<         return m_blob;
<     }
< 
<     std::vector<block_item> block_list() const override {
<         return m_block_list;
<     }
< 
<     put_block_list_request &set_block_list(const std::vector<block_item> &block_list) {
<         m_block_list = block_list;
<         return *this;
<     }
< 
<     std::vector<std::pair<std::string, std::string>> metadata() const override {
<         return m_metadata;
<     }
< 
<     put_block_list_request &set_metadata(const std::vector<std::pair<std::string, std::string>> &metadata) {
<         m_metadata = metadata;
<         return *this;
<     }
< 
< private:
<     std::string m_container;
<     std::string m_blob;
<     std::vector<block_item> m_block_list;
<     std::vector<std::pair<std::string, std::string>> m_metadata;
< };
---
>     class put_block_list_request final : public put_block_list_request_base
>     {
>     public:
>         put_block_list_request(const std::string &container, const std::string &blob)
>             : m_container(container),
>             m_blob(blob) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string blob() const override
>         {
>             return m_blob;
>         }
> 
>         std::vector<block_item> block_list() const override
>         {
>             return m_block_list;
>         }
> 
>         put_block_list_request &set_block_list(const std::vector<block_item> &block_list)
>         {
>             m_block_list = block_list;
>             return *this;
>         }
> 
>         std::vector<std::pair<std::string, std::string>> metadata() const override
>         {
>             return m_metadata;
>         }
> 
>         put_block_list_request &set_metadata(const std::vector<std::pair<std::string, std::string>> &metadata)
>         {
>             m_metadata = metadata;
>             return *this;
>         }
> 
>     private:
>         std::string m_container;
>         std::string m_blob;
>         std::vector<block_item> m_block_list;
>         std::vector<std::pair<std::string, std::string>> m_metadata;
>     };
47,48c53
< }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/put_block_request.h cpplite/include/blob/put_block_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
8,40c7,45
<         class put_block_request final : public put_block_request_base {
<         public:
<             put_block_request(const std::string &container, const std::string &blob, const std::string &blockid)
<                 : m_container(container),
<                 m_blob(blob),
<                 m_blockid(blockid),
<                 m_content_length(0) {}
< 
<             std::string container() const override {
<                 return m_container;
<             }
< 
<             std::string blob() const override {
<                 return m_blob;
<             }
< 
<             std::string blockid() const override {
<                 return m_blockid;
<             }
< 
<             unsigned int content_length() const override {
<                 return m_content_length;
<             }
< 
<             put_block_request &set_content_length(unsigned int content_length) {
<                 m_content_length = content_length;
<                 return *this;
<             }
< 
<         private:
<             std::string m_container;
<             std::string m_blob;
<             std::string m_blockid;
---
>     class put_block_request final : public put_block_request_base
>     {
>     public:
>         put_block_request(const std::string &container, const std::string &blob, const std::string &blockid)
>             : m_container(container),
>             m_blob(blob),
>             m_blockid(blockid),
>             m_content_length(0) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string blob() const override
>         {
>             return m_blob;
>         }
> 
>         std::string blockid() const override
>         {
>             return m_blockid;
>         }
> 
>         unsigned int content_length() const override
>         {
>             return m_content_length;
>         }
> 
>         put_block_request &set_content_length(unsigned int content_length)
>         {
>             m_content_length = content_length;
>             return *this;
>         }
> 
>     private:
>         std::string m_container;
>         std::string m_blob;
>         std::string m_blockid;
42,43c47,48
<             unsigned int m_content_length;
<         };
---
>         unsigned int m_content_length;
>     };
45,46c50
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/blob/put_page_request.h cpplite/include/blob/put_page_request.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
8,69c7,77
<         class put_page_request final : public put_page_request_base {
<         public:
<             put_page_request(const std::string &container, const std::string &blob, bool clear = false)
<                 : m_container(container),
<                 m_blob(blob),
<                 m_clear(clear),
<                 m_start_byte(0),
<                 m_end_byte(0),
<                 m_content_length(0) {}
< 
<             std::string container() const override {
<                 return m_container;
<             }
< 
<             std::string blob() const override {
<                 return m_blob;
<             }
< 
<             unsigned long long start_byte() const override {
<                 return m_start_byte;
<             }
< 
<             unsigned long long end_byte() const override {
<                 return m_end_byte;
<             }
< 
<             put_page_request &set_start_byte(unsigned long long start_byte) {
<                 m_start_byte = start_byte;
<                 return *this;
<             }
< 
<             put_page_request &set_end_byte(unsigned long long end_byte) {
<                 m_end_byte = end_byte;
<                 return *this;
<             }
< 
<             page_write ms_page_write() const override {
<                 if (m_clear) {
<                     return page_write::clear;
<                 }
<                 return page_write::update;
<             }
< 
<             unsigned int content_length() const override {
<                 return m_content_length;
<             }
< 
<             put_page_request &set_content_length(unsigned int content_length) {
<                 m_content_length = content_length;
<                 return *this;
<             }
< 
<         private:
<             std::string m_container;
<             std::string m_blob;
<             bool m_clear;
<             unsigned long long m_start_byte;
<             unsigned long long m_end_byte;
<             unsigned int m_content_length;
<         };
<     }
< }
---
>     class put_page_request final : public put_page_request_base
>     {
>     public:
>         put_page_request(const std::string &container, const std::string &blob, bool clear = false)
>             : m_container(container),
>             m_blob(blob),
>             m_clear(clear),
>             m_start_byte(0),
>             m_end_byte(0),
>             m_content_length(0) {}
> 
>         std::string container() const override
>         {
>             return m_container;
>         }
> 
>         std::string blob() const override
>         {
>             return m_blob;
>         }
> 
>         unsigned long long start_byte() const override
>         {
>             return m_start_byte;
>         }
> 
>         unsigned long long end_byte() const override
>         {
>             return m_end_byte;
>         }
> 
>         put_page_request &set_start_byte(unsigned long long start_byte)
>         {
>             m_start_byte = start_byte;
>             return *this;
>         }
> 
>         put_page_request &set_end_byte(unsigned long long end_byte)
>         {
>             m_end_byte = end_byte;
>             return *this;
>         }
> 
>         page_write ms_page_write() const override
>         {
>             if (m_clear) {
>                 return page_write::clear;
>             }
>             return page_write::update;
>         }
> 
>         unsigned int content_length() const override
>         {
>             return m_content_length;
>         }
> 
>         put_page_request &set_content_length(unsigned int content_length)
>         {
>             m_content_length = content_length;
>             return *this;
>         }
> 
>     private:
>         std::string m_container;
>         std::string m_blob;
>         bool m_clear;
>         unsigned long long m_start_byte;
>         unsigned long long m_end_byte;
>         unsigned int m_content_length;
>     };
> }}  // azure::storage_lite
Only in cpplite/include/blob: set_blob_metadata_request.h
Only in cpplite/include/blob: set_container_metadata_request.h
diff -r azure-storage-cpp-lite-org/include/common.h cpplite/include/common.h
8,9c8,9
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
>     template<class... T> void unused(T&&...) {}
11,118c11,123
<         enum class lease_status {
<             locked,
<             unlocked
<         };
< 
<         enum class lease_state {
<             available,
<             leased,
<             expired,
<             breaking,
<             broken
<         };
< 
<         enum class lease_duration {
<             none,
<             infinite,
<             fixed
<         };
< 
<         enum class page_write {
<             update,
<             clear
<         };
< 
<         enum class payload_format {
<             json_fullmetadata,
<             json_nometadata
<         };
< 
<         // TODO: use the iterator for returned blob response.
<         //class my_iterator_base : public std::iterator<std::input_iterator_tag, std::pair<std::string, std::string>>
<         //{
<         //public:
<         //    virtual bool pass_end() const = 0;
<         //    virtual value_type operator*() = 0;
<         //    virtual void operator++() = 0;
<         //};
< 
<         //class iterator_base : public std::iterator<std::input_iterator_tag, std::pair<std::string, std::string>>
<         //{
<         //public:
<         //    iterator_base(std::shared_ptr<my_iterator_base> iterator) : m_iterator(iterator) {}
< 
<         //    bool operator!=(const iterator_base &other) const {
<         //        if (m_iterator->pass_end() && other.m_iterator->pass_end())
<         //            return false;
<         //        return true;
<         //    }
< 
<         //    value_type operator*() {
<         //        return **m_iterator;
<         //    }
< 
<         //    iterator_base &operator++() {
<         //        ++(*m_iterator);
<         //        return *this;
<         //    }
< 
<         //private:
<         //    std::shared_ptr<my_iterator_base> m_iterator;
<         //};
< 
<         //class A
<         //{
<         //public:
<         //    virtual iterator_base begin() = 0;
<         //    virtual iterator_base end() = 0;
<         //};
< 
<         //class my_iterator : public my_iterator_base
<         //{
<         //public:
<         //    my_iterator(std::map<std::string, std::string>::iterator i, std::map<std::string, std::string>::iterator e) : it(i), end_it(e) {}
< 
<         //    void operator++() override
<         //    {
<         //        ++it;
<         //    }
< 
<         //    value_type operator*() override
<         //    {
<         //        return std::make_pair(it->first, it->second);
<         //    }
< 
<         //    bool pass_end() const override
<         //    {
<         //        return it == end_it;
<         //    }
< 
<         //private:
<         //    std::map<std::string, std::string>::iterator it;
<         //    std::map<std::string, std::string>::iterator end_it;
<         //};
< 
<         //class B : public A
<         //{
<         //public:
<         //    iterator_base begin() override
<         //    {
<         //        return iterator_base(std::make_shared<my_iterator>(m.begin(), m.end()));
<         //    }
< 
<         //    iterator_base end() override
<         //    {
<         //        return iterator_base(std::make_shared<my_iterator>(m.end(), m.end()));
<         //    }
<         //    std::map<std::string, std::string> m;
<         //};
---
>     enum class lease_status
>     {
>         locked,
>         unlocked
>     };
> 
>     enum class lease_state
>     {
>         available,
>         leased,
>         expired,
>         breaking,
>         broken
>     };
> 
>     enum class lease_duration
>     {
>         none,
>         infinite,
>         fixed
>     };
> 
>     enum class page_write
>     {
>         update,
>         clear
>     };
> 
>     enum class payload_format
>     {
>         json_fullmetadata,
>         json_nometadata
>     };
> 
>     // TODO: use the iterator for returned blob response.
>     //class my_iterator_base : public std::iterator<std::input_iterator_tag, std::pair<std::string, std::string>>
>     //{
>     //public:
>     //    virtual bool pass_end() const = 0;
>     //    virtual value_type operator*() = 0;
>     //    virtual void operator++() = 0;
>     //};
> 
>     //class iterator_base : public std::iterator<std::input_iterator_tag, std::pair<std::string, std::string>>
>     //{
>     //public:
>     //    iterator_base(std::shared_ptr<my_iterator_base> iterator) : m_iterator(iterator) {}
> 
>     //    bool operator!=(const iterator_base &other) const {
>     //        if (m_iterator->pass_end() && other.m_iterator->pass_end())
>     //            return false;
>     //        return true;
>     //    }
> 
>     //    value_type operator*() {
>     //        return **m_iterator;
>     //    }
> 
>     //    iterator_base &operator++() {
>     //        ++(*m_iterator);
>     //        return *this;
>     //    }
> 
>     //private:
>     //    std::shared_ptr<my_iterator_base> m_iterator;
>     //};
> 
>     //class A
>     //{
>     //public:
>     //    virtual iterator_base begin() = 0;
>     //    virtual iterator_base end() = 0;
>     //};
> 
>     //class my_iterator : public my_iterator_base
>     //{
>     //public:
>     //    my_iterator(std::map<std::string, std::string>::iterator i, std::map<std::string, std::string>::iterator e) : it(i), end_it(e) {}
> 
>     //    void operator++() override
>     //    {
>     //        ++it;
>     //    }
> 
>     //    value_type operator*() override
>     //    {
>     //        return std::make_pair(it->first, it->second);
>     //    }
> 
>     //    bool pass_end() const override
>     //    {
>     //        return it == end_it;
>     //    }
> 
>     //private:
>     //    std::map<std::string, std::string>::iterator it;
>     //    std::map<std::string, std::string>::iterator end_it;
>     //};
> 
>     //class B : public A
>     //{
>     //public:
>     //    iterator_base begin() override
>     //    {
>     //        return iterator_base(std::make_shared<my_iterator>(m.begin(), m.end()));
>     //    }
> 
>     //    iterator_base end() override
>     //    {
>     //        return iterator_base(std::make_shared<my_iterator>(m.end(), m.end()));
>     //    }
>     //    std::map<std::string, std::string> m;
>     //};
120,121c125
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/compare.h cpplite/include/compare.h
15,16c15
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure { namespace storage_lite {
diff -r azure-storage-cpp-lite-org/include/constants.dat cpplite/include/constants.dat
5a6
> DAT(http_patch, "PATCH")
30a32
> DAT(query_maxResults, "maxResults")
31a34,37
> DAT(query_resource, "resource")
> DAT(query_resource_filesystem, "filesystem")
> DAT(query_resource_file, "file")
> DAT(query_resource_directory, "directory")
36,42c42,49
< DAT(param_mi_api_version, "api-version")
< DAT(param_mi_api_version_data, "2018-02-01")
< DAT(param_oauth_resource, "resource")
< DAT(param_oauth_resource_data, "https://storage.azure.com/")
< DAT(param_object_id, "object_id")
< DAT(param_client_id, "client_id")
< DAT(param_mi_res_id, "mi_res_id")
---
> DAT(query_recursive, "recursive")
> DAT(query_continuation, "continuation")
> DAT(query_action, "action")
> DAT(query_action_append, "append")
> DAT(query_action_flush, "flush")
> DAT(query_action_set_access_control, "setAccessControl")
> DAT(query_action_get_access_control, "getAccessControl")
> DAT(query_position, "position")
62,63d68
< DAT(header_metadata, "Metadata")
< DAT(header_msi_secret, "Secret")
89a95,100
> DAT(header_ms_continuation, "x-ms-continuation")
> DAT(header_ms_owner, "x-ms-owner")
> DAT(header_ms_group, "x-ms-group")
> DAT(header_ms_permissions, "x-ms-permissions")
> DAT(header_ms_acl, "x-ms-acl")
> DAT(header_ms_rename_source, "x-ms-rename-source")
91a103
> DAT(header_ms_meta_hdi_isfoler, "x-ms-meta-hdi_isfolder")
92a105
> DAT(header_value_content_type_json, "application/json")
104,105c117
< DAT(header_value_storage_version, "2018-11-09")
< DAT(header_value_metadata, "true")
---
> DAT(header_value_storage_blob_version, "2018-11-09")
107c119
< DAT(header_value_user_agent, "Azure-Storage-Fuse/1.2.3")
---
> DAT(header_value_user_agent, "azure-storage-cpplite/0.3.0")
113,116d124
< 
< DAT(msi_request_uri, "http://169.254.169.254/metadata/identity/oauth2/token")
< DAT(oauth_request_uri, "https://login.microsoftonline.com")
< DAT(spn_request_path, "oauth2/v2.0/token")
\ No newline at end of file
diff -r azure-storage-cpp-lite-org/include/constants.h cpplite/include/constants.h
3,5c3
< namespace microsoft_azure {
<     namespace storage {
<         namespace constants {
---
> #include <cstdint>
7c5,9
< #define DAT(x, y) extern const char *x; const int x ## _size{ sizeof(y) / sizeof(char) - 1 };
---
> #include "storage_EXPORTS.h"
> 
> namespace azure {  namespace storage_lite {  namespace constants {
> 
> #define DAT(x, y) extern AZURE_STORAGE_API const char *x; const int x ## _size{ sizeof(y) / sizeof(char) - 1 };
11,12c13,15
<             const int max_concurrency_oauth = 2;
<             const int max_retry_oauth = 5;
---
>     const uint64_t default_block_size = 8 * 1024 * 1024;
>     const uint64_t max_block_size = 100 * 1024 * 1024;
>     const uint64_t max_num_blocks = 50000;
14,17c17
<             const int max_concurrency_blob_wrapper = 20;
<         }
<     }
< }
---
> }}}  // azure::storage_lite::constants
diff -r azure-storage-cpp-lite-org/include/copy_blob_request_base.h cpplite/include/copy_blob_request_base.h
11,12c11
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
14,15c13,15
<         class copy_blob_request_base : public blob_request_base {
<         public:
---
>     class copy_blob_request_base : public blob_request_base
>     {
>     public:
17,21c17,18
<             virtual std::string container() const = 0;
<             virtual std::string blob() const = 0;
<             
<             virtual std::string destContainer() const = 0;
<             virtual std::string destBlob() const = 0;
---
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
23,24c20,21
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
---
>         virtual std::string destContainer() const = 0;
>         virtual std::string destBlob() const = 0;
26c23,24
<         //AZURE_STORAGE_API void build_request(const storage_account &a, const delete_blob_request_base &r, http_base &h);
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
28,29c26
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/create_container_request_base.h cpplite/include/create_container_request_base.h
12,13c12
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
15,27c14,22
<         class create_container_request_base : public blob_request_base {
<         public:
<             enum class blob_public_access {
<                 unspecified,
<                 container,
<                 blob
<             };
< 
<             virtual std::string container() const = 0;
< 
<             virtual blob_public_access ms_blob_public_access() const {
<                 return blob_public_access::unspecified;
<             }
---
>     class create_container_request_base : public blob_request_base
>     {
>     public:
>         enum class blob_public_access
>         {
>             unspecified,
>             container,
>             blob
>         };
29c24
<             //virtual std::map<std::string, std::string> ms_meta() const {};
---
>         virtual std::string container() const = 0;
31,32c26,29
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
---
>         virtual blob_public_access ms_blob_public_access() const
>         {
>             return blob_public_access::unspecified;
>         }
34c31,32
<         //AZURE_STORAGE_API void build_request(const storage_account &a, const create_container_request_base &r, http_base &h);
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
36,37c34
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/delete_blob_request_base.h cpplite/include/delete_blob_request_base.h
11,12c11
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
14,23c13,21
<         class delete_blob_request_base : public blob_request_base {
<         public:
<             enum class delete_snapshots {
<                 unspecified,
<                 include,
<                 only
<             };
< 
<             virtual std::string container() const = 0;
<             virtual std::string blob() const = 0;
---
>     class delete_blob_request_base : public blob_request_base
>     {
>     public:
>         enum class delete_snapshots
>         {
>             unspecified,
>             include,
>             only
>         };
25,26c23,24
<             virtual std::string snapshot() const { return std::string(); }
<             virtual delete_snapshots ms_delete_snapshots() const { return delete_snapshots::unspecified; }
---
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
28,29c26,27
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
---
>         virtual std::string snapshot() const { return std::string(); }
>         virtual delete_snapshots ms_delete_snapshots() const { return delete_snapshots::unspecified; }
31c29,30
<         //AZURE_STORAGE_API void build_request(const storage_account &a, const delete_blob_request_base &r, http_base &h);
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
33,34c32
<     }
< }
\ No newline at end of file
---
> }}  // azure::storage_lite
\ No newline at end of file
diff -r azure-storage-cpp-lite-org/include/delete_container_request_base.h cpplite/include/delete_container_request_base.h
12,13c12
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
15,17c14,17
<         class delete_container_request_base : public blob_request_base {
<         public:
<             virtual std::string container() const = 0;
---
>     class delete_container_request_base : public blob_request_base
>     {
>     public:
>         virtual std::string container() const = 0;
19,20c19,20
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
22,23c22
<     }
< }
---
> }}  // azure::storage_lite
\ No newline at end of file
diff -r azure-storage-cpp-lite-org/include/executor.h cpplite/include/executor.h
15a16
> #include "json_parser_base.h"
19,23c20,23
< #define HTTP_CODE_SERVICE_UNAVAILABLE 503 //Service unavailable
< namespace microsoft_azure {
<     namespace storage {
<         const char * const xml_parser_ex_literal = "Attempt at parsing XML response failed.";
<         class executor_context {
---
> namespace azure {  namespace storage_lite {
> 
>         class executor_context
>         {
29c29,30
<             std::shared_ptr<xml_parser_base> xml_parser() const {
---
>             std::shared_ptr<xml_parser_base> xml_parser() const
>             {
33c34,45
<             std::shared_ptr<retry_policy_base> retry_policy() const {
---
>             std::shared_ptr<json_parser_base> json_parser() const
>             {
>                 return m_json_parser;
>             }
> 
>             void set_json_parser(std::shared_ptr<json_parser_base> parser)
>             {
>                 m_json_parser = std::move(parser);
>             }
> 
>             std::shared_ptr<retry_policy_base> retry_policy() const
>             {
36a49,53
>             void set_retry_policy(std::shared_ptr<retry_policy_base> retry_policy)
>             {
>                 m_retry_policy = std::move(retry_policy);
>             }
> 
38a56
>             std::shared_ptr<json_parser_base> m_json_parser;
43c61,62
<         class async_executor {
---
>         class async_executor
>         {
45,66d63
<             static void submit_request(std::promise<storage_outcome<RESPONSE_TYPE>> &promise, const storage_account &a, const storage_request_base &r, http_base &h, const executor_context &context, retry_context &retry) {
<                 h.set_error_stream([](http_base::http_code) { return true; }, storage_iostream::create_storage_stream());
<                 r.build_request(a, h);
< 
<                 retry_info info = context.retry_policy()->evaluate(retry);
<                 if (info.should_retry()) {
<                     h.submit([&promise, &a, &r, &h, &context, &retry](http_base::http_code result, storage_istream s, CURLcode code) {
<                         std::string str(std::istreambuf_iterator<char>(s.istream()), std::istreambuf_iterator<char>());
<                         if (code != CURLE_OK || unsuccessful(result)) {
<                             promise.set_value(storage_outcome<RESPONSE_TYPE>(context.xml_parser()->parse_storage_error(str)));
<                             retry.add_result(code == CURLE_OK ? result : HTTP_CODE_SERVICE_UNAVAILABLE);
<                             h.reset_input_stream();
<                             h.reset_output_stream();
<                             async_executor<RESPONSE_TYPE>::submit_request(promise, a, r, h, context, retry);
<                         }
<                         else {
<                             promise.set_value(storage_outcome<RESPONSE_TYPE>(context.xml_parser()->parse_response<RESPONSE_TYPE>(str)));
<                         }
<                     }, info.interval());
<                 }
<             }
< 
75a73
>                 http->reset();
78c76,77
<                 retry_info info = context->retry_policy()->evaluate(*retry);
---
> 
>                 retry_info info = retry->numbers() == 0 ? retry_info(true, std::chrono::seconds(0)) : context->retry_policy()->evaluate(*retry);
83d81
<                         bool retry_response = false;
87d84
<                             //if we are unable to parse or did not find the values we needed to parse the error response
89,93c86
<                             try
<                             {
<                                 error = context->xml_parser()->parse_storage_error(str);
<                             }
<                             catch(std::invalid_argument& parser_error_except)
---
>                             if (code != CURLE_OK)
95,100c88,89
<                                 int sizeArray = strlen(xml_parser_ex_literal) + sizeof(" ") + strlen(parser_error_except.what());
<                                 char * cstr_parser_error = (char *)malloc(sizeArray);
<                                 strcpy(cstr_parser_error, xml_parser_ex_literal);
<                                 strcat(cstr_parser_error, " ");
<                                 strcat(cstr_parser_error, parser_error_except.what());
<                                 syslog(LOG_ERR, "%s", cstr_parser_error);
---
>                                 error.code = std::to_string(code);
>                                 error.code_name = curl_easy_strerror(code);
102c91
<                             catch(...)
---
>                             else
104c93,94
<                                 syslog(LOG_ERR, "%s",xml_parser_ex_literal);
---
>                                 error = context->xml_parser()->parse_storage_error(str);
>                                 error.code = std::to_string(result);
106,109c96
<                             retry_response = true;
<                             //to ensure the most helpful error code is returned, if the curl code returns ok
<                             //return the http error code
<                             error.code = std::to_string(code == CURLE_OK ? result : code);
---
> 
111c98,101
<                             retry->add_result(code == CURLE_OK ? result: HTTP_CODE_SERVICE_UNAVAILABLE);
---
>                             retry->add_result(code == CURLE_OK ? result: 503);
>                             http->reset_input_stream();
>                             http->reset_output_stream();
>                             async_executor<RESPONSE_TYPE>::submit_helper(promise, outcome, account, request, http, context, retry);
113c103
<                         else
---
>                         else if (http->get_response_header(constants::header_content_type).find(constants::header_value_content_type_json) != std::string::npos)
115,139c105,106
<                             //if we are unable to parse or did not find the values we needed to parse the response
<                             //something is corrupt in the response and we need to retry for a better response
<                             try
<                             {
<                                 *outcome = storage_outcome<RESPONSE_TYPE>(context->xml_parser()->parse_response<RESPONSE_TYPE>(str));
<                             }
<                             catch(std::invalid_argument& parser_error_except)
<                             {
<                                 retry_response = true;
<                                 int sizeArray = strlen(xml_parser_ex_literal) + sizeof(" ") + strlen(parser_error_except.what());
<                                 char * cstr_parser_error = (char *)malloc(sizeArray);
<                                 strcpy(cstr_parser_error, xml_parser_ex_literal);
<                                 strcat(cstr_parser_error, " ");
<                                 strcat(cstr_parser_error, parser_error_except.what());
<                                 syslog(LOG_ERR, "%s", cstr_parser_error);
<                             }
<                             catch(...)
<                             {
<                                 retry_response = true;
<                                 syslog(LOG_ERR, "%s", xml_parser_ex_literal);
<                             }
<                             if(!retry_response)
<                             {
<                                 promise->set_value(*outcome);
<                             }
---
>                             *outcome = storage_outcome<RESPONSE_TYPE>(context->json_parser()->parse_response<RESPONSE_TYPE>(str));
>                             promise->set_value(*outcome);
141,142c108
<                         //if we receive an error response or a parser error then retry the request for a better response
<                         if(retry_response)
---
>                         else
144,146c110,111
<                             http->reset_input_stream();
<                             http->reset_output_stream();
<                             async_executor<RESPONSE_TYPE>::submit_helper(promise, outcome, account, request, http, context, retry);
---
>                             *outcome = storage_outcome<RESPONSE_TYPE>(context->xml_parser()->parse_response<RESPONSE_TYPE>(str));
>                             promise->set_value(*outcome);
173,210d137
<             static void submit_request(std::promise<storage_outcome<void>> &promise, const storage_account &a, const storage_request_base &r, http_base &h, const executor_context &context, retry_context &retry) {
<                 h.set_error_stream(unsuccessful, storage_iostream::create_storage_stream());
<                 r.build_request(a, h);
< 
<                 retry_info info = context.retry_policy()->evaluate(retry);
<                 if (info.should_retry()) {
<                     h.submit([&promise, &a, &r, &h, &context, &retry](http_base::http_code result, storage_istream s, CURLcode code) {
<                         std::string str(std::istreambuf_iterator<char>(s.istream()), std::istreambuf_iterator<char>());
<                         if (code != CURLE_OK || unsuccessful(result)) {
<                             try
<                             {
<                                 promise.set_value(storage_outcome<void>(context.xml_parser()->parse_storage_error(str)));
<                             }
<                             catch(std::invalid_argument & parser_error_except)
<                             {
<                                 int sizeArray = strlen(xml_parser_ex_literal) + sizeof(" ") + strlen(parser_error_except.what());
<                                 char * cstr_parser_error = (char *)malloc(sizeArray);
<                                 strcpy(cstr_parser_error, xml_parser_ex_literal);
<                                 strcat(cstr_parser_error, " ");
<                                 strcat(cstr_parser_error, parser_error_except.what());
<                                 syslog(LOG_ERR, "%s", cstr_parser_error);
<                             }
<                             catch(...)
<                             {
<                                 syslog(LOG_ERR,"%s", xml_parser_ex_literal);
<                             }
<                             retry.add_result(code == CURLE_OK ? result : HTTP_CODE_SERVICE_UNAVAILABLE);
<                             h.reset_input_stream();
<                             h.reset_output_stream();
<                             async_executor<void>::submit_request(promise, a, r, h, context, retry);
<                         }
<                         else {
<                             promise.set_value(storage_outcome<void>());
<                         }
<                     }, info.interval());
<                 }
<             }
< 
224c151
<                 retry_info info = context->retry_policy()->evaluate(*retry);
---
>                 retry_info info = retry->numbers() == 0 ? retry_info(true, std::chrono::seconds(0)) : context->retry_policy()->evaluate(*retry);
229d155
<                         std::string str(std::istreambuf_iterator<char>(s.istream()), std::istreambuf_iterator<char>());
233,237c159
<                             try
<                             {
<                                 error = context->xml_parser()->parse_storage_error(str);
<                             }
<                             catch(std::invalid_argument & parser_error_except)
---
>                             if (code != CURLE_OK)
239,244c161,162
<                                 int sizeArray = strlen(xml_parser_ex_literal) + sizeof(" ") + strlen(parser_error_except.what());
<                                 char * cstr_parser_error = (char *)malloc(sizeArray);
<                                 strcpy(cstr_parser_error, xml_parser_ex_literal);
<                                 strcat(cstr_parser_error, " ");
<                                 strcat(cstr_parser_error, parser_error_except.what());
<                                 syslog(LOG_ERR, "%s", cstr_parser_error);
---
>                                 error.code = std::to_string(code);
>                                 error.code_name = curl_easy_strerror(code);
246c164
<                             catch(...)
---
>                             else
248c166,168
<                                 syslog(LOG_ERR,"%s", xml_parser_ex_literal);
---
>                                 std::string str(std::istreambuf_iterator<char>(s.istream()), std::istreambuf_iterator<char>());
>                                 error = context->xml_parser()->parse_storage_error(str);
>                                 error.code = std::to_string(result);
250,252c170
<                             //to ensure the most helpful error code is returned, if the curl code returns ok
<                             //return the http error code
<                             error.code = std::to_string(code == CURLE_OK ? result : code);
---
> 
254c172
<                             retry->add_result(code == CURLE_OK ? result: HTTP_CODE_SERVICE_UNAVAILABLE);
---
>                             retry->add_result(code == CURLE_OK ? result: 503);
287d204
< 
diff -r azure-storage-cpp-lite-org/include/get_blob_property_request_base.h cpplite/include/get_blob_property_request_base.h
12,13c12
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
15,23c14,34
<         class get_blob_property_request_base : public blob_request_base {
<         public:
<             virtual std::string container() const = 0;
<             virtual std::string blob() const = 0;
< 
<             virtual std::string snapshot() const { return std::string(); }
< 
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
---
>     class get_blob_property_request_base : public blob_request_base
>     {
>     public:
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
> 
>         virtual std::string snapshot() const { return std::string(); }
> 
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
> 
>     class blob_property
>     {
>     public:
>         blob_property() : m_valid(false) {}
> 
>         blob_property(bool valid)
>             :last_modified{time(NULL)},
>             m_valid(valid)
>         {
>         }
25c36,39
<         //AZURE_STORAGE_API void build_request(const storage_account &a, const get_blob_request_base &r, http_base &h);
---
>         void set_valid(bool valid)
>         {
>             m_valid = valid;
>         }
27c41
<         class blob_property
---
>         bool valid()
29,67c43,66
<         public:
<             blob_property(bool valid)
<                 :last_modified{time(NULL)},
<                 m_valid(valid)
<             {
<             }
< 
<             void set_valid(bool valid)
<             {
<                 m_valid = valid;
<             }
< 
<             bool valid()
<             {
<                 return m_valid;
<             }
< 
<             std::string cache_control;
<             std::string content_disposition;
<             std::string content_encoding;
<             std::string content_language;
<             unsigned long long size;
<             std::string content_md5;
<             std::string content_type;
<             std::string etag;
<             std::vector<std::pair<std::string, std::string>> metadata;
<             std::string copy_status;
<             time_t last_modified;
<             // blob_type m_type;
<             // azure::storage::lease_status m_lease_status;
<             // azure::storage::lease_state m_lease_state;
<             // azure::storage::lease_duration m_lease_duration;
< 
<         private:
<             blob_property() {}
<             bool m_valid;
<         };
<     }
< }
---
>             return m_valid;
>         }
> 
>         std::string cache_control;
>         std::string content_disposition;
>         std::string content_encoding;
>         std::string content_language;
>         unsigned long long size;
>         std::string content_md5;
>         std::string content_type;
>         std::string etag;
>         std::vector<std::pair<std::string, std::string>> metadata;
>         std::string copy_status;
>         time_t last_modified;
>         // TODO: support lease and blob_type
>         // blob_type m_type;
>         // azure::storage::lease_status m_lease_status;
>         // azure::storage::lease_state m_lease_state;
>         // azure::storage::lease_duration m_lease_duration;
> 
>     private:
>         bool m_valid;
>     };
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/get_blob_request_base.h cpplite/include/get_blob_request_base.h
11,12c11
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
14,17c13,17
<         class get_blob_request_base : public blob_request_base {
<         public:
<             virtual std::string container() const = 0;
<             virtual std::string blob() const = 0;
---
>     class get_blob_request_base : public blob_request_base
>     {
>     public:
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
19,23c19,23
<             virtual std::string snapshot() const { return std::string(); }
<             virtual unsigned long long start_byte() const { return 0; }
<             virtual unsigned long long end_byte() const { return 0; }
<             virtual std::string origin() const { return std::string(); }
<             virtual bool ms_range_get_content_md5() const { return false; }
---
>         virtual std::string snapshot() const { return std::string(); }
>         virtual unsigned long long start_byte() const { return 0; }
>         virtual unsigned long long end_byte() const { return 0; }
>         virtual std::string origin() const { return std::string(); }
>         virtual bool ms_range_get_content_md5() const { return false; }
25,26c25,26
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
28,30c28,34
<         //AZURE_STORAGE_API void build_request(const storage_account &a, const get_blob_request_base &r, http_base &h);
< 
<         class chunk_property
---
>     class chunk_property
>     {
>     public:
>         chunk_property()
>             :totalSize{0},
>             size{0},
>             last_modified{0} //returns 1970
32,45c36,42
<         public:
<             chunk_property()
<                :totalSize{0},
<                size{0},
<                last_modified{0} //returns 1970
<             {
<             }
<             long long totalSize;
<             unsigned long long size;
<             time_t last_modified;
<             std::string etag;
<         };
<     }
< }
---
>         }
>         long long totalSize;
>         unsigned long long size;
>         time_t last_modified;
>         std::string etag;
>     };
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/get_block_list_request_base.h cpplite/include/get_block_list_request_base.h
11,12c11
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
14,28c13,20
<         class get_block_list_request_base : public blob_request_base {
<         public:
<             enum class blocklisttypes {
<                 committed,
<                 uncommitted,
<                 all
<             };
< 
<             virtual std::string container() const = 0;
<             virtual std::string blob() const = 0;
< 
<             virtual std::string snapshot() const { return std::string(); }
<             virtual blocklisttypes blocklisttype() const { return blocklisttypes::all; }
< 
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
---
>     class get_block_list_request_base : public blob_request_base
>     {
>     public:
>         enum class blocklisttypes
>         {
>             committed,
>             uncommitted,
>             all
31c23,24
<         //AZURE_STORAGE_API void build_request(const storage_account &a, const get_blob_request_base &r, http_base &h);
---
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
33,37c26,27
<         class get_block_list_item {
<         public:
<             std::string name;
<             unsigned long long size;
<         };
---
>         virtual std::string snapshot() const { return std::string(); }
>         virtual blocklisttypes blocklisttype() const { return blocklisttypes::all; }
39,43c29,44
<         class get_block_list_response {
<         public:
<             std::vector<get_block_list_item> committed;
<             std::vector<get_block_list_item> uncommitted;
<         };
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
> 
>     class get_block_list_item
>     {
>     public:
>         std::string name;
>         unsigned long long size;
>     };
> 
>     class get_block_list_response
>     {
>     public:
>         std::vector<get_block_list_item> committed;
>         std::vector<get_block_list_item> uncommitted;
>     };
45,46c46
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/get_container_property_request_base.h cpplite/include/get_container_property_request_base.h
11,12c11
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
14,16c13,24
<         class get_container_property_request_base : public blob_request_base {
<         public:
<             virtual std::string container() const = 0;
---
>     class get_container_property_request_base : public blob_request_base
>     {
>     public:
>         virtual std::string container() const = 0;
> 
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
> 
>     class container_property
>     {
>     public:
>         container_property() : m_valid(false) {}
18,19c26,29
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
---
>         container_property(bool valid)
>             :m_valid(valid)
>         {
>         }
21c31,34
<         //AZURE_STORAGE_API void build_request(const storage_account &a, const get_blob_request_base &r, http_base &h);
---
>         void set_valid(bool valid)
>         {
>             m_valid = valid;
>         }
23c36
<         class container_property
---
>         bool valid()
25,49c38,47
<         public:
<             container_property(bool valid)
<                 :m_valid(valid)
<             {
<             }
< 
<             void set_valid(bool valid)
<             {
<                 m_valid = valid;
<             }
< 
<             bool valid()
<             {
<                 return m_valid;
<             }
< 
<             std::string etag;
<             std::vector<std::pair<std::string, std::string>> metadata;
< 
<         private:
<             container_property() {}
<             bool m_valid;
<         };
<     }
< }
---
>             return m_valid;
>         }
> 
>         std::string etag;
>         std::vector<std::pair<std::string, std::string>> metadata;
> 
>     private:
>         bool m_valid;
>     };
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/get_page_ranges_request_base.h cpplite/include/get_page_ranges_request_base.h
11,12c11
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
14,17c13,38
<         class get_page_ranges_request_base : public blob_request_base {
<         public:
<             virtual std::string container() const = 0;
<             virtual std::string blob() const = 0;
---
>     class get_page_ranges_request_base : public blob_request_base
>     {
>     public:
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
> 
>         virtual unsigned long long start_byte() const { return 0; }
>         virtual unsigned long long end_byte() const { return 0; }
> 
>         virtual std::string snapshot() const { return std::string(); }
> 
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
> 
>     class get_page_ranges_item
>     {
>     public:
>         unsigned long long start;
>         unsigned long long end;
>     };
> 
>     class get_page_ranges_response
>     {
>     public:
>         std::vector<get_page_ranges_item> pagelist;
>     };
19,41c40
<             virtual unsigned long long start_byte() const { return 0; }
<             virtual unsigned long long end_byte() const { return 0; }
< 
<             virtual std::string snapshot() const { return std::string(); }
< 
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
< 
<         //AZURE_STORAGE_API void build_request(const storage_account &a, const get_blob_request_base &r, http_base &h);
< 
<         class get_page_ranges_item {
<         public:
<             unsigned long long start;
<             unsigned long long end;
<         };
< 
<         class get_page_ranges_response {
<         public:
<             std::vector<get_page_ranges_item> pagelist;
<         };
< 
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/hash.h cpplite/include/hash.h
6,11d5
< #ifdef WIN32
< #include <Windows.h>
< #include <bcrypt.h>
< #else
< #include <gnutls/gnutls.h>
< #include <gnutls/crypto.h>
13d6
< #endif
17,21c10,12
< namespace microsoft_azure {
<     namespace storage {
<         AZURE_STORAGE_API std::string hash_impl(const std::string &input, const std::vector<unsigned char> &key);
<     }
< }
---
> namespace azure {  namespace storage_lite {
>     AZURE_STORAGE_API std::string hash(const std::string &to_sign, const std::vector<unsigned char> &key);
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/http/libcurl_http_client.h cpplite/include/http/libcurl_http_client.h
17,18d16
< #include <syslog.h>
< #include <utility.h>
24,25c22
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
27c24
<         std::string to_lower(std::string original);
---
>     class CurlEasyClient;
29c26,27
<         class CurlEasyClient;
---
>     class CurlEasyRequest final : public http_base
>     {
31,34c29
<         class CurlEasyRequest final : public http_base
<         {
< 
<             using REQUEST_TYPE = CurlEasyRequest;
---
>         using REQUEST_TYPE = CurlEasyRequest;
36,37c31,32
<             public:
<                 AZURE_STORAGE_API CurlEasyRequest(std::shared_ptr<CurlEasyClient> client, CURL *h);
---
>     public:
>         AZURE_STORAGE_API CurlEasyRequest(std::shared_ptr<CurlEasyClient> client, CURL *h);
39,43c34
<                 AZURE_STORAGE_API ~CurlEasyRequest();
< 
<                 void set_url(const std::string &url) override {
<                     m_url = url;
<                 }
---
>         AZURE_STORAGE_API ~CurlEasyRequest();
45,51c36,39
<                 std::string get_url() const override {
<                     return m_url;
<                 }
< 
<                 void set_method(http_method method) override {
<                     m_method = method;
<                 }
---
>         void set_url(const std::string &url) override
>         {
>             m_url = url;
>         }
53,55c41,44
<                 http_method get_method() const override {
<                     return m_method;
<                 }
---
>         std::string get_url() const override
>         {
>             return m_url;
>         }
57,67c46,49
<                 void add_header(const std::string &name, const std::string &value) override {
<                     std::string header(name);
<                     header.append(": ").append(value);
<                     m_slist = curl_slist_append(m_slist, header.data());
<                     if (name == "Content-Length") {
<                         unsigned int l;
<                         std::istringstream iss(value);
<                         iss >> l;
<                         curl_easy_setopt(m_curl, CURLOPT_INFILESIZE, l);
<                     }
<                 }
---
>         void set_method(http_method method) override
>         {
>             m_method = method;
>         }
69,82c51,54
<                 std::string get_header(const std::string &name) const override {
<                     auto iter = m_headers.find(name);
<                     if (iter != m_headers.end())
<                     {
<                         return iter->second;
<                     }
<                     else
<                     {
<                         return "";
<                     }
<                 }
<                 const std::map<std::string, std::string, case_insensitive_compare>& get_headers() const override {
<                     return m_headers;
<                 }
---
>         http_method get_method() const override
>         {
>             return m_method;
>         }
84c56,68
<                 AZURE_STORAGE_API CURLcode perform() override;
---
>         void add_header(const std::string &name, const std::string &value) override
>         {
>             m_request_headers.emplace(name, value);
>             std::string header(name);
>             header.append(": ").append(value);
>             m_slist = curl_slist_append(m_slist, header.data());
>             if (name == "Content-Length") {
>                 unsigned int l;
>                 std::istringstream iss(value);
>                 iss >> l;
>                 curl_easy_setopt(m_curl, CURLOPT_INFILESIZE, l);
>             }
>         }
86,88c70,73
<                 void submit(std::function<void(http_code, storage_istream, CURLcode)> cb, std::chrono::seconds interval) override {
<                     std::this_thread::sleep_for(interval);
<                     const auto curlCode = perform();
---
>         const std::map<std::string, std::string, case_insensitive_compare>& get_request_headers() const override
>         {
>             return m_request_headers;
>         }
90c75,90
<                     syslog(curlCode != CURLE_OK || unsuccessful(m_code) ? LOG_ERR : LOG_DEBUG, "%s", format_request_response().c_str());
---
>         std::string get_response_header(const std::string &name) const override
>         {
>             auto iter = m_response_headers.find(name);
>             if (iter != m_response_headers.end())
>             {
>                 return iter->second;
>             }
>             else
>             {
>                 return "";
>             }
>         }
>         const std::map<std::string, std::string, case_insensitive_compare>& get_response_headers() const override
>         {
>             return m_response_headers;
>         }
92,93c92
<                     cb(m_code, m_error_stream, curlCode);
<                 }
---
>         AZURE_STORAGE_API CURLcode perform() override;
95,102c94,99
<                 void reset() override {
<                     m_headers.clear();
<                     curl_slist_free_all(m_slist);
<                     m_slist = NULL;
<                     //curl_easy_setopt(m_curl, CURLOPT_INFILESIZE, -1);
<                     //curl_easy_setopt(m_curl, CURLOPT_WRITEFUNCTION, NULL);
<                     //curl_easy_setopt(m_curl, CURLOPT_READFUNCTION, NULL);
<                 }
---
>         void submit(std::function<void(http_code, storage_istream, CURLcode)> cb, std::chrono::seconds interval) override
>         {
>             std::this_thread::sleep_for(interval);
>             const auto curlCode = perform();
>             cb(m_code, m_error_stream, curlCode);
>         }
104,106c101,107
<                 http_code status_code() const override {
<                     return m_code;
<                 }
---
>         void reset() override
>         {
>             m_request_headers.clear();
>             m_response_headers.clear();
>             curl_slist_free_all(m_slist);
>             m_slist = NULL;
>         }
108,124c109,112
<                 /*void set_output_callback(OUT_CB output_callback) override {
<                     m_output_callback = output_callback;
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_WRITEFUNCTION, write_callback));
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_WRITEDATA, this));
<                 }*/
< 
<                 /*void set_input_callback(IN_CB input_callback) override {
<                     m_input_callback = input_callback;
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_READFUNCTION, read_callback));
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_READDATA, this));
<                 }*/
< 
<                 void set_output_stream(storage_ostream s) override {
<                     m_output_stream = s;
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_WRITEFUNCTION, write));
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_WRITEDATA, this));
<                 }
---
>         http_code status_code() const override
>         {
>             return m_code;
>         }
126,131c114,119
<                 void set_error_stream(std::function<bool(http_code)> f, storage_iostream s) override {
<                     m_switch_error_callback = f;
<                     m_error_stream = s;
<                     //check_code(curl_easy_setopt(m_curl, CURLOPT_WRITEFUNCTION, write));
<                     //check_code(curl_easy_setopt(m_curl, CURLOPT_WRITEDATA, this));
<                 }
---
>         void set_output_stream(storage_ostream s) override
>         {
>             m_output_stream = s;
>             check_code(curl_easy_setopt(m_curl, CURLOPT_WRITEFUNCTION, write));
>             check_code(curl_easy_setopt(m_curl, CURLOPT_WRITEDATA, this));
>         }
133,138c121,125
<                 void set_input_stream(storage_istream s) override {
<                     m_input_stream = s;
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_READFUNCTION, read));
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_READDATA, this));
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_POSTFIELDS, nullptr)); // CURL won't actually read data on POSTs unless this is explicitly set.
<                 }
---
>         void set_error_stream(std::function<bool(http_code)> f, storage_iostream s) override
>         {
>             m_switch_error_callback = f;
>             m_error_stream = s;
>         }
140,146c127,132
<                 void set_input_buffer(char* buff) override
<                 {
<                     m_input_buffer = buff;
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_READFUNCTION, read));
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_READDATA, this));
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_POSTFIELDS, nullptr)); // CURL won't actually read data on POSTs unless this is explicitly set.
<                 }
---
>         void set_input_stream(storage_istream s) override
>         {
>             m_input_stream = s;
>             check_code(curl_easy_setopt(m_curl, CURLOPT_READFUNCTION, read));
>             check_code(curl_easy_setopt(m_curl, CURLOPT_READDATA, this));
>         }
148,151c134,137
<                 void set_input_content_length(size_t content_length)
<                 {
<                     m_input_content_length=content_length;
<                 }
---
>         void set_input_content_length(uint64_t content_length)
>         {
>             m_input_content_length = content_length;
>         }
153,156c139,142
<                 size_t get_input_content_length(void)
<                 {
<                     return m_input_content_length;
<                 }
---
>         void set_is_input_length_known(void)
>         {
>             m_is_input_length_known = true;
>         }
158,161c144,147
<                 void set_is_input_length_known(void)
<                 {
<                     m_is_input_length_known=true;
<                 }
---
>         bool get_is_input_length_known(void)
>         {
>             return m_is_input_length_known;
>         }
163,169c149,153
<                 bool get_is_input_length_known(void)
<                 {
<                     return m_is_input_length_known;
<                 }
<                 void reset_input_stream() override {
<                     m_input_stream.reset();
<                 }
---
>         void reset_input_stream() override
>         {
>             m_input_stream.reset();
>             m_input_read_pos = 0;
>         }
171,173c155,158
<                 void reset_output_stream() override {
<                     m_output_stream.reset();
<                 }
---
>         void reset_output_stream() override
>         {
>             m_output_stream.reset();
>         }
175,177c160,163
<                 storage_ostream get_output_stream() const override {
<                     return m_output_stream;
<                 }
---
>         storage_ostream get_output_stream() const override
>         {
>             return m_output_stream;
>         }
179,181c165,168
<                 storage_iostream get_error_stream() const override {
<                     return m_error_stream;
<                 }
---
>         storage_iostream get_error_stream() const override
>         {
>             return m_error_stream;
>         }
183,185c170,173
<                 storage_istream get_input_stream() const override {
<                     return m_input_stream;
<                 }
---
>         storage_istream get_input_stream() const override
>         {
>             return m_input_stream;
>         }
187,188c175,177
<                 void set_absolute_timeout(long long timeout) override {
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_TIMEOUT, timeout)); // Absolute timeout
---
>         void set_absolute_timeout(long long timeout) override
>         {
>             check_code(curl_easy_setopt(m_curl, CURLOPT_TIMEOUT, timeout)); // Absolute timeout
190,193c179,182
<                     // For the moment, we are only using one type of timeout per operation, so we clear the other one, in case it was set for this handle by a prior operation:
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_LOW_SPEED_TIME, 0L));
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_LOW_SPEED_LIMIT, 0L));
<                 }
---
>             // For the moment, we are only using one type of timeout per operation, so we clear the other one, in case it was set for this handle by a prior operation:
>             check_code(curl_easy_setopt(m_curl, CURLOPT_LOW_SPEED_TIME, 0L)); 
>             check_code(curl_easy_setopt(m_curl, CURLOPT_LOW_SPEED_LIMIT, 0L));
>         }
195,198c184,208
<                 void set_data_rate_timeout() override {
<                     // If the download speed is less than 17KB/sec for more than a minute, timout. This time was selected because it should ensure that downloading each megabyte take no more than a minute.
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_LOW_SPEED_TIME, 60L));
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_LOW_SPEED_LIMIT, 1024L * 17L));
---
>         void set_data_rate_timeout() override
>         {
>             // If the download speed is less than 17KB/sec for more than a minute, timout. This time was selected because it should ensure that downloading each megabyte take no more than a minute.
>             check_code(curl_easy_setopt(m_curl, CURLOPT_LOW_SPEED_TIME, 60L)); 
>             check_code(curl_easy_setopt(m_curl, CURLOPT_LOW_SPEED_LIMIT, 1024L * 17L));
> 
>             // For the moment, we are only using one type of timeout per operation, so we clear the other one, in case it was set for this handle by a prior operation:
>             check_code(curl_easy_setopt(m_curl, CURLOPT_TIMEOUT, 0L));
>         }
> 
>     private:
>         std::shared_ptr<CurlEasyClient> m_client;
>         CURL *m_curl;
>         curl_slist *m_slist;
>         std::map<std::string, std::string, case_insensitive_compare> m_request_headers;
> 
>         http_method m_method;
>         std::string m_url;
>         storage_istream m_input_stream;
>         storage_ostream m_output_stream;
>         storage_iostream m_error_stream;
>         uint64_t m_input_content_length = 0;
>         uint64_t m_input_read_pos = 0;
>         bool m_is_input_length_known = false;
>         std::function<bool(http_code)> m_switch_error_callback;
200,202c210,211
<                     // For the moment, we are only using one type of timeout per operation, so we clear the other one, in case it was set for this handle by a prior operation:
<                     check_code(curl_easy_setopt(m_curl, CURLOPT_TIMEOUT, 0L));
<                 }
---
>         http_code m_code;
>         std::map<std::string, std::string, case_insensitive_compare> m_response_headers;
204,220c213
<             private:
<                 std::shared_ptr<CurlEasyClient> m_client;
<                 CURL *m_curl;
<                 curl_slist *m_slist;
< 
<                 http_method m_method;
<                 std::string m_url;
<                 char* m_input_buffer = NULL;
<                 int m_input_buffer_pos = 0;
<                 storage_istream m_input_stream;
<                 storage_ostream m_output_stream;
<                 storage_iostream m_error_stream;
<                 size_t m_input_content_length;
<                 bool m_is_input_length_known;
<                 std::function<bool(http_code)> m_switch_error_callback;
<                 http_code m_code;
<                 std::map<std::string, std::string, case_insensitive_compare> m_headers;
---
>         AZURE_STORAGE_API static size_t header_callback(char *buffer, size_t size, size_t nitems, void *userdata);
222,277c215,220
<                 std::string format_request_response()
<                 {
<                     std::string out;
<                     auto currentTime = std::time(nullptr);
<                     auto timestamp = std::asctime(std::localtime(&currentTime));
< 
<                     auto sigLoc = m_url.find("sig=");
<                     auto tmpURL = m_url;
< 
<                     if (sigLoc != std::string::npos) {
<                         // Find the string and replace the segment
<                         for(auto i = sigLoc; i < tmpURL.length(); i++) {
<                             if(tmpURL[i] == '&' || i == tmpURL.length()-1) {
<                                 auto count =
<                                         (i - sigLoc) + // The real count, if we landed on &
<                                         (i == tmpURL.length() - 1 ? 1 : 0); // If we're at the end, trim to the end.
<                                 tmpURL.replace(sigLoc, count, "sig=REDACTED");
<                                 break;
<                             }
<                         }
<                     }
< 
<                     out += timestamp;
<                     out.erase(out.end()-1);
<                     out += " ==> REQUEST/RESPONSE\n";
<                     out += "\t" + http_method_label[m_method] + " " + tmpURL + "\n";
< 
<                     // our headers
<                     for(auto x = m_slist; x->next != nullptr; x = x->next) {
<                         std::string header = std::string(x->data);
<                         auto splitAt = header.find(':');
< 
<                         if (splitAt != header.length() - 1) {
<                             std::string name = header.substr(0, splitAt);
<                             std::string value = header.substr(splitAt + 2);
< 
<                             if(to_lower(name) == "authorization" || to_lower(name) == "secret") {
<                                 value = "REDACTED";
<                             }
< 
<                             out = out.append("\t").append(name).append(": [").append(value).append("]\n");
<                         } else {
<                             out = out.append("\t").append(header.substr(0, splitAt)).append(": []").append("\n");
<                         }
<                     }
< 
<                     out += "\t--------------------------------------------------------------------------------\n";
<                     out += "\tRESPONSE Status: " + std::to_string(m_code) + "\n";
< 
<                     // their headers
<                     for(const auto& pair : m_headers) {
<                         auto lineReturn = pair.second.find('\n');
<                         // ternary statement also trims the carriage return character, which accidentally clears lines.
<                         auto trimmed_str = pair.second.substr(0, pair.second[lineReturn - 1] == '\r' ? lineReturn - 1 : lineReturn );
<                         out = out.append("\t").append(pair.first).append(": [").append(trimmed_str).append("]\n");
<                     }
---
>         static size_t write(char *buffer, size_t size, size_t nitems, void *userdata)
>         {
>             REQUEST_TYPE *p = static_cast<REQUEST_TYPE *>(userdata);
>             p->m_output_stream.ostream().write(buffer, size * nitems);
>             return size * nitems;
>         }
279,280c222,227
<                     return out;
<                 }
---
>         static size_t error(char *buffer, size_t size, size_t nitems, void *userdata)
>         {
>             REQUEST_TYPE *p = static_cast<REQUEST_TYPE *>(userdata);
>             p->m_error_stream.ostream().write(buffer, size * nitems);
>             return size * nitems;
>         }
282c229,231
<                 AZURE_STORAGE_API static size_t header_callback(char *buffer, size_t size, size_t nitems, void *userdata);
---
>         static size_t read(char *buffer, size_t size, size_t nitems, void *userdata)
>         {
>             REQUEST_TYPE *p = static_cast<REQUEST_TYPE *>(userdata);
284c233,237
<                 static size_t write(char *buffer, size_t size, size_t nitems, void *userdata)
---
>             size_t actual_size = 0;
>             if (p->m_input_stream.valid())
>             {
>                 auto &s = p->m_input_stream.istream();
>                 if (p->get_is_input_length_known())
286,288c239
<                     REQUEST_TYPE *p = static_cast<REQUEST_TYPE *>(userdata);
<                     p->m_output_stream.ostream().write(buffer, size * nitems);
<                     return size * nitems;
---
>                     actual_size = size_t(std::min(uint64_t(size * nitems), p->m_input_content_length - p->m_input_read_pos));
290,291c241
< 
<                 static size_t error(char *buffer, size_t size, size_t nitems, void *userdata)
---
>                 else
293,295c243,247
<                     REQUEST_TYPE *p = static_cast<REQUEST_TYPE *>(userdata);
<                     p->m_error_stream.ostream().write(buffer, size * nitems);
<                     return size * nitems;
---
>                     std::streampos cur_pos = s.tellg();
>                     s.seekg(0, std::ios_base::end);
>                     std::streampos end_pos = s.tellg();
>                     s.seekg(cur_pos, std::ios_base::beg);
>                     actual_size = size_t(std::min(uint64_t(size * nitems), uint64_t(end_pos - cur_pos)));
297,298c249,250
< 
<                 static size_t read(char *buffer, size_t size, size_t nitems, void *userdata)
---
>                 s.read(buffer, actual_size);
>                 if (s.fail())
300,331c252
<                     REQUEST_TYPE *p = static_cast<REQUEST_TYPE *>(userdata);
<                     auto &s = p->m_input_stream.istream();
<                     size_t contentlen = p->get_input_content_length();
<                     size_t actual_size = 0 ;
<                     if( ! p->get_is_input_length_known() ) {
<                         auto cur = s.tellg();
<                         s.seekg(0, std::ios_base::end);
<                         auto end = s.tellg();
<                         s.seekg(cur);
<                         actual_size = std::min(static_cast<size_t>(end-cur), size * nitems);
<                     }
<                     else
<                     {
<                         actual_size = std::min(contentlen, size * nitems);
<                     }
< 
<                     if (p->m_input_buffer != NULL)
<                     {
<                         memcpy(buffer, p->m_input_buffer + p->m_input_buffer_pos, actual_size);
<                         p->m_input_buffer_pos += actual_size;
<                     }
<                     else
<                     {
<                         s.read(buffer, actual_size);
<                     }
< 
<                     if(p->get_is_input_length_known()) {
<                         contentlen -= actual_size;
<                         p->set_input_content_length(contentlen);
<                     }
< 
<                     return actual_size;
---
>                     return CURL_READFUNC_ABORT;
332a254,256
>                 actual_size = static_cast<size_t>(s.gcount());
>                 p->m_input_read_pos += actual_size;
>             }
334,344c258,259
<                 static void check_code(CURLcode code, std::string = std::string())
<                 {
<                     if (code != CURLE_OK) {
<                         //std::cout << s << ":" << curl_easy_strerror(code) << std::endl;
<                     }
<                     else
<                     {
<                         errno = 0; // CURL sometimes sets errno internally, if everything was ok we should reset it to zero.
<                     }
<                 }
<             };
---
>             return actual_size;
>         }
346,356c261,263
<         class CurlEasyClient : public std::enable_shared_from_this<CurlEasyClient> {
<         public:
<             CurlEasyClient(int size) : m_size(size) {
<                 curl_global_init(CURL_GLOBAL_DEFAULT);
<                 for (int i = 0; i < m_size; i++) {
<                     CURL *h = curl_easy_init();
<                     m_handles.push(h);
<                 }
<             }
<             //Sets CURL CA BUNDLE location for all the curl handlers.
<             CurlEasyClient(int size, const std::string& ca_path) : m_size(size)
---
>         static void check_code(CURLcode code, std::string = std::string())
>         {
>             if (code == CURLE_OK)
358,363c265
<                 curl_global_init(CURL_GLOBAL_DEFAULT);
<                 for (int i = 0; i < m_size; i++) {
<                     CURL *h = curl_easy_init();
<                     curl_easy_setopt(h, CURLOPT_CAPATH, ca_path.c_str());
<                     m_handles.push(h);
<                 }
---
>                 errno = 0; // CURL sometimes sets errno internally, if everything was ok we should reset it to zero.
364a267,268
>         }
>     };
366,371c270,278
<             ~CurlEasyClient() {
<                 while (!m_handles.empty()) {
<                     curl_easy_cleanup(m_handles.front());
<                     m_handles.pop();
<                 }
<                 curl_global_cleanup();
---
>     class CurlEasyClient : public std::enable_shared_from_this<CurlEasyClient>
>     {
>     public:
>         CurlEasyClient(int size) : m_size(size)
>         {
>             curl_global_init(CURL_GLOBAL_DEFAULT);
>             for (int i = 0; i < m_size; i++) {
>                 CURL *h = curl_easy_init();
>                 m_handles.push(h);
372a280
>         }
374,376c282,288
<             int size()
<             {
<                 return m_size;
---
>         //Sets CURL CA BUNDLE location for all the curl handlers.
>         CurlEasyClient(int size, const std::string& ca_path) : m_size(size), m_capath(ca_path)
>         {
>             curl_global_init(CURL_GLOBAL_DEFAULT);
>             for (int i = 0; i < m_size; i++) {
>                 CURL *h = curl_easy_init();
>                 m_handles.push(h);
377a290
>         }
379,382c292,295
<             std::shared_ptr<CurlEasyRequest> get_handle() {
<                 std::unique_lock<std::mutex> lk(m_handles_mutex);
<                 m_cv.wait(lk, [this]() { return !m_handles.empty(); });
<                 auto res = std::make_shared<CurlEasyRequest>(shared_from_this(), m_handles.front());
---
>         ~CurlEasyClient() {
>             while (!m_handles.empty())
>             {
>                 curl_easy_cleanup(m_handles.front());
384d296
<                 return res;
385a298,299
>             curl_global_cleanup();
>         }
387,391c301,344
<             void release_handle(CURL *h) {
<                 std::lock_guard<std::mutex> lg(m_handles_mutex);
<                 m_handles.push(h);
<                 m_cv.notify_one();
<             }
---
>         int size()
>         {
>             return m_size;
>         }
> 
>         std::shared_ptr<CurlEasyRequest> get_handle()
>         {
>             std::unique_lock<std::mutex> lk(m_handles_mutex);
>             m_cv.wait(lk, [this]() { return !m_handles.empty(); });
>             auto res = std::make_shared<CurlEasyRequest>(shared_from_this(), m_handles.front());
>             m_handles.pop();
>             return res;
>         }
> 
>         const std::string& get_capath()
>         {
>             return m_capath;
>         }
> 
>         void release_handle(CURL *h)
>         {
>             std::lock_guard<std::mutex> lg(m_handles_mutex);
>             m_handles.push(h);
>             m_cv.notify_one();
>         }
> 
>         void set_proxy(std::string proxy)
>         {
>             m_proxy = std::move(proxy);
>         }
> 
>         const std::string& get_proxy() const
>         {
>             return m_proxy;
>         }
> 
>     private:
>         int m_size;
>         std::string m_capath;
>         std::string m_proxy;
>         std::queue<CURL *> m_handles;
>         std::mutex m_handles_mutex;
>         std::condition_variable m_cv;
>     };
393,400c346
<         private:
<             int m_size;
<             std::queue<CURL *> m_handles;
<             std::mutex m_handles_mutex;
<             std::condition_variable m_cv;
<         };
<     }
< }
---
> }}   // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/http_base.h cpplite/include/http_base.h
11,12d10
< namespace microsoft_azure {
<     namespace storage {
14,29c12
<         class http_base {
<         public:
<             enum class http_method {
<                 del,
<                 get,
<                 head,
<                 post,
<                 put
<             };
<             std::map<http_method, std::string> http_method_label = {
<                     {http_method::del,"DELETE"},
<                     {http_method::get,"GET"},
<                     {http_method::head,"HEAD"},
<                     {http_method::post,"POST"},
<                     {http_method::put,"PUT"},
<             };
---
> namespace azure {  namespace storage_lite {
31c14,25
<             virtual ~http_base() {}
---
>     class http_base
>     {
>     public:
>         enum class http_method
>         {
>             del,
>             get,
>             head,
>             post,
>             put,
>             patch
>         };
33c27
<             using http_code = int;
---
>         virtual ~http_base() {}
35c29
<             virtual void set_method(http_method method) = 0;
---
>         using http_code = int;
37c31
<             virtual http_method get_method() const = 0;
---
>         virtual void set_method(http_method method) = 0;
39c33
<             virtual void set_url(const std::string &url) = 0;
---
>         virtual http_method get_method() const = 0;
41c35
<             virtual std::string get_url() const = 0;
---
>         virtual void set_url(const std::string &url) = 0;
43c37
<             virtual void add_header(const std::string &name, const std::string &value) = 0;
---
>         virtual std::string get_url() const = 0;
45,46c39
<             virtual std::string get_header(const std::string &name) const = 0;
<             virtual const std::map<std::string, std::string, case_insensitive_compare>& get_headers() const = 0;
---
>         virtual void add_header(const std::string &name, const std::string &value) = 0;
48c41
<             virtual CURLcode perform() = 0;
---
>         virtual const std::map<std::string, std::string, case_insensitive_compare>& get_request_headers() const = 0;
50c43,44
<             virtual void submit(std::function<void(http_code, storage_istream, CURLcode)> cb, std::chrono::seconds interval) = 0;
---
>         virtual std::string get_response_header(const std::string &name) const = 0;
>         virtual const std::map<std::string, std::string, case_insensitive_compare>& get_response_headers() const = 0;
52c46
<             virtual void reset() = 0;
---
>         virtual CURLcode perform() = 0;
54c48
<             virtual http_code status_code() const = 0;
---
>         virtual void submit(std::function<void(http_code, storage_istream, CURLcode)> cb, std::chrono::seconds interval) = 0;
56c50
<             virtual void set_input_stream(storage_istream s) = 0;
---
>         virtual void reset() = 0;
58c52
<             virtual void set_input_buffer(char* buff) = 0;
---
>         virtual http_code status_code() const = 0;
60c54
<             virtual void reset_input_stream() = 0;
---
>         virtual void set_input_stream(storage_istream s) = 0;
62c56
<             virtual void reset_output_stream() = 0;
---
>         virtual void reset_input_stream() = 0;
64c58
<             virtual void set_output_stream(storage_ostream s) = 0;
---
>         virtual void reset_output_stream() = 0;
66c60
<             virtual void set_error_stream(std::function<bool(http_code)> f, storage_iostream s) = 0;
---
>         virtual void set_output_stream(storage_ostream s) = 0;
68c62
<             virtual storage_istream get_input_stream() const = 0;
---
>         virtual void set_error_stream(std::function<bool(http_code)> f, storage_iostream s) = 0;
70c64
<             virtual storage_ostream get_output_stream() const = 0;
---
>         virtual storage_istream get_input_stream() const = 0;
72c66
<             virtual storage_iostream get_error_stream() const = 0;
---
>         virtual storage_ostream get_output_stream() const = 0;
74c68
<             virtual void set_absolute_timeout(long long timeout) = 0;
---
>         virtual storage_iostream get_error_stream() const = 0;
76,77c70,73
<             virtual void set_data_rate_timeout() = 0;
<         };
---
>         virtual void set_absolute_timeout(long long timeout) = 0;
> 
>         virtual void set_data_rate_timeout() = 0;
>     };
79,80c75
<     }
< }
---
> }}  // azure::storage_lite
Only in cpplite/include: json_parser_base.h
diff -r azure-storage-cpp-lite-org/include/list_blobs_request_base.h cpplite/include/list_blobs_request_base.h
14,15c14
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
17,100c16,33
< class list_blobs_request_base : public blob_request_base {
< public:
<     enum include {
<         unspecifies = 0x0,
<         snapshots = 0x1,
<         metadata = 0x2,
<         uncommittedblobs = 0x4,
<         copy = 0x8
<     };
< 
<     virtual std::string container() const = 0;
<     virtual std::string prefix() const { return std::string(); }
<     virtual std::string delimiter() const { return std::string(); }
<     virtual std::string marker() const { return std::string(); }
<     virtual int maxresults() const { return 0; }
<     virtual include includes() const { return include::unspecifies; }
< 
<     AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
< };
< 
< class list_blobs_item {
< public:
<     std::string name;
<     std::string snapshot;
<     std::string last_modified;
<     std::string etag;
<     unsigned long long content_length;
<     std::string content_encoding;
<     std::string content_type;
<     std::string content_md5;
<     std::string content_language;
<     std::string cache_control;
<     lease_status status;
<     lease_state state;
<     lease_duration duration;
< };
< 
< class list_blobs_response {
< public:
<     std::string ms_request_id;
<     std::vector<list_blobs_item> blobs;
<     std::string next_marker;
< };
< 
< 
< class list_blobs_hierarchical_request_base : public blob_request_base {
< public:
< 
<     virtual std::string container() const = 0;
<     virtual std::string prefix() const { return std::string(); }
<     virtual std::string delimiter() const { return std::string(); }
<     virtual std::string marker() const { return std::string(); }
<     virtual int maxresults() const { return 0; }
<     virtual list_blobs_request_base::include includes() const { return list_blobs_request_base::include::unspecifies; }
< 
<     AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
< };
< 
< class list_blobs_hierarchical_item {
< public:
<     std::string name;
<     std::string snapshot;
<     std::string last_modified;
<     std::string etag;
<     unsigned long long content_length;
<     std::string content_encoding;
<     std::string content_type;
<     std::string content_md5;
<     std::string content_language;
<     std::string cache_control;
<     lease_status status;
<     lease_state state;
<     lease_duration duration;
<     std::string copy_status;
<     std::vector<std::pair<std::string, std::string>> metadata;
<     bool is_directory;
< };
< 
< class list_blobs_hierarchical_response {
< public:
<     std::string ms_request_id;
<     std::vector<list_blobs_hierarchical_item> blobs;
<     std::string next_marker;
< };
---
>     class list_blobs_request_base : public blob_request_base
>     {
>     public:
>         enum include
>         {
>             unspecifies = 0x0,
>             snapshots = 0x1,
>             metadata = 0x2,
>             uncommittedblobs = 0x4,
>             copy = 0x8
>         };
> 
>         virtual std::string container() const = 0;
>         virtual std::string prefix() const { return std::string(); }
>         virtual std::string delimiter() const { return std::string(); }
>         virtual std::string marker() const { return std::string(); }
>         virtual int maxresults() const { return 0; }
>         virtual include includes() const { return include::unspecifies; }
102,103c35,107
< }
< }
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
> 
>     class list_blobs_item
>     {
>     public:
>         std::string name;
>         std::string snapshot;
>         std::string last_modified;
>         std::string etag;
>         unsigned long long content_length;
>         std::string content_encoding;
>         std::string content_type;
>         std::string content_md5;
>         std::string content_language;
>         std::string cache_control;
>         lease_status status;
>         lease_state state;
>         lease_duration duration;
>     };
> 
>     class list_blobs_response
>     {
>     public:
>         std::string ms_request_id;
>         std::vector<list_blobs_item> blobs;
>         std::string next_marker;
>     };
> 
> 
>     class list_blobs_segmented_request_base : public blob_request_base
>     {
>     public:
> 
>         virtual std::string container() const = 0;
>         virtual std::string prefix() const { return std::string(); }
>         virtual std::string delimiter() const { return std::string(); }
>         virtual std::string marker() const { return std::string(); }
>         virtual int maxresults() const { return 0; }
>         virtual list_blobs_request_base::include includes() const { return list_blobs_request_base::include::unspecifies; }
> 
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
> 
>     class list_blobs_segmented_item
>     {
>     public:
>         std::string name;
>         std::string snapshot;
>         std::string last_modified;
>         std::string etag;
>         unsigned long long content_length;
>         std::string content_encoding;
>         std::string content_type;
>         std::string content_md5;
>         std::string content_language;
>         std::string cache_control;
>         lease_status status;
>         lease_state state;
>         lease_duration duration;
>         std::vector<std::pair<std::string, std::string>> metadata;
>         bool is_directory;
>     };
> 
>     class list_blobs_segmented_response
>     {
>     public:
>         std::string ms_request_id;
>         std::vector<list_blobs_segmented_item> blobs;
>         std::string next_marker;
>     };
> 
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/list_containers_request_base.h cpplite/include/list_containers_request_base.h
3d2
< #include <map>
14,15c13
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
17,42c15,43
<         class list_containers_request_base : public blob_request_base {
<         public:
<             virtual std::string prefix() const { return std::string(); }
<             virtual std::string marker() const { return std::string(); }
<             virtual int maxresults() const { return 0; }
<             virtual bool include_metadata() const { return false; }
< 
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
< 
<         class list_containers_item {
<         public:
<             std::string name;
<             std::string last_modified;
<             std::string etag;
<             lease_status status;
<             lease_state state;
<             lease_duration duration;
<         };
< 
<         class list_containers_response {
<         public:
<             std::string ms_request_id;
<             std::vector<list_containers_item> containers;
<             std::string next_marker;
<         };
---
>     class list_containers_request_base : public blob_request_base
>     {
>     public:
>         virtual std::string prefix() const { return std::string(); }
>         virtual std::string marker() const { return std::string(); }
>         virtual int maxresults() const { return 0; }
>         virtual bool include_metadata() const { return false; }
> 
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
> 
>     class list_containers_item
>     {
>     public:
>         std::string name;
>         std::string last_modified;
>         std::string etag;
>         lease_status status;
>         lease_state state;
>         lease_duration duration;
>     };
> 
>     class list_constainers_segmented_response
>     {
>     public:
>         std::string ms_request_id;
>         std::vector<list_containers_item> containers;
>         std::string next_marker;
>     };
44,45c45
<     }
< }
---
> }}  // azure::storage_lite
Only in cpplite/include: logging.h
Only in cpplite/include: mstream.h
diff -r azure-storage-cpp-lite-org/include/put_blob_request_base.h cpplite/include/put_blob_request_base.h
12,13c12
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
15,46c14,45
< class put_blob_request_base : public blob_request_base {
< public:
<     enum class blob_type {
<         block_blob,
<         page_blob,
<         append_blob
<     };
< 
<     virtual std::string container() const = 0;
<     virtual std::string blob() const = 0;
<     virtual std::vector<std::pair<std::string, std::string>> metadata() const = 0;
< 
<     virtual std::string content_encoding() const { return std::string(); }
<     virtual std::string content_language() const { return std::string(); }
<     virtual unsigned int content_length() const = 0;
<     virtual std::string content_md5() const { return std::string(); }
<     virtual std::string content_type() const { return std::string(); }
< 
<     virtual std::string origin() const { return std::string(); }
<     virtual std::string cache_control() const { return std::string(); }
< 
<     virtual std::string ms_blob_cache_control() const { return std::string(); }
<     virtual std::string ms_blob_content_disposition() const { return std::string(); }
<     virtual std::string ms_blob_content_encoding() const { return std::string(); }
<     virtual std::string ms_blob_content_language() const { return std::string(); }
<     virtual unsigned long long ms_blob_content_length() const { return 0; }
<     virtual std::string ms_blob_content_md5() const { return std::string(); }
<     virtual std::string ms_blob_content_type() const { return std::string(); }
<     virtual unsigned long long ms_blob_sequence_number() const { return 0; }
<     virtual blob_type ms_blob_type() const = 0;
< 
<     //virtual std::map<std::string, std::string> ms_meta() const {};
---
>     class put_blob_request_base : public blob_request_base
>     {
>     public:
>         enum class blob_type
>         {
>             block_blob,
>             page_blob,
>             append_blob
>         };
> 
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
>         virtual std::vector<std::pair<std::string, std::string>> metadata() const = 0;
> 
>         virtual std::string content_encoding() const { return std::string(); }
>         virtual std::string content_language() const { return std::string(); }
>         virtual unsigned int content_length() const = 0;
>         virtual std::string content_md5() const { return std::string(); }
>         virtual std::string content_type() const { return std::string(); }
> 
>         virtual std::string origin() const { return std::string(); }
>         virtual std::string cache_control() const { return std::string(); }
> 
>         virtual std::string ms_blob_cache_control() const { return std::string(); }
>         virtual std::string ms_blob_content_disposition() const { return std::string(); }
>         virtual std::string ms_blob_content_encoding() const { return std::string(); }
>         virtual std::string ms_blob_content_language() const { return std::string(); }
>         virtual unsigned long long ms_blob_content_length() const { return 0; }
>         virtual std::string ms_blob_content_md5() const { return std::string(); }
>         virtual std::string ms_blob_content_type() const { return std::string(); }
>         virtual unsigned long long ms_blob_sequence_number() const { return 0; }
>         virtual blob_type ms_blob_type() const = 0;
48,51c47,48
<     AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
< };
< 
< //AZURE_STORAGE_API void build_request(const storage_account &a, const put_blob_request_base &r, http_base &h);
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
53,54c50
< }
< }
---
> }}
diff -r azure-storage-cpp-lite-org/include/put_block_list_request_base.h cpplite/include/put_block_list_request_base.h
12,13c12
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
15,23c14,15
< class put_block_list_request_base : public blob_request_base {
< public:
<     enum class block_type {
<         committed,
<         uncommitted,
<         latest
<     };
< 
<     class block_item {
---
>     class put_block_list_request_base : public blob_request_base
>     {
25,33c17,41
<         std::string id;
<         block_type type;
<     };
< 
<     virtual std::string container() const = 0;
<     virtual std::string blob() const = 0;
< 
<     virtual std::vector<block_item> block_list() const = 0;
<     virtual std::vector<std::pair<std::string, std::string>> metadata() const = 0;
---
>         enum class block_type {
>             committed,
>             uncommitted,
>             latest
>         };
> 
>         struct block_item {
>             std::string id;
>             block_type type;
>         };
> 
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
> 
>         virtual std::vector<block_item> block_list() const = 0;
>         virtual std::vector<std::pair<std::string, std::string>> metadata() const = 0;
> 
>         virtual std::string content_md5() const { return std::string(); }
> 
>         virtual std::string ms_blob_cache_control() const { return std::string(); }
>         virtual std::string ms_blob_content_disposition() const { return std::string(); }
>         virtual std::string ms_blob_content_encoding() const { return std::string(); }
>         virtual std::string ms_blob_content_language() const { return std::string(); }
>         virtual std::string ms_blob_content_md5() const { return std::string(); }
>         virtual std::string ms_blob_content_type() const { return std::string(); }
35,50c43,44
<     //virtual unsigned int content_length() const = 0;
<     virtual std::string content_md5() const { return std::string(); }
< 
<     virtual std::string ms_blob_cache_control() const { return std::string(); }
<     virtual std::string ms_blob_content_disposition() const { return std::string(); }
<     virtual std::string ms_blob_content_encoding() const { return std::string(); }
<     virtual std::string ms_blob_content_language() const { return std::string(); }
<     virtual std::string ms_blob_content_md5() const { return std::string(); }
<     virtual std::string ms_blob_content_type() const { return std::string(); }
< 
<     //virtual std::map<std::string, std::string> ms_meta() const {};
< 
<     AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
< };
< 
< //AZURE_STORAGE_API void build_request(const storage_account &a, const put_blob_request_base &r, http_base &h);
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
52,53c46
< }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/put_block_request_base.h cpplite/include/put_block_request_base.h
12,13c12
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
15,19c14,19
<         class put_block_request_base : public blob_request_base {
<         public:
<             virtual std::string container() const = 0;
<             virtual std::string blob() const = 0;
<             virtual std::string blockid() const = 0;
---
>     class put_block_request_base : public blob_request_base
>     {
>     public:
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
>         virtual std::string blockid() const = 0;
21,22c21,22
<             virtual unsigned int content_length() const = 0;
<             virtual std::string content_md5() const { return std::string(); }
---
>         virtual unsigned int content_length() const = 0;
>         virtual std::string content_md5() const { return std::string(); }
24,25c24,25
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
---
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
27,28c27
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/put_page_request_base.h cpplite/include/put_page_request_base.h
12,13c12
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
15,30c14,21
<         class put_page_request_base : public blob_request_base {
<         public:
<             enum class page_write {
<                 update,
<                 clear
<             };
< 
<             virtual std::string container() const = 0;
<             virtual std::string blob() const = 0;
< 
<             virtual unsigned long long start_byte() const { return 0; }
<             virtual unsigned long long end_byte() const { return 0; }
<             virtual page_write ms_page_write() const = 0;
<             virtual std::string ms_if_sequence_number_le() const { return std::string(); }
<             virtual std::string ms_if_sequence_number_lt() const { return std::string(); }
<             virtual std::string ms_if_sequence_number_eq() const { return std::string(); }
---
>     class put_page_request_base : public blob_request_base
>     {
>     public:
>         enum class page_write
>         {
>             update,
>             clear
>         };
32,33c23,24
<             virtual unsigned int content_length() const = 0;
<             virtual std::string content_md5() const { return std::string(); }
---
>         virtual std::string container() const = 0;
>         virtual std::string blob() const = 0;
35,36c26,37
<             AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
<         };
---
>         virtual unsigned long long start_byte() const { return 0; }
>         virtual unsigned long long end_byte() const { return 0; }
>         virtual page_write ms_page_write() const = 0;
>         virtual std::string ms_if_sequence_number_le() const { return std::string(); }
>         virtual std::string ms_if_sequence_number_lt() const { return std::string(); }
>         virtual std::string ms_if_sequence_number_eq() const { return std::string(); }
> 
>         virtual unsigned int content_length() const = 0;
>         virtual std::string content_md5() const { return std::string(); }
> 
>         AZURE_STORAGE_API void build_request(const storage_account &a, http_base &h) const override;
>     };
38,39c39
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/retry.h cpplite/include/retry.h
12,13c12
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
15,19c14,105
<         class retry_info final{
<         public:
<             retry_info(bool should_retry, std::chrono::seconds interval)
<                 : m_should_retry(should_retry),
<                 m_interval(interval) {}
---
>     class retry_info final
>     {
>     public:
>         retry_info(bool should_retry, std::chrono::seconds interval)
>             : m_should_retry(should_retry),
>             m_interval(interval) {}
> 
>         bool should_retry() const
>         {
>             return m_should_retry;
>         }
> 
>         std::chrono::seconds interval() const
>         {
>             return m_interval;
>         }
> 
>     private:
>         bool m_should_retry;
>         std::chrono::seconds m_interval;
>     };
> 
>     class retry_context final
>     {
>     public:
>         retry_context()
>             : m_numbers(0),
>             m_result(0) {}
> 
>         retry_context(int numbers, http_base::http_code result)
>             : m_numbers(numbers),
>             m_result(result) {}
> 
>         int numbers() const
>         {
>             return m_numbers;
>         }
> 
>         http_base::http_code result() const
>         {
>             return m_result;
>         }
> 
>         void add_result(http_base::http_code result)
>         {
>             m_result = result;
>             m_numbers++;
>         }
> 
>     private:
>         int m_numbers;
>         http_base::http_code m_result;
>     };
> 
>     class retry_policy_base
>     {
>     public:
>         virtual ~retry_policy_base() {}
>         virtual retry_info evaluate(const retry_context &context) const = 0;
>     };
> 
>     // Default retry policy
>     class retry_policy final : public retry_policy_base
>     {
>     public:
>         retry_info evaluate(const retry_context& context) const override
>         {
>             const int max_retry_count = 3;
>             if (context.numbers() <= max_retry_count && can_retry(context.result()))
>             {
>                 return retry_info(true, std::chrono::seconds(0));
>             }
>             return retry_info(false, std::chrono::seconds(0));
>         }
> 
>     private:
>         bool can_retry(http_base::http_code code) const
>         {
>             return retryable(code);
>         }
>     };
> 
>     // No-retry policy
>     class no_retry_policy final : public retry_policy_base
>     {
>     public:
>         retry_info evaluate(const retry_context& context) const override
>         {
>             unused(context);
>             return retry_info(false, std::chrono::seconds(0));
>         }
>     };
21,89c107
<             bool should_retry() const {
<                 return m_should_retry;
<             }
< 
<             std::chrono::seconds interval() const {
<                 return m_interval;
<             }
< 
<         private:
<             bool m_should_retry;
<             std::chrono::seconds m_interval;
<         };
< 
<         class retry_context final {
<         public:
<             retry_context()
<                 : m_numbers(0),
<                 m_result(0) {}
< 
<             retry_context(int numbers, http_base::http_code result)
<                 : m_numbers(numbers),
<                 m_result(result) {}
< 
<             int numbers() const {
<                 return m_numbers;
<             }
< 
<             http_base::http_code result() const {
<                 return m_result;
<             }
< 
<             void add_result(http_base::http_code result) {
<                 m_result = result;
<                 m_numbers++;
<             }
< 
<         private:
<             int m_numbers;
<             http_base::http_code m_result;
<         };
< 
<         class retry_policy_base {
<         public:
<             virtual ~retry_policy_base() {}
<             virtual retry_info evaluate(const retry_context &context) const = 0;
<         };
< 
<         class retry_policy final : public retry_policy_base {
<         public:
<             retry_info evaluate(const retry_context &context) const override {
<                 if (context.numbers() == 0) {
<                     return retry_info(true, std::chrono::seconds(0));
<                 } else if (context.numbers() < 26 && can_retry(context.result())) {
<                     double delay = (pow(1.2, context.numbers()-1)-1);
<                     delay = std::min(delay, 60.0); // Maximum backoff delay of 1 minute
<                     delay *= (((double)rand())/RAND_MAX)/2 + 0.75;
<                     return retry_info(true, std::chrono::seconds((int)delay));
<                 }
<                 return retry_info(false, std::chrono::seconds(0));
<             }
< 
<         private:
<             bool can_retry(http_base::http_code code) const {
<                 return retryable(code);
<             }
<         };
< 
<     }
< }
---
> }}  // azure::storage_lite
Only in cpplite/include: set_blob_metadata_request_base.h
Only in cpplite/include: set_container_metadata_request_base.h
diff -r azure-storage-cpp-lite-org/include/storage_account.h cpplite/include/storage_account.h
11,12c11
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
14,21c13,23
<         class storage_account final {
<         public:
<             enum class service {
<                 blob,
<                 table,
<                 queue,
<                 file
<             };
---
>     class storage_account final
>     {
>     public:
>         enum class service
>         {
>             blob,
>             table,
>             queue,
>             file,
>             adls
>         };
23c25
<             static std::shared_ptr<storage_account> development_storage_account();
---
>         static std::shared_ptr<storage_account> development_storage_account();
25c27
<             AZURE_STORAGE_API storage_account(const std::string &account_name, std::shared_ptr<storage_credential> credential, bool use_https = true, const std::string &blob_endpoint = std::string());
---
>         AZURE_STORAGE_API storage_account(const std::string &account_name, std::shared_ptr<storage_credential> credential, bool use_https = true, const std::string &blob_endpoint = std::string());
27,28c29,49
<             std::shared_ptr<storage_credential> credential() const {
<                 return m_credential;
---
>         std::shared_ptr<storage_credential> credential() const
>         {
>             return m_credential;
>         }
> 
>         storage_url get_url(service service) const
>         {
>             switch (service)
>             {
>             case storage_account::service::blob:
>                 return m_blob_url;
>             case storage_account::service::table:
>                 return m_table_url;
>             case storage_account::service::queue:
>                 return m_queue_url;
>             case storage_account::service::file:
>                 return m_file_url;
>             case storage_account::service::adls:
>                 return m_adls_url;
>             default:
>                 return storage_url();
29a51
>         }
31,41c53,60
<             AZURE_STORAGE_API storage_url get_url(service service) const;
< 
<         private:
<             std::shared_ptr<storage_credential> m_credential;
<             std::string m_blob_domain;
<             std::string m_table_domain;
<             std::string m_queue_domain;
<             std::string m_file_domain;
< 
<             AZURE_STORAGE_API void append_all(const std::string &part);
<         };
---
>     private:
>         std::shared_ptr<storage_credential> m_credential;
>         storage_url m_blob_url;
>         storage_url m_table_url;
>         storage_url m_queue_url;
>         storage_url m_file_url;
>         storage_url m_adls_url;
>     };
43,44c62
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/storage_credential.h cpplite/include/storage_credential.h
12d11
< #include "OAuthTokenCredentialManager.h"
14,15c13
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
17,32c15,29
<         class storage_credential {
<         public:
<             virtual ~storage_credential() {};
<             virtual void sign_request(const storage_request_base &, http_base &, const storage_url &, const storage_headers &) const {}
<             virtual std::string transform_url(std::string url) const {
<                 return url;
<             }
<         };
< 
<         class shared_key_credential final : public storage_credential {
<         public:
<             AZURE_STORAGE_API shared_key_credential(const std::string &account_name, const std::string &account_key);
< 
<             AZURE_STORAGE_API shared_key_credential(const std::string &account_name, const std::vector<unsigned char> &account_key);
< 
<             AZURE_STORAGE_API void sign_request(const storage_request_base &r, http_base &h, const storage_url &url, const storage_headers &headers) const override;
---
>     class storage_credential
>     {
>     public:
>         virtual ~storage_credential() {};
>         virtual void sign_request(const storage_request_base &, http_base &, const storage_url &, const storage_headers &) const {}
>         virtual std::string transform_url(std::string url) const
>         {
>             return url;
>         }
>     };
> 
>     class shared_key_credential final : public storage_credential
>     {
>     public:
>         AZURE_STORAGE_API shared_key_credential(const std::string &account_name, const std::string &account_key);
34c31
<             AZURE_STORAGE_API void sign_request(const table_request_base &r, http_base &h, const storage_url &url, const storage_headers &headers) const;
---
>         AZURE_STORAGE_API shared_key_credential(const std::string &account_name, const std::vector<unsigned char> &account_key);
36,38c33
<             const std::string &account_name() const {
<                 return m_account_name;
<             }
---
>         AZURE_STORAGE_API void sign_request(const storage_request_base &r, http_base &h, const storage_url &url, const storage_headers &headers) const override;
40,42c35
<             const std::vector<unsigned char> &account_key() const {
<                 return m_account_key;
<             }
---
>         AZURE_STORAGE_API void sign_request(const table_request_base &r, http_base &h, const storage_url &url, const storage_headers &headers) const;
44,52c37,57
<         private:
<             std::string m_account_name;
<             std::vector<unsigned char> m_account_key;
<         };
< 
<         class shared_access_signature_credential final : public storage_credential {
<         public:
<             shared_access_signature_credential(const std::string &sas_token)
<                 : m_sas_token(sas_token) {
---
>         const std::string &account_name() const
>         {
>             return m_account_name;
>         }
> 
>         const std::vector<unsigned char> &account_key() const
>         {
>             return m_account_key;
>         }
> 
>     private:
>         std::string m_account_name;
>         std::vector<unsigned char> m_account_key;
>     };
> 
>     class shared_access_signature_credential final : public storage_credential
>     {
>     public:
>         shared_access_signature_credential(const std::string &sas_token)
>             : m_sas_token(sas_token)
>         {
54c59,60
<             if (!m_sas_token.empty() && m_sas_token[0] == '?') {
---
>             if (!m_sas_token.empty() && m_sas_token[0] == '?')
>             {
57c63
< 	    }
---
>         }
62,100c68,90
<         private:
<             std::string m_sas_token;
<         };
< 
<         class anonymous_credential final : public storage_credential {
<         public:
<             void sign_request(const storage_request_base &, http_base &, const storage_url &, const storage_headers &) const override {}
<         };
< 
<         class token_credential : public storage_credential {
<         public:
<             // NOTE: This is a blobfuse linked function.
<             // It links up with the blobfuse-initialized OAuthTokenManager.
<             // If it was not already initialized, this will throw.
<             AZURE_STORAGE_API token_credential();
< 
<             // DEPRECATION NOTICE: This is mostly meant for compatibility with sample.cpp
<             // The new token credential uses the OAuthTokenCredentialManager, and explicitly set tokens disable this functionality!
<             AZURE_STORAGE_API token_credential(const std::string &token);
< 
<             void sign_request(
<                     const storage_request_base &,
<                     http_base &,
<                     const storage_url &,
<                     const storage_headers &
<                     ) const override;
< 
<             // DEPRECATION NOTICE: This is mostly meant for compatibility with sample.cpp
<             // The new token credential uses the OAuthTokenCredentialManager, and explicitly set tokens disable this functionality!
<             void set_token(const std::string &token);
< 
<         private:
<             std::shared_ptr<OAuthTokenCredentialManager> m_credmgr_ptr;
<             std::string m_token;
<             mutable std::mutex m_token_mutex;
<         };
< 
<     }
< }
---
>     private:
>         std::string m_sas_token;
>     };
> 
>     class anonymous_credential final : public storage_credential
>     {
>     public:
>         void sign_request(const storage_request_base &, http_base &, const storage_url &, const storage_headers &) const override {}
>     };
> 
>     class token_credential : public storage_credential {
>     public:
>         AZURE_STORAGE_API token_credential(const std::string &token);
> 
>         void sign_request(const storage_request_base &, http_base &, const storage_url &, const storage_headers &) const override;
> 
>         void set_token(const std::string& token);
> 
>     private:
>         std::string m_token;
>         mutable std::mutex m_token_mutex;
>     };
> }}
diff -r azure-storage-cpp-lite-org/include/storage_errno.h cpplite/include/storage_errno.h
15c15
< const int blob__already_exists = 1500;
---
> const int blob_already_exists = 1500;
21a22
> const int blob_too_big = 1507;
diff -r azure-storage-cpp-lite-org/include/storage_EXPORTS.h cpplite/include/storage_EXPORTS.h
3,6c3,10
< #if defined (_MSC_VER)
< #define AZURE_STORAGE_API __declspec(dllexport)
< #else /* defined (_MSC_VER) */
< #define AZURE_STORAGE_API
---
> #if defined(_WIN32) && defined(_WINDLL)
>     #if defined(azure_storage_lite_EXPORTS)
>         #define AZURE_STORAGE_API __declspec(dllexport)
>     #else
>         #define AZURE_STORAGE_API __declspec(dllimport)
>     #endif
> #else /* defined(_WIN32) && defined(_WINDLL) */
>     #define AZURE_STORAGE_API
diff -r azure-storage-cpp-lite-org/include/storage_outcome.h cpplite/include/storage_outcome.h
3a4
> #include <exception>
7,8c8
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
10,70c10,91
<         class storage_error {
<         public:
<             std::string code;
<             std::string code_name;
<             std::string message;
<         };
< 
<         template<typename RESPONSE_TYPE>
<         class storage_outcome {
<         public:
<             storage_outcome()
<                 : m_success(false) {}
< 
<             storage_outcome(RESPONSE_TYPE response)
<                 : m_success(true),
<                 m_response(std::move(response)) {}
< 
<             storage_outcome(storage_error error)
<                 : m_success(false),
<                 m_error(std::move(error)) {}
< 
<             bool success() const {
<                 return m_success;
<             }
< 
<             const storage_error &error() const {
<                 return m_error;
<             }
< 
<             const RESPONSE_TYPE &response() const {
<                 return m_response;
<             }
< 
<         private:
<             bool m_success;
<             storage_error m_error;
<             RESPONSE_TYPE m_response;
<         };
< 
<         template<>
<         class storage_outcome<void> {
<         public:
<             storage_outcome()
<                 : m_success(true) {}
< 
<             storage_outcome(storage_error error)
<                 : m_success(false),
<                 m_error(std::move(error)) {}
< 
<             bool success() const {
<                 return m_success;
<             }
< 
<             const storage_error &error() const {
<                 return m_error;
<             }
< 
<         private:
<             bool m_success;
<             storage_error m_error;
<         };
---
>     class storage_error
>     {
>     public:
>         std::string code;
>         std::string code_name;
>         std::string message;
>     };
> 
>     struct storage_exception : public std::exception
>     {
>         storage_exception(int code, std::string code_name, std::string message) : code(code), code_name(std::move(code_name)), message(std::move(message)) {}
> 
>         int code;
>         std::string code_name;
>         std::string message;
>     };
> 
>     template<typename RESPONSE_TYPE>
>     class storage_outcome
>     {
>     public:
>         storage_outcome()
>             : m_success(false) {}
> 
>         storage_outcome(RESPONSE_TYPE response)
>             : m_success(true),
>             m_response(std::move(response)) {}
> 
>         storage_outcome(storage_error error)
>             : m_success(false),
>             m_error(std::move(error)) {}
> 
>         bool success() const
>         {
>             return m_success;
>         }
> 
>         const storage_error &error() const
>         {
>             return m_error;
>         }
> 
>         const RESPONSE_TYPE &response() const
>         {
>             return m_response;
>         }
> 
>     private:
>         bool m_success;
>         storage_error m_error;
>         RESPONSE_TYPE m_response;
>     };
> 
>     template<>
>     class storage_outcome<void>
>     {
>     public:
>         storage_outcome()
>             : m_success(true) {}
> 
>         storage_outcome(storage_error error)
>             : m_success(false),
>             m_error(std::move(error)) {}
> 
>         bool success() const
>         {
>             return m_success;
>         }
> 
>         const storage_error &error() const
>         {
>             return m_error;
>         }
> 
>         void response() const
>         {
>         }
> 
>     private:
>         bool m_success;
>         storage_error m_error;
>     };
72,73c93
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/storage_request_base.h cpplite/include/storage_request_base.h
5,6c5
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
11c10,11
<         class storage_request_base {
---
>         class storage_request_base
>         {
13a14
>             // TODO: create request ID for each request for future debugging purposes.
19c20,21
<         class blob_request_base : public storage_request_base {
---
>         class blob_request_base : public storage_request_base
>         {
34,35c36,37
<     }
< }
---
> 
> }}
diff -r azure-storage-cpp-lite-org/include/storage_stream.h cpplite/include/storage_stream.h
9,10c9
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
12,15c11,14
<         class storage_istream_helper {
<         public:
<             storage_istream_helper(std::istream &stream)
<                 : m_stream(stream) {}
---
>     class storage_istream
>     {
>     public:
>         storage_istream() {}
17,19c16
<             std::istream &istream() {
<                 return m_stream;
<             }
---
>         storage_istream(std::istream& stream) : m_initial(stream.tellg()), m_stream(&stream, [](std::istream*) { /* null deleter */ }) {}
21,27c18
<         private:
<             std::istream &m_stream;
<         };
< 
<         class storage_istream {
<         public:
<             storage_istream() {}
---
>         storage_istream(std::shared_ptr<std::istream> stream) : m_initial(stream->tellg()), m_stream(std::move(stream)) {}
29,30c20,24
<             storage_istream(std::istream &stream) {
<                 m_helper = std::make_shared<storage_istream_helper>(stream);
---
>         void reset()
>         {
>             if (valid())
>             {
>                 m_stream->seekg(m_initial);
31a26
>         }
33,35c28,31
<             storage_istream(std::shared_ptr<std::istream> stream) {
<                 m_stream = stream;
<             }
---
>         std::istream& istream()
>         {
>             return *m_stream;
>         }
37,42c33,36
<             void reset() {
<                if (!valid()) {
<                   return;
<                }
<                istream().seekg(0);
<             }
---
>         bool valid() const
>         {
>             return m_stream != nullptr;
>         }
44,51c38,41
<             std::istream &istream() {
<                 if (m_helper) {
<                     return m_helper->istream();
<                 }
<                 else {
<                     return *m_stream;
<                 }
<             }
---
>     private:
>         std::istream::off_type m_initial;
>         std::shared_ptr<std::istream> m_stream;
>     };
53,55c43,46
<             bool valid() const {
<                 return m_helper != nullptr || m_stream != nullptr;
<             }
---
>     class storage_ostream
>     {
>     public:
>         storage_ostream() {}
57,65c48
<         private:
<             std::shared_ptr<storage_istream_helper> m_helper;
<             std::shared_ptr<std::istream> m_stream;
<         };
< 
<         class storage_ostream_helper {
<         public:
<             storage_ostream_helper(std::ostream &stream)
<                 : m_stream(stream) {}
---
>         storage_ostream(std::ostream& stream) : m_initial(stream.tellp()), m_stream(&stream, [](std::ostream*) { /* null deleter */ }) {}
67,69c50
<             std::ostream &ostream() {
<                 return m_stream;
<             }
---
>         storage_ostream(std::shared_ptr<std::ostream> stream) : m_initial(stream->tellp()), m_stream(std::move(stream)) {}
71,82c52,55
<         private:
<             std::ostream &m_stream;
<         };
< 
<         class storage_ostream {
<         public:
<             storage_ostream() {}
< 
<             storage_ostream(std::ostream &stream) {
<                 m_initial = stream.tellp();
<                 m_helper = std::make_shared<storage_ostream_helper>(stream);
<             }
---
>         std::ostream& ostream()
>         {
>             return *m_stream;
>         }
84,85c57,61
<             std::ostream &ostream() {
<                 return m_helper->ostream();
---
>         void reset()
>         {
>             if (valid())
>             {
>                 m_stream->seekp(m_initial);
86a63
>         }
88,93c65,68
<             void reset() {
<                 if (!valid()) {
<                     return;
<                 }
<                 ostream().seekp(m_initial);
<             }
---
>         bool valid() const
>         {
>             return m_stream != nullptr;
>         }
95,97c70,73
<             bool valid() const {
<                 return m_helper != nullptr;
<             }
---
>     private:
>         std::ostream::off_type m_initial;
>         std::shared_ptr<std::ostream> m_stream;
>     };
99,108c75,81
<         private:
<             std::ostream::off_type m_initial;
<             std::shared_ptr<storage_ostream_helper> m_helper;
<         };
< 
<         class storage_iostream : public storage_istream, public storage_ostream {
<         public:
<             static storage_iostream create_storage_stream() {
<                 return storage_iostream(std::make_shared<std::stringstream>());
<             }
---
>     class storage_iostream : public storage_istream, public storage_ostream
>     {
>     public:
>         static storage_iostream create_storage_stream()
>         {
>             return storage_iostream(std::make_shared<std::stringstream>());
>         }
110,112c83
<             static storage_iostream create_storage_stream(const std::string &str) {
<                 return storage_iostream(std::make_shared<std::stringstream>(str));
<             }
---
>         storage_iostream() {}
114c85
<             storage_iostream() {}
---
>         storage_iostream(std::iostream& stream) : storage_istream(stream), storage_ostream(stream) {}
116,124c87,88
<             storage_iostream(std::iostream &stream)
<                 : storage_istream(stream),
<                 storage_ostream(stream) {}
< 
<         private:
<             storage_iostream(std::shared_ptr<std::iostream> s)
<                 : storage_istream(*s),
<                 storage_ostream(*s),
<                 m_stream(s) {}
---
>     private:
>         storage_iostream(std::shared_ptr<std::iostream> s) : storage_istream(*s), storage_ostream(*s), m_stream(s) {}
126,127c90,91
<             std::shared_ptr<std::iostream> m_stream;
<         };
---
>         std::shared_ptr<std::iostream> m_stream;
>     };
129,130c93
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/storage_url.h cpplite/include/storage_url.h
6d5
< #include <memory>
10,11c9
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
13c11,70
<         std::string encode_url_path(const std::string& path);
---
>     class storage_url
>     {
>     public:
>         storage_url & set_domain(const std::string &domain)
>         {
>             m_domain = domain;
>             return *this;
>         }
> 
>         const std::string &get_domain() const
>         {
>             return m_domain;
>         }
> 
>         storage_url &append_path(const std::string &segment)
>         {
>             m_path.append("/").append(segment);
>             return *this;
>         }
> 
>         const std::string &get_path() const
>         {
>             return m_path;
>         }
> 
>         AZURE_STORAGE_API std::string get_encoded_path() const;
> 
>         storage_url &add_query(const std::string &name, const std::string &value)
>         {
>             m_query[name].insert(value);
>             return *this;
>         }
> 
>         const std::map<std::string, std::set<std::string>> &get_query() const
>         {
>             return m_query;
>         }
> 
>         AZURE_STORAGE_API std::string to_string() const;
> 
>     private:
>         std::string m_domain;
>         std::string m_path;
>         std::map<std::string, std::set<std::string>> m_query;
>     };
> 
>     class storage_headers
>     {
>     public:
>         std::string content_encoding;
>         std::string content_language;
>         std::string content_length;
>         std::string content_md5;
>         std::string content_type;
>         std::string if_modified_since;
>         std::string if_match;
>         std::string if_none_match;
>         std::string if_unmodified_since;
>         std::map<std::string, std::string> ms_headers;
>     };
15,75c72
<         class storage_url {
<         public:
<             storage_url &set_domain(const std::string &domain) {
<                 m_domain = domain;
<                 return *this;
<             }
< 
<             const std::string &get_domain() const {
<                 return m_domain;
<             }
< 
<             storage_url &append_path(const std::string &segment) {
<                 m_path.append("/").append(segment);
<                 return *this;
<             }
< 
<             const std::string &get_path() const {
<                 return m_path;
<             }
< 
<             std::string get_encoded_path() const {
<                 return encode_url_path(m_path);
<             }
< 
<             storage_url &add_query(const std::string &name, const std::string &value) {
<                 m_query[name].insert(value);
<                 return *this;
<             }
< 
<             const std::map<std::string, std::set<std::string>> &get_query() const {
<                 return m_query;
<             }
< 
<             AZURE_STORAGE_API std::string to_string() const;
< 
<         private:
<             std::string m_domain;
<             std::string m_path;
<             std::map<std::string, std::set<std::string>> m_query;
<         };
< 
<         class storage_headers {
<         public:
<             std::string content_encoding;
<             std::string content_language;
<             std::string content_length;
<             std::string content_md5;
<             std::string content_type;
<             std::string if_modified_since;
<             std::string if_match;
<             std::string if_none_match;
<             std::string if_unmodified_since;
<             std::map<std::string, std::string> ms_headers;
<         };
< 
<         // NOTE: This is a blobfuse injected function.
<         // It is used primarily for parsing custom endpoints for MSI and other AD auth types.
<         std::shared_ptr<storage_url> parse_url(const std::string& url);
< 
<     }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/tinyxml2.h cpplite/include/tinyxml2.h
102,103c102,103
< static const int TIXML2_MINOR_VERSION = 0;
< static const int TIXML2_PATCH_VERSION = 1;
---
> static const int TIXML2_MINOR_VERSION = 1;
> static const int TIXML2_PATCH_VERSION = 0;
106,107c106,107
< #define TINYXML2_MINOR_VERSION 0
< #define TINYXML2_PATCH_VERSION 1
---
> #define TINYXML2_MINOR_VERSION 1
> #define TINYXML2_PATCH_VERSION 0
306c306
<             int newAllocated = cap * 2;
---
>             const int newAllocated = cap * 2;
619a620
>     static void ToStr(uint64_t v, char* buffer, int bufferSize);
628c629
< 
---
>     static bool ToUnsigned64(const char* str, uint64_t* value);
1166a1168,1173
>     uint64_t Unsigned64Value() const {
>         uint64_t i = 0;
>         QueryUnsigned64Value(&i);
>         return i;
>     }
> 
1200a1208,1209
>     /// See QueryIntValue
>     XMLError QueryUnsigned64Value(uint64_t* value) const;
1216c1225,1227
< 	/// Set the attribute to value.
---
>     /// Set the attribute to value.
>     void SetAttribute(uint64_t value);
>     /// Set the attribute to value.
1303a1315,1316
>     /// See IntAttribute()
>     uint64_t Unsigned64Attribute(const char* name, uint64_t defaultValue = 0) const;
1349a1363,1371
>     /// See QueryIntAttribute()
>     XMLError QueryUnsigned64Attribute(const char* name, uint64_t* value) const {
>         const XMLAttribute* a = FindAttribute(name);
>         if(!a) {
>             return XML_NO_ATTRIBUTE;
>         }
>         return a->QueryUnsigned64Value(value);
>     }
> 
1416c1438,1442
< 	XMLError QueryAttribute( const char* name, bool* value ) const {
---
>     XMLError QueryAttribute(const char* name, uint64_t* value) const {
>         return QueryUnsigned64Attribute(name, value);
>     }
> 
>     XMLError QueryAttribute( const char* name, bool* value ) const {
1450c1476,1482
< 	/// Sets the named attribute to value.
---
>     /// Sets the named attribute to value.
>     void SetAttribute(const char* name, uint64_t value) {
>         XMLAttribute* a = FindOrCreateAttribute(name);
>         a->SetAttribute(value);
>     }
>     
>     /// Sets the named attribute to value.
1548a1581,1582
>     /// Convenience method for setting text inside an element. See SetText() for important limitations.
>     void SetText(uint64_t value);
1587a1622,1623
> 	XMLError QueryUnsigned64Text(uint64_t* uval) const;
> 	/// See QueryIntText()
1599a1636,1637
>     /// See QueryIntText()
>     uint64_t Unsigned64Text(uint64_t defaultValue = 0) const;
1687c1725
<     XMLError Parse( const char* xml, size_t nBytes=(size_t)(-1) );
---
>     XMLError Parse( const char* xml, size_t nBytes=static_cast<size_t>(-1) );
2197c2235,2236
< 	void PushAttribute(const char* name, int64_t value);
---
> 	void PushAttribute( const char* name, int64_t value );
> 	void PushAttribute( const char* name, uint64_t value );
2209,2210c2248,2251
< 	/// Add a text node from an unsigned.
< 	void PushText(int64_t value);
---
> 	/// Add a text node from a signed 64bit integer.
> 	void PushText( int64_t value );
> 	/// Add a text node from an unsigned 64bit integer.
> 	void PushText( uint64_t value );
2256c2297
<     void ClearBuffer() {
---
>     void ClearBuffer( bool resetToFirstElement = true ) {
2259c2300
< 		_firstElement = true;
---
> 		_firstElement = resetToFirstElement;
diff -r azure-storage-cpp-lite-org/include/tinyxml2_parser.h cpplite/include/tinyxml2_parser.h
10,11c10
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
13,15c12,15
< class tinyxml2_parser : public xml_parser_base {
< public:
<     AZURE_STORAGE_API storage_error parse_storage_error(const std::string &xml) const override;
---
>     class tinyxml2_parser final : public xml_parser_base
>     {
>     public:
>         AZURE_STORAGE_API storage_error parse_storage_error(const std::string &xml) const override;
17c17
<     //AZURE_STORAGE_API list_containers_response parse_list_containers_response(const std::string &xml, std::vector<list_containers_item> &items) const override;
---
>         AZURE_STORAGE_API list_constainers_segmented_response parse_list_constainers_segmented_response(const std::string &xml) const override;
19c19
<     AZURE_STORAGE_API list_containers_response parse_list_containers_response(const std::string &xml) const override;
---
>         AZURE_STORAGE_API list_blobs_response parse_list_blobs_response(const std::string &xml) const override;
21c21
<     AZURE_STORAGE_API list_blobs_response parse_list_blobs_response(const std::string &xml) const override;
---
>         AZURE_STORAGE_API list_blobs_segmented_response parse_list_blobs_segmented_response(const std::string &xml) const override;
23c23
<     AZURE_STORAGE_API list_blobs_hierarchical_response parse_list_blobs_hierarchical_response(const std::string &xml) const override;
---
>         AZURE_STORAGE_API get_block_list_response parse_get_block_list_response(const std::string &xml) const override;
25c25
<     AZURE_STORAGE_API get_block_list_response parse_get_block_list_response(const std::string &xml) const override;
---
>         AZURE_STORAGE_API get_page_ranges_response parse_get_page_ranges_response(const std::string &xml) const override;
27c27,28
<     AZURE_STORAGE_API get_page_ranges_response parse_get_page_ranges_response(const std::string &xml) const override;
---
>     private:
>         AZURE_STORAGE_API std::string parse_text(tinyxml2::XMLElement *ele, const std::string &name) const;
29,30c30
< private:
<     AZURE_STORAGE_API std::string parse_text(tinyxml2::XMLElement *ele, const std::string &name) const;
---
>         AZURE_STORAGE_API unsigned long long parse_long(tinyxml2::XMLElement *ele, const std::string &name) const;
32c32
<     AZURE_STORAGE_API unsigned long long parse_long(tinyxml2::XMLElement *ele, const std::string &name) const;
---
>         AZURE_STORAGE_API list_containers_item parse_list_containers_item(tinyxml2::XMLElement *ele) const;
34c34
<     AZURE_STORAGE_API list_containers_item parse_list_containers_item(tinyxml2::XMLElement *ele) const;
---
>         AZURE_STORAGE_API list_blobs_item parse_list_blobs_item(tinyxml2::XMLElement *ele) const;
36c36
<     AZURE_STORAGE_API list_blobs_item parse_list_blobs_item(tinyxml2::XMLElement *ele) const;
---
>         AZURE_STORAGE_API std::vector<std::pair<std::string, std::string>> parse_blob_metadata(tinyxml2::XMLElement *ele) const;
38c38
<     AZURE_STORAGE_API std::vector<std::pair<std::string, std::string>> parse_blob_metadata(tinyxml2::XMLElement *ele) const;
---
>         AZURE_STORAGE_API list_blobs_segmented_item parse_list_blobs_segmented_item(tinyxml2::XMLElement *ele, bool is_directory) const;
40c40
<     AZURE_STORAGE_API list_blobs_hierarchical_item parse_list_blobs_hierarchical_item(tinyxml2::XMLElement *ele, bool is_directory) const;
---
>         AZURE_STORAGE_API get_block_list_item parse_get_block_list_item(tinyxml2::XMLElement *ele) const;
42c42,43
<     AZURE_STORAGE_API get_block_list_item parse_get_block_list_item(tinyxml2::XMLElement *ele) const;
---
>         AZURE_STORAGE_API get_page_ranges_item parse_get_page_ranges_item(tinyxml2::XMLElement *ele) const;
>     };
44,48c45
<     AZURE_STORAGE_API get_page_ranges_item parse_get_page_ranges_item(tinyxml2::XMLElement *ele) const;
< };
< 
< }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/todo/get_blob_metadata_request.h cpplite/include/todo/get_blob_metadata_request.h
15,16c15,16
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {
>     namespace storage_lite {
50,60c50,61
<                     details::add_optional_header(h, constant::header_content_encoding, r.content_encoding());
<                     details::add_optional_header(h, constant::header_content_language, r.content_language());
<                     details::add_optional_header(h, constant::header_content_length, (r.content_length() != 0 ? std::to_string(r.content_length()) : std::string()));
<                     details::add_optional_header(h, constant::header_content_md5, r.content_md5());
<                     details::add_optional_header(h, constant::header_content_type, r.content_type());
<                     details::add_optional_header(h, constant::header_date, r.date());
<                     details::add_optional_header(h, constant::header_if_modified_since, r.if_modified_since());
<                     details::add_optional_header(h, constant::header_if_match, r.if_match());
<                     details::add_optional_header(h, constant::header_if_none_match, r.if_none_match());
<                     details::add_optional_header(h, constant::header_if_unmodified_since, r.if_unmodified_since());
<                     details::add_optional_header(h, constant::header_range, r.range());
---
>                     // TODO: move the lines below to set blob property request base when implementing it.
>                     // details::add_optional_header(h, constant::header_content_encoding, r.content_encoding());
>                     // details::add_optional_header(h, constant::header_content_language, r.content_language());
>                     // details::add_optional_header(h, constant::header_content_length, (r.content_length() != 0 ? std::to_string(r.content_length()) : std::string()));
>                     // details::add_optional_header(h, constant::header_content_md5, r.content_md5());
>                     // details::add_optional_header(h, constant::header_content_type, r.content_type());
>                     // details::add_optional_header(h, constant::header_date, r.date());
>                     // details::add_optional_header(h, constant::header_if_modified_since, r.if_modified_since());
>                     // details::add_optional_header(h, constant::header_if_match, r.if_match());
>                     // details::add_optional_header(h, constant::header_if_none_match, r.if_none_match());
>                     // details::add_optional_header(h, constant::header_if_unmodified_since, r.if_unmodified_since());
>                     // details::add_optional_header(h, constant::header_range, r.range());
diff -r azure-storage-cpp-lite-org/include/todo/get_blob_properties_request.h cpplite/include/todo/get_blob_properties_request.h
15,16c15,16
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {
>     namespace storage_lite {
diff -r azure-storage-cpp-lite-org/include/todo/query_entities_request.h cpplite/include/todo/query_entities_request.h
14,15c14,15
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {
>     namespace storage_lite {
diff -r azure-storage-cpp-lite-org/include/todo/set_blob_metadata_request.h cpplite/include/todo/set_blob_metadata_request.h
15,16c15,16
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {
>     namespace storage_lite {
diff -r azure-storage-cpp-lite-org/include/utility.h cpplite/include/utility.h
14,15c14
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
17,20c16,20
< enum class date_format {
<     rfc_1123,
<     iso_8601
< };
---
>     enum class date_format
>     {
>         rfc_1123,
>         iso_8601
>     };
22c22
< AZURE_STORAGE_API std::string get_ms_date(date_format format);
---
>     AZURE_STORAGE_API std::string get_ms_date(date_format format);
24c24
< AZURE_STORAGE_API std::string get_ms_range(unsigned long long start_byte, unsigned long long end_byte);
---
>     AZURE_STORAGE_API std::string get_ms_range(unsigned long long start_byte, unsigned long long end_byte);
26c26
< AZURE_STORAGE_API std::string get_http_verb(http_base::http_method method);
---
>     AZURE_STORAGE_API std::string get_http_verb(http_base::http_method method);
28,30c28,33
< inline void add_optional_query(storage_url &url, const std::string &name, unsigned int value) {
<     if (value > 0) {
<         url.add_query(name, std::to_string(value));
---
>     inline void add_optional_query(storage_url &url, const std::string &name, unsigned int value)
>     {
>         if (value > 0)
>         {
>             url.add_query(name, std::to_string(value));
>         }
32d34
< }
34,36c36,41
< inline void add_optional_query(storage_url &url, const std::string &name, const std::string &value) {
<     if (!value.empty()) {
<         url.add_query(name, value);
---
>     inline void add_optional_query(storage_url &url, const std::string &name, const std::string &value)
>     {
>         if (!value.empty())
>         {
>             url.add_query(name, value);
>         }
38d42
< }
40c44
< AZURE_STORAGE_API void add_access_condition_headers(http_base &h, storage_headers &headers, const blob_request_base &r);
---
>     AZURE_STORAGE_API void add_access_condition_headers(http_base &h, storage_headers &headers, const blob_request_base &r);
42,44c46,51
< inline void add_optional_header(http_base &h, const std::string &name, const std::string &value) {
<     if (!value.empty()) {
<         h.add_header(name, value);
---
>     inline void add_optional_header(http_base &h, const std::string &name, const std::string &value)
>     {
>         if (!value.empty())
>         {
>             h.add_header(name, value);
>         }
46d52
< }
48,51c54,60
< inline void add_optional_content_encoding(http_base &h, storage_headers &headers, const std::string &value) {
<     if (!value.empty()) {
<         h.add_header(constants::header_content_encoding, value);
<         headers.content_encoding = value;
---
>     inline void add_optional_content_encoding(http_base &h, storage_headers &headers, const std::string &value)
>     {
>         if (!value.empty())
>         {
>             h.add_header(constants::header_content_encoding, value);
>             headers.content_encoding = value;
>         }
53d61
< }
55,58c63,69
< inline void add_optional_content_language(http_base &h, storage_headers &headers, const std::string &value) {
<     if (!value.empty()) {
<         h.add_header(constants::header_content_language, value);
<         headers.content_language = value;
---
>     inline void add_optional_content_language(http_base &h, storage_headers &headers, const std::string &value)
>     {
>         if (!value.empty())
>         {
>             h.add_header(constants::header_content_language, value);
>             headers.content_language = value;
>         }
60d70
< }
62,66c72,79
< inline void add_content_length(http_base &h, storage_headers &headers, unsigned int length) {
<     std::string value = std::to_string(length);
<     h.add_header(constants::header_content_length, value);
<     if (length > 0) {
<         headers.content_length = value;
---
>     inline void add_content_length(http_base &h, storage_headers &headers, uint64_t length)
>     {
>         std::string value = std::to_string(length);
>         h.add_header(constants::header_content_length, value);
>         if (length > 0)
>         {
>             headers.content_length = value;
>         }
68d80
< }
70,73c82,97
< inline void add_optional_content_md5(http_base &h, storage_headers &headers, const std::string &value) {
<     if (!value.empty()) {
<         h.add_header(constants::header_content_md5, value);
<         headers.content_md5 = value;
---
>     inline void add_optional_content_md5(http_base &h, storage_headers &headers, const std::string &value)
>     {
>         if (!value.empty())
>         {
>             h.add_header(constants::header_content_md5, value);
>             headers.content_md5 = value;
>         }
>     }
> 
>     inline void add_optional_content_type(http_base &h, storage_headers &headers, const std::string &value)
>     {
>         if (!value.empty())
>         {
>             h.add_header(constants::header_content_type, value);
>             headers.content_type = value;
>         }
75d98
< }
77,80c100,106
< inline void add_optional_content_type(http_base &h, storage_headers &headers, const std::string &value) {
<     if (!value.empty()) {
<         h.add_header(constants::header_content_type, value);
<         headers.content_type = value;
---
>     inline void add_ms_header(http_base &h, storage_headers &headers, const std::string &name, const std::string &value, bool optional = false)
>     {
>         if (!optional || !value.empty())
>         {
>             h.add_header(name, value);
>             headers.ms_headers[name] = value;
>         }
82d107
< }
84,87c109,115
< inline void add_ms_header(http_base &h, storage_headers &headers, const std::string &name, const std::string &value, bool optional = false) {
<     if (!optional || !value.empty()) {
<         h.add_header(name, value);
<         headers.ms_headers[name] = value;
---
>     inline void add_ms_header(http_base &h, storage_headers &headers, const std::string &name, unsigned long long value, bool optional = false)
>     {
>         if (!optional || (value != std::numeric_limits<unsigned long long>::max()))
>         {
>             h.add_header(name, std::to_string(value));
>             headers.ms_headers[name] = std::to_string(value);
>         }
89d116
< }
91,92c118
< inline void add_ms_header(http_base &h, storage_headers &headers, const std::string &name, unsigned long long value, bool optional = false) {
<     if (!optional || (value != std::numeric_limits<unsigned long long>::max()) )
---
>     inline void add_metadata_header(http_base &h, storage_headers &headers, const std::string &name, const std::string &value, bool optional = false)
94,95c120
<         h.add_header(name, std::to_string(value));
<         headers.ms_headers[name] = std::to_string(value);
---
>         add_ms_header(h, headers, constants::header_ms_meta_prefix + name, value, optional);
97d121
< }
99,101c123
< inline void add_metadata_header(http_base &h, storage_headers &headers, const std::string &name, const std::string &value, bool optional = false) {
<     add_ms_header(h, headers, constants::header_ms_meta_prefix + name, value, optional);
< }
---
>     AZURE_STORAGE_API bool retryable(http_base::http_code status_code);
103c125,128
< AZURE_STORAGE_API bool retryable(http_base::http_code status_code);
---
>     AZURE_STORAGE_API std::string encode_url_path(const std::string& path);
>     AZURE_STORAGE_API std::string encode_url_query(const std::string& query);
> 
>     AZURE_STORAGE_API std::string to_lowercase(std::string str);
105a131
> 
107,113c133,136
< inline bool unsuccessful(http_base::http_code status_code) {
<     return !(status_code >= 200 && status_code < 300);
< }
< 
< inline lease_status parse_lease_status(const std::string &value) {
<     if (value == "locked") {
<         return lease_status::locked;
---
> 
>     inline bool unsuccessful(http_base::http_code status_code)
>     {
>         return !(status_code >= 200 && status_code < 300);
115c138,148
<     else if (value == "unlocked") {
---
> 
>     inline lease_status parse_lease_status(const std::string &value)
>     {
>         if (value == "locked")
>         {
>             return lease_status::locked;
>         }
>         else if (value == "unlocked")
>         {
>             return lease_status::unlocked;
>         }
118,119d150
<     return lease_status::unlocked;
< }
121,122c152,173
< inline lease_state parse_lease_state(const std::string &value) {
<     if (value == "available") {
---
>     inline lease_state parse_lease_state(const std::string &value)
>     {
>         if (value == "available")
>         {
>             return lease_state::available;
>         }
>         else if (value == "leased")
>         {
>             return lease_state::leased;
>         }
>         else if (value == "expired")
>         {
>             return lease_state::expired;
>         }
>         else if (value == "breaking")
>         {
>             return lease_state::breaking;
>         }
>         else if (value == "broken")
>         {
>             return lease_state::broken;
>         }
125,138d175
<     else if (value == "leased") {
<         return lease_state::leased;
<     }
<     else if (value == "expired") {
<         return lease_state::expired;
<     }
<     else if (value == "breaking") {
<         return lease_state::breaking;
<     }
<     else if (value == "broken") {
<         return lease_state::broken;
<     }
<     return lease_state::available;
< }
140,145c177,187
< inline lease_duration parse_lease_duration(const std::string &value) {
<     if (value == "infinite") {
<         return lease_duration::infinite;
<     }
<     else if (value == "fixed") {
<         return lease_duration::fixed;
---
>     inline lease_duration parse_lease_duration(const std::string &value)
>     {
>         if (value == "infinite")
>         {
>             return lease_duration::infinite;
>         }
>         else if (value == "fixed")
>         {
>             return lease_duration::fixed;
>         }
>         return lease_duration::none;
147,148d188
<     return lease_duration::none;
< }
150,151c190
< }
< }
---
> }}   // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/xml_parser_base.h cpplite/include/xml_parser_base.h
12,13c12
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
15,16c14,16
< class xml_parser_base {
< public:
---
>     class xml_parser_base
>     {
>     public:
18d17
<     virtual storage_error parse_storage_error(const std::string &) const = 0;
20,21c19
<     template<typename RESPONSE_TYPE>
<     RESPONSE_TYPE parse_response(const std::string &) const {}
---
>         virtual storage_error parse_storage_error(const std::string &) const = 0;
23c21,22
<     //virtual list_containers_response parse_list_containers_response(const std::string &xml, std::vector<list_containers_item> &items) const = 0;
---
>         template<typename RESPONSE_TYPE>
>         RESPONSE_TYPE parse_response(const std::string &) const { return RESPONSE_TYPE();  }
25c24
<     virtual list_containers_response parse_list_containers_response(const std::string &xml) const = 0;
---
>         virtual list_constainers_segmented_response parse_list_constainers_segmented_response(const std::string &xml) const = 0;
27c26
<     virtual list_blobs_response parse_list_blobs_response(const std::string &xml) const = 0;
---
>         virtual list_blobs_response parse_list_blobs_response(const std::string &xml) const = 0;
29c28
<     virtual list_blobs_hierarchical_response parse_list_blobs_hierarchical_response(const std::string &xml) const = 0;
---
>         virtual list_blobs_segmented_response parse_list_blobs_segmented_response(const std::string &xml) const = 0;
31c30
<     virtual get_block_list_response parse_get_block_list_response(const std::string &xml) const = 0;
---
>         virtual get_block_list_response parse_get_block_list_response(const std::string &xml) const = 0;
33,34c32,33
<     virtual get_page_ranges_response parse_get_page_ranges_response(const std::string &xml) const = 0;
< };
---
>         virtual get_page_ranges_response parse_get_page_ranges_response(const std::string &xml) const = 0;
>     };
36,39c35,39
< template<>
< inline list_containers_response xml_parser_base::parse_response<list_containers_response>(const std::string &xml) const {
<     return parse_list_containers_response(xml);
< }
---
>     template<>
>     inline list_constainers_segmented_response xml_parser_base::parse_response<list_constainers_segmented_response>(const std::string &xml) const
>     {
>         return parse_list_constainers_segmented_response(xml);
>     }
41,44c41,45
< template<>
< inline list_blobs_response xml_parser_base::parse_response<list_blobs_response>(const std::string &xml) const {
<     return parse_list_blobs_response(xml);
< }
---
>     template<>
>     inline list_blobs_response xml_parser_base::parse_response<list_blobs_response>(const std::string &xml) const
>     {
>         return parse_list_blobs_response(xml);
>     }
46,49c47,51
< template<>
< inline list_blobs_hierarchical_response xml_parser_base::parse_response<list_blobs_hierarchical_response>(const std::string &xml) const {
<     return parse_list_blobs_hierarchical_response(xml);
< }
---
>     template<>
>     inline list_blobs_segmented_response xml_parser_base::parse_response<list_blobs_segmented_response>(const std::string &xml) const
>     {
>         return parse_list_blobs_segmented_response(xml);
>     }
51,54c53,57
< template<>
< inline get_block_list_response xml_parser_base::parse_response<get_block_list_response>(const std::string &xml) const {
<     return parse_get_block_list_response(xml);
< }
---
>     template<>
>     inline get_block_list_response xml_parser_base::parse_response<get_block_list_response>(const std::string &xml) const
>     {
>         return parse_get_block_list_response(xml);
>     }
56,59c59,63
< template<>
< inline get_page_ranges_response xml_parser_base::parse_response<get_page_ranges_response>(const std::string &xml) const {
<     return parse_get_page_ranges_response(xml);
< }
---
>     template<>
>     inline get_page_ranges_response xml_parser_base::parse_response<get_page_ranges_response>(const std::string &xml) const
>     {
>         return parse_get_page_ranges_response(xml);
>     }
61,62c65
< }
< }
---
> }}   // azure::storage_lite
diff -r azure-storage-cpp-lite-org/include/xml_writer.h cpplite/include/xml_writer.h
9,10c9
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
12,44c11,32
<         class xml_writer {
<         public:
<             static std::string write_block_list(const std::vector<put_block_list_request_base::block_item> &items) {
<                 std::string xml;
<                 xml.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
<                 xml.append("<BlockList>");
< 
<                 for (const auto &b : items) {
<                     switch (b.type) {
<                     case put_block_list_request_base::block_type::committed:
<                         xml.append("<Committed>");
<                         break;
<                     case put_block_list_request_base::block_type::uncommitted:
<                         xml.append("<Uncommitted>");
<                         break;
<                     case put_block_list_request_base::block_type::latest:
<                         xml.append("<Latest>");
<                         break;
<                     }
< 
<                     xml.append(b.id);
< 
<                     switch (b.type) {
<                     case put_block_list_request_base::block_type::committed:
<                         xml.append("</Committed>");
<                         break;
<                     case put_block_list_request_base::block_type::uncommitted:
<                         xml.append("</Uncommitted>");
<                         break;
<                     case put_block_list_request_base::block_type::latest:
<                         xml.append("</Latest>");
<                         break;
<                     }
---
>     class xml_writer
>     {
>     public:
>         static std::string write_block_list(const std::vector<put_block_list_request_base::block_item> &items)
>         {
>             std::string xml;
>             xml.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
>             xml.append("<BlockList>");
> 
>             for (const auto &b : items)
>             {
>                 switch (b.type)
>                 {
>                 case put_block_list_request_base::block_type::committed:
>                     xml.append("<Committed>");
>                     break;
>                 case put_block_list_request_base::block_type::uncommitted:
>                     xml.append("<Uncommitted>");
>                     break;
>                 case put_block_list_request_base::block_type::latest:
>                     xml.append("<Latest>");
>                     break;
47,49c35
<                 xml.append("</BlockList>");
<                 return xml;
<             }
---
>                 xml.append(b.id);
51,53c37,49
<         private:
<             //static std::string xml_declaration("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
<         };
---
>                 switch (b.type)
>                 {
>                 case put_block_list_request_base::block_type::committed:
>                     xml.append("</Committed>");
>                     break;
>                 case put_block_list_request_base::block_type::uncommitted:
>                     xml.append("</Uncommitted>");
>                     break;
>                 case put_block_list_request_base::block_type::latest:
>                     xml.append("</Latest>");
>                     break;
>                 }
>             }
54a51,54
>             xml.append("</BlockList>");
>             return xml;
>         }
>     };
56,57c56
<     }
< }
---
> }}
Only in cpplite/: LICENSE
Only in cpplite/: NOTICE.txt
Only in cpplite/: README.md
diff -r azure-storage-cpp-lite-org/sample/CMakeLists.txt cpplite/sample/CMakeLists.txt
4c4,7
< target_link_libraries(azure-storage-sample azure-storage-lite)
\ No newline at end of file
---
> if(WIN32)
>   target_compile_definitions(azure-storage-sample PRIVATE NOMINMAX)
> endif()
> target_link_libraries(azure-storage-sample azure-storage-lite)
Only in azure-storage-cpp-lite-org/sample: Makefile
Only in cpplite/sample: sample2.cpp
diff -r azure-storage-cpp-lite-org/sample/sample.cpp cpplite/sample/sample.cpp
1,6d0
< 
< #include <string>
< #include <chrono>
< #include <thread>
< #include <assert.h>
< 
11,29c5,7
< static std::string account_name = "YOUR_ACCOUNT_NAME";
< 
< // Provide either account key or access token
< // Account key operations require RBAC 'Storage Blob Data Owner'
< static std::string account_key = "";    // Storage account key if using shared key auth
< static std::string access_token = "";   // Get an access token via `az account get-access-token --resource https://storage.azure.com/ -o tsv --query accessToken`
< using namespace microsoft_azure::storage;
< 
< void checkstatus()
< {
<     if(errno == 0)
<     {
<         printf("Success\n");
<     }
<     else
<     {
<         printf("Fail\n");
<     }
< }
---
> #include <iostream>
> #include <fstream>
> #include <sstream>
33,34c11,29
<     std::shared_ptr<storage_credential> cred = nullptr;
<     if (!access_token.empty())
---
>     using namespace azure::storage_lite;
> 
>     std::string account_name = "YOUR_STORAGE_ACCOUNT";
>     std::string account_key = "";
>     std::string container_name = "my-sample-container";
>     std::string blob_name = "my-sample-blob";
> 
>     // Create a file for uploading later
>     std::string sample_file = "sample-file";
>     std::ofstream fout("sample-file");
>     fout << "Hello world!\n";
>     fout.close();
> 
>     std::shared_ptr<storage_credential> cred = std::make_shared<shared_key_credential>(account_name, account_key);
>     std::shared_ptr<storage_account> account = std::make_shared<storage_account>(account_name, cred, /* use_https */ true);
>     blob_client client(account, 16);
> 
>     auto ret = client.create_container(container_name).get();
>     if (!ret.success())
36c31
<         cred = std::make_shared<token_credential>(access_token);
---
>         std::cout << "Failed to create container, Error: " << ret.error().code << ", " << ret.error().code_name << std::endl;
38c33,39
<     else 
---
> 
>     std::ifstream fin(sample_file, std::ios_base::in | std::ios_base::binary);
>     std::vector<std::pair<std::string, std::string>> metadata;
>     metadata.emplace_back(std::make_pair("meta_key1", "meta-value1"));
>     metadata.emplace_back(std::make_pair("meta_key2", "meta-value2"));
>     ret = client.upload_block_blob_from_stream(container_name, blob_name, fin, metadata).get();
>     if (!ret.success())
40c41
<         cred = std::make_shared<shared_key_credential>(account_name, account_key);
---
>         std::cout << "Failed to upload blob, Error: " << ret.error().code << ", " << ret.error().code_name << std::endl;
42,57c43
<     std::shared_ptr<storage_account> account = std::make_shared<storage_account>(account_name, cred, /* use_https */ true);
<     auto bC = std::make_shared<blob_client>(account, 10);
<     //auto f1 = bc.list_containers("");
<     //f1.wait();
<     //
<     std::string containerName = "jasontest1";
<     std::string blobName = "test.txt";
<     std::string destContainerName = "jasontest1";
<     std::string destBlobName = "test.txt.copy";
<     std::string uploadFileName = "test.txt";
<     std::string downloadFileName = "download.txt";
< 
<     bool exists = true;
<     blob_client_wrapper bc(bC);
<  
<     exists = bc.container_exists(containerName);
---
>     fin.close();
59c45,47
<     if(!exists)
---
>     std::ostringstream out_stream;
>     ret = client.download_blob_to_stream(container_name, blob_name, 0, 0, out_stream).get();
>     if (!ret.success())
61,62c49
<         bc.create_container(containerName);
<         assert(errno == 0);
---
>         std::cout << "Failed to download blob, Error: " << ret.error().code << ", " << ret.error().code_name << std::endl;
64,92c51
< 
<     assert(errno == 0);
<     exists = bc.blob_exists(containerName, "testsss.txt");
<     assert(errno == 0);
<     assert(!exists);
<     std::cout <<"Start upload Blob: " << blobName << std::endl;
<     bc.upload_file_to_blob(uploadFileName, containerName, blobName);
<     std::cout <<"Error upload Blob: " << errno << std::endl;
<     assert(errno == 0);
< 
<     exists = bc.blob_exists(containerName, blobName);
<     assert(errno == 0);
<     assert(exists);
< 
<     auto blobProperty = bc.get_blob_property(containerName, blobName);
<     assert(errno == 0);
<     std::cout <<"Size of BLob: " << blobProperty.size << std::endl;
< 
<     auto blobs = bc.list_blobs_hierarchical(containerName, "/", "", "");
<     std::cout <<"Size of BLobs: " << blobs.size() << std::endl;
<     std::cout <<"Error Size of BLobs: " << errno << std::endl;
<     assert(errno == 0);
< 
<     time_t last_modified;
<     bc.download_blob_to_file(containerName, blobName, downloadFileName, last_modified);
<     std::cout <<"Download Blob done: " << errno << std::endl;
<     assert(errno == 0);
<     exists = bc.container_exists(destContainerName);
<     if(!exists)
---
>     else
94,95c53
<         bc.create_container(destContainerName);
<         assert(errno == 0);
---
>         std::cout << out_stream.str();
98,114c56,58
<     // copy blob 
<     bc.start_copy(containerName, blobName, destContainerName, destBlobName);
<     auto property = bc.get_blob_property(destContainerName, destBlobName);
<     std::cout << "Copy status: " << property.copy_status <<std::endl;
<     exists = bc.blob_exists(destContainerName, destBlobName);
<     assert(errno == 0);
<     assert(exists);
< 
<     bc.delete_blob(containerName, blobName);
<     bc.delete_blob(destContainerName, destBlobName);
<     assert(errno == 0);
<     exists = bc.blob_exists(containerName, blobName);
<     assert(errno == 0);
<     assert(!exists);
<     //bc.delete_container(containerName);
<     //assert(errno == 0);
<     //std::this_thread::sleep_for(std::chrono::seconds(5));
---
>     client.delete_blob(container_name, blob_name).wait();
> 
>     return 0;
diff -r azure-storage-cpp-lite-org/src/append_block_request_base.cpp cpplite/src/append_block_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,10c8,10
<         void append_block_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
---
>     void append_block_request_base::build_request(const storage_account &a, http_base &h) const
>     {
>         const auto &r = *this;
12c12
<             h.set_data_rate_timeout();
---
>         h.set_data_rate_timeout();
14c14
<             h.set_method(http_base::http_method::put);
---
>         h.set_method(http_base::http_method::put);
16,17c16,17
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.container()).append_path(r.blob());
---
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.container()).append_path(r.blob());
19,21c19,21
<             url.add_query(constants::query_comp, constants::query_comp_appendblock);
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
---
>         url.add_query(constants::query_comp, constants::query_comp_appendblock);
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
23,26c23,26
<             storage_headers headers;
<             add_content_length(h, headers, r.content_length());
<             add_optional_content_md5(h, headers, r.content_md5());
<             add_access_condition_headers(h, headers, r);
---
>         storage_headers headers;
>         add_content_length(h, headers, r.content_length());
>         add_optional_content_md5(h, headers, r.content_md5());
>         add_access_condition_headers(h, headers, r);
28,29c28,29
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
<             add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
---
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
>         add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
31,32c31,32
<             add_ms_header(h, headers, constants::header_ms_blob_condition_maxsize, r.ms_blob_condition_maxsize(), true);
<             add_ms_header(h, headers, constants::header_ms_blob_condition_appendpos, r.ms_blob_condition_appendpos(), true);
---
>         add_ms_header(h, headers, constants::header_ms_blob_condition_maxsize, r.ms_blob_condition_maxsize(), true);
>         add_ms_header(h, headers, constants::header_ms_blob_condition_appendpos, r.ms_blob_condition_appendpos(), true);
34,39c34,36
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
< 
<             a.credential()->sign_request(r, h, url, headers);
<         }
---
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
40a38
>         a.credential()->sign_request(r, h, url, headers);
42c40,41
< }
---
> 
> }} // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/base64.cpp cpplite/src/base64.cpp
7c7,8
<     bool is_ascii(char c) {
---
>     bool is_ascii(char c)
>     {
12,13c13
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
15c15
<         static const char* _base64_enctbl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
---
>     static const char* _base64_enctbl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
17,34c17,25
<         const std::array<unsigned char, 128> _base64_dectbl =
<         { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
<         255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
<         255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63,
<         52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 254, 255, 255,
<         255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
<         15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255,
<         255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
<         41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 255, 255, 255, 255, 255 } };
< 
<         struct _triple_byte {
<             unsigned char _1_1 : 2;
<             unsigned char _0 : 6;
<             unsigned char _2_1 : 4;
<             unsigned char _1_2 : 4;
<             unsigned char _3 : 6;
<             unsigned char _2_2 : 2;
<         };
---
>     const std::array<unsigned char, 128> _base64_dectbl =
>     { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
>     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
>     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63,
>     52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 254, 255, 255,
>     255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
>     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255,
>     255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
>     41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 255, 255, 255, 255, 255 } };
36,37c27,38
<         std::string to_base64(const std::vector<unsigned char> &input)
<         {
---
>     struct _triple_byte
>     {
>         unsigned char _1_1 : 2;
>         unsigned char _0 : 6;
>         unsigned char _2_1 : 4;
>         unsigned char _1_2 : 4;
>         unsigned char _3 : 6;
>         unsigned char _2_2 : 2;
>     };
> 
>     std::string to_base64(const std::vector<unsigned char> &input)
>     {
45,46c46,47
<             std::string result;
<             result.reserve((size / 3 + 1) * 4);
---
>         std::string result;
>         result.reserve((size / 3 + 1) * 4);
48,86c49,61
<             for (; size >= 3;) {
<                 const _triple_byte* record = reinterpret_cast<const _triple_byte*>(ptr);
<                 unsigned char idx0 = record->_0;
<                 unsigned char idx1 = (record->_1_1 << 4) | record->_1_2;
<                 unsigned char idx2 = (record->_2_1 << 2) | record->_2_2;
<                 unsigned char idx3 = record->_3;
<                 result.push_back(char(_base64_enctbl[idx0]));
<                 result.push_back(char(_base64_enctbl[idx1]));
<                 result.push_back(char(_base64_enctbl[idx2]));
<                 result.push_back(char(_base64_enctbl[idx3]));
<                 size -= 3;
<                 ptr += 3;
<             }
< 
<             switch (size) {
<             case 1: {
<                 const _triple_byte* record = reinterpret_cast<const _triple_byte*>(ptr);
<                 unsigned char idx0 = record->_0;
<                 unsigned char idx1 = (record->_1_1 << 4);
<                 result.push_back(char(_base64_enctbl[idx0]));
<                 result.push_back(char(_base64_enctbl[idx1]));
<                 result.push_back('=');
<                 result.push_back('=');
<                 break;
<             }
<             case 2: {
<                 const _triple_byte* record = reinterpret_cast<const _triple_byte*>(ptr);
<                 unsigned char idx0 = record->_0;
<                 unsigned char idx1 = (record->_1_1 << 4) | record->_1_2;
<                 unsigned char idx2 = (record->_2_1 << 2);
<                 result.push_back(char(_base64_enctbl[idx0]));
<                 result.push_back(char(_base64_enctbl[idx1]));
<                 result.push_back(char(_base64_enctbl[idx2]));
<                 result.push_back('=');
<                 break;
<             }
<             }
< 
<             return result;
---
>         for (; size >= 3;)
>         {
>             const _triple_byte* record = reinterpret_cast<const _triple_byte*>(ptr);
>             unsigned char idx0 = record->_0;
>             unsigned char idx1 = (record->_1_1 << 4) | record->_1_2;
>             unsigned char idx2 = (record->_2_1 << 2) | record->_2_2;
>             unsigned char idx3 = record->_3;
>             result.push_back(char(_base64_enctbl[idx0]));
>             result.push_back(char(_base64_enctbl[idx1]));
>             result.push_back(char(_base64_enctbl[idx2]));
>             result.push_back(char(_base64_enctbl[idx3]));
>             size -= 3;
>             ptr += 3;
89c64,76
<         std::vector<unsigned char> from_base64(const std::string &input)
---
>         switch (size)
>         {
>         case 1: {
>             const _triple_byte* record = reinterpret_cast<const _triple_byte*>(ptr);
>             unsigned char idx0 = record->_0;
>             unsigned char idx1 = (record->_1_1 << 4);
>             result.push_back(char(_base64_enctbl[idx0]));
>             result.push_back(char(_base64_enctbl[idx1]));
>             result.push_back('=');
>             result.push_back('=');
>             break;
>         }
>         case 2:
91c78,88
<             std::vector<unsigned char> result;
---
>             const _triple_byte* record = reinterpret_cast<const _triple_byte*>(ptr);
>             unsigned char idx0 = record->_0;
>             unsigned char idx1 = (record->_1_1 << 4) | record->_1_2;
>             unsigned char idx2 = (record->_2_1 << 2);
>             result.push_back(char(_base64_enctbl[idx0]));
>             result.push_back(char(_base64_enctbl[idx1]));
>             result.push_back(char(_base64_enctbl[idx2]));
>             result.push_back('=');
>             break;
>         }
>         }
93,94c90,91
<             if (input.empty())
<                 return result;
---
>         return result;
>     }
96c93,95
<             size_t padding = 0;
---
>     std::vector<unsigned char> from_base64(const std::string &input)
>     {
>         std::vector<unsigned char> result;
98c97,106
<             // Validation
---
>         if (input.empty())
>             return result;
> 
>         size_t padding = 0;
> 
>         // Validation
>         {
>             auto size = input.size();
> 
>             if ((size % 4) != 0)
100c108,109
<                 auto size = input.size();
---
>                 throw std::runtime_error("length of base64 string is not an even multiple of 4");
>             }
102c111,114
<                 if ((size % 4) != 0)
---
>             for (auto iter = input.begin(); iter != input.end(); ++iter, --size)
>             {
>                 const auto ch = *iter;
>                 if (!is_ascii(ch))
104c116
<                     throw std::runtime_error("length of base64 string is not an even multiple of 4");
---
>                     throw std::runtime_error("invalid character found in base64 string");
106,107c118,119
< 
<                 for (auto iter = input.begin(); iter != input.end(); ++iter, --size)
---
>                 const size_t ch_sz = static_cast<size_t>(ch);
>                 if (ch_sz >= _base64_dectbl.size() || _base64_dectbl[ch_sz] == 255)
109,115c121,127
<                     const auto ch = *iter;
<                     if (!is_ascii(ch))
<                     {
<                         throw std::runtime_error("invalid character found in base64 string");
<                     }
<                     const size_t ch_sz = static_cast<size_t>(ch);
<                     if (ch_sz >= _base64_dectbl.size() || _base64_dectbl[ch_sz] == 255)
---
>                     throw std::runtime_error("invalid character found in base64 string");
>                 }
>                 if (_base64_dectbl[ch_sz] == 254)
>                 {
>                     padding++;
>                     // padding only at the end
>                     if (size > 2)
117c129
<                         throw std::runtime_error("invalid character found in base64 string");
---
>                         throw std::runtime_error("invalid padding character found in base64 string");
119c131
<                     if (_base64_dectbl[ch_sz] == 254)
---
>                     if (size == 2)
121,123c133,134
<                         padding++;
<                         // padding only at the end
<                         if (size > 2)
---
>                         const auto ch2 = *(iter + 1);
>                         if (!is_ascii(ch2))
127c138,139
<                         if (size == 2)
---
>                         const size_t ch2_sz = static_cast<size_t>(ch2);
>                         if (ch2_sz >= _base64_dectbl.size() || _base64_dectbl[ch2_sz] != 254)
129,138c141
<                             const auto ch2 = *(iter + 1);
<                             if (!is_ascii(ch2))
<                             {
<                                 throw std::runtime_error("invalid padding character found in base64 string");
<                             }
<                             const size_t ch2_sz = static_cast<size_t>(ch2);
<                             if (ch2_sz >= _base64_dectbl.size() || _base64_dectbl[ch2_sz] != 254)
<                             {
<                                 throw std::runtime_error("invalid padding character found in base64 string");
<                             }
---
>                             throw std::runtime_error("invalid padding character found in base64 string");
142a146
>         }
145,146c149,150
<             auto size = input.size();
<             const char* ptr = &input[0];
---
>         auto size = input.size();
>         const char* ptr = &input[0];
148,149c152,153
<             auto outsz = (size / 4) * 3;
<             outsz -= padding;
---
>         auto outsz = (size / 4) * 3;
>         outsz -= padding;
151c155
<             result.resize(outsz);
---
>         result.resize(outsz);
153,158c157,179
<             size_t idx = 0;
<             for (; size > 4; ++idx)
<             {
<                 unsigned char target[3];
<                 std::memset(target, 0, sizeof(target));
<                 _triple_byte* record = reinterpret_cast<_triple_byte*>(target);
---
>         size_t idx = 0;
>         for (; size > 4; ++idx)
>         {
>             unsigned char target[3];
>             std::memset(target, 0, sizeof(target));
>             _triple_byte* record = reinterpret_cast<_triple_byte*>(target);
> 
>             unsigned char val0 = _base64_dectbl[ptr[0]];
>             unsigned char val1 = _base64_dectbl[ptr[1]];
>             unsigned char val2 = _base64_dectbl[ptr[2]];
>             unsigned char val3 = _base64_dectbl[ptr[3]];
> 
>             record->_0 = val0;
>             record->_1_1 = val1 >> 4;
>             result[idx] = target[0];
> 
>             record->_1_2 = val1 & 0xF;
>             record->_2_1 = val2 >> 2;
>             result[++idx] = target[1];
> 
>             record->_2_2 = val2 & 0x3;
>             record->_3 = val3 & 0x3F;
>             result[++idx] = target[2];
160,163c181,183
<                 unsigned char val0 = _base64_dectbl[ptr[0]];
<                 unsigned char val1 = _base64_dectbl[ptr[1]];
<                 unsigned char val2 = _base64_dectbl[ptr[2]];
<                 unsigned char val3 = _base64_dectbl[ptr[3]];
---
>             ptr += 4;
>             size -= 4;
>         }
165,167c185,199
<                 record->_0 = val0;
<                 record->_1_1 = val1 >> 4;
<                 result[idx] = target[0];
---
>         // Handle the last four bytes separately, to avoid having the conditional statements
>         // in all the iterations (a performance issue).
>         {
>             unsigned char target[3];
>             std::memset(target, 0, sizeof(target));
>             _triple_byte* record = reinterpret_cast<_triple_byte*>(target);
> 
>             unsigned char val0 = _base64_dectbl[ptr[0]];
>             unsigned char val1 = _base64_dectbl[ptr[1]];
>             unsigned char val2 = _base64_dectbl[ptr[2]];
>             unsigned char val3 = _base64_dectbl[ptr[3]];
> 
>             record->_0 = val0;
>             record->_1_1 = val1 >> 4;
>             result[idx] = target[0];
169c201,203
<                 record->_1_2 = val1 & 0xF;
---
>             record->_1_2 = val1 & 0xF;
>             if (val2 != 254)
>             {
172,178d205
< 
<                 record->_2_2 = val2 & 0x3;
<                 record->_3 = val3 & 0x3F;
<                 result[++idx] = target[2];
< 
<                 ptr += 4;
<                 size -= 4;
180,182c207
< 
<             // Handle the last four bytes separately, to avoid having the conditional statements
<             // in all the iterations (a performance issue).
---
>             else
184,198c209,210
<                 unsigned char target[3];
<                 std::memset(target, 0, sizeof(target));
<                 _triple_byte* record = reinterpret_cast<_triple_byte*>(target);
< 
<                 unsigned char val0 = _base64_dectbl[ptr[0]];
<                 unsigned char val1 = _base64_dectbl[ptr[1]];
<                 unsigned char val2 = _base64_dectbl[ptr[2]];
<                 unsigned char val3 = _base64_dectbl[ptr[3]];
< 
<                 record->_0 = val0;
<                 record->_1_1 = val1 >> 4;
<                 result[idx] = target[0];
< 
<                 record->_1_2 = val1 & 0xF;
<                 if (val2 != 254)
---
>                 // There shouldn't be any information (ones) in the unused bits,
>                 if (record->_1_2 != 0)
200,210c212
<                     record->_2_1 = val2 >> 2;
<                     result[++idx] = target[1];
<                 }
<                 else
<                 {
<                     // There shouldn't be any information (ones) in the unused bits,
<                     if (record->_1_2 != 0)
<                     {
<                         throw std::runtime_error("Invalid end of base64 string");
<                     }
<                     return result;
---
>                     throw std::runtime_error("Invalid end of base64 string");
211a214,215
>                 return result;
>             }
213,219c217,226
<                 record->_2_2 = val2 & 0x3;
<                 if (val3 != 254)
<                 {
<                     record->_3 = val3 & 0x3F;
<                     result[++idx] = target[2];
<                 }
<                 else
---
>             record->_2_2 = val2 & 0x3;
>             if (val3 != 254)
>             {
>                 record->_3 = val3 & 0x3F;
>                 result[++idx] = target[2];
>             }
>             else
>             {
>                 // There shouldn't be any information (ones) in the unused bits.
>                 if (record->_2_2 != 0)
221,226c228
<                     // There shouldn't be any information (ones) in the unused bits.
<                     if (record->_2_2 != 0)
<                     {
<                         throw std::runtime_error("Invalid end of base64 string");
<                     }
<                     return result;
---
>                     throw std::runtime_error("Invalid end of base64 string");
227a230
>                 return result;
229,230d231
< 
<             return result;
232a234
>         return result;
234c236,237
< }
---
> 
> }}  // azure::storage_lite
Only in azure-storage-cpp-lite-org/src/blob: blob_client_attr_cache_wrapper.cpp
diff -r azure-storage-cpp-lite-org/src/blob/blob_client.cpp cpplite/src/blob/blob_client.cpp
1a2
> #include <future>
2a4,9
> 
> #ifdef _WIN32
> #include <BaseTsd.h>
> typedef SSIZE_T ssize_t;
> #endif
> 
20a28,29
> #include "blob/set_container_metadata_request.h"
> #include "blob/set_blob_metadata_request.h"
21a31,32
> #include "constants.h"
> #include "storage_errno.h"
23a35
> #include "base64.h"
24a37,38
> #include "mstream.h"
> 
27,28c41
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
33c46,47
< ssize_t get_length_from_content_range(const std::string &header) {
---
> ssize_t get_length_from_content_range(const std::string &header)
> {
48c62,63
< storage_outcome<chunk_property> blob_client::get_chunk_to_stream_sync(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, std::ostream &os) {
---
> storage_outcome<chunk_property> blob_client::get_chunk_to_stream_sync(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, std::ostream &os)
> {
60a76
>     // TODO: async submit transfered to sync operation. This can be utilized.
65,68c81,84
<         property.etag = http->get_header(constants::header_etag);
<         property.totalSize = get_length_from_content_range(http->get_header(constants::header_content_range));
<         std::istringstream(http->get_header(constants::header_content_length)) >> property.size;
<         property.last_modified = curl_getdate(http->get_header(constants::header_last_modified).c_str(), NULL);
---
>         property.etag = http->get_response_header(constants::header_etag);
>         property.totalSize = get_length_from_content_range(http->get_response_header(constants::header_content_range));
>         std::istringstream(http->get_response_header(constants::header_content_length)) >> property.size;
>         property.last_modified = curl_getdate(http->get_response_header(constants::header_last_modified).c_str(), NULL);
74c90,91
< std::future<storage_outcome<void>> blob_client::download_blob_to_stream(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, std::ostream &os) {
---
> std::future<storage_outcome<void>> blob_client::download_blob_to_stream(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, std::ostream &os)
> {
92c109,188
< std::future<storage_outcome<void>> blob_client::upload_block_blob_from_stream(const std::string &container, const std::string &blob, std::istream &is, const std::vector<std::pair<std::string, std::string>> &metadata) {
---
> std::future<storage_outcome<void>> blob_client::download_blob_to_buffer(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, char* buffer, int parallelism)
> {
>     parallelism = std::min(parallelism, int(concurrency()));
> 
>     const uint64_t grain_size = 64 * 1024;
>     uint64_t block_size = size / parallelism;
>     block_size = (block_size + grain_size - 1) / grain_size * grain_size;
>     block_size = std::min(block_size, constants::default_block_size);
> 
>     int num_blocks = int((size + block_size - 1) / block_size);
> 
>     struct concurrent_task_info
>     {
>         std::string container;
>         std::string blob;
>         char* buffer;
>         uint64_t download_offset;
>         uint64_t download_size;
>         uint64_t block_size;
>         int num_blocks;
>     };
>     struct concurrent_task_context
>     {
>         std::atomic<int> num_workers{ 0 };
>         std::atomic<int> block_index{ 0 };
>         std::atomic<bool> failed{ false };
>         storage_error failed_reason;
> 
>         std::promise<storage_outcome<void>> task_promise;
>         std::vector<std::future<void>> task_futures;
>     };
> 
>     auto info = std::make_shared<concurrent_task_info>(concurrent_task_info{ container, blob, buffer, offset, size, block_size, num_blocks });
>     auto context = std::make_shared<concurrent_task_context>();
>     context->num_workers = parallelism;
> 
>     auto thread_download_func = [this, info, context]()
>     {
>         while (true)
>         {
>             int i = context->block_index.fetch_add(1);
>             if (i >= info->num_blocks || context->failed)
>             {
>                 break;
>             }
>             char* block_buffer = info->buffer + info->block_size * i;
>             uint64_t block_size = std::min(info->block_size, info->download_size - info->block_size * i);
> 
>             auto http = m_client->get_handle();
>             auto request = std::make_shared<download_blob_request>(info->container, info->blob);
>             request->set_start_byte(info->download_offset + info->block_size * i);
>             request->set_end_byte(request->start_byte() + block_size - 1);
> 
>             auto os = std::make_shared<omstream>(block_buffer, block_size);
>             http->set_output_stream(storage_ostream(os));
> 
>             auto result = async_executor<void>::submit(m_account, request, http, m_context).get();
> 
>             if (!result.success() && !context->failed.exchange(true))
>             {
>                 context->failed_reason = result.error();
>             }
>         }
>         if (context->num_workers.fetch_sub(1) == 1)
>         {
>             // I'm the last worker thread
>             context->task_promise.set_value(context->failed ? storage_outcome<void>(context->failed_reason) : storage_outcome<void>());
>         }
>     };
> 
>     for (int i = 0; i < parallelism; ++i)
>     {
>         context->task_futures.emplace_back(std::async(std::launch::async, thread_download_func));
>     }
> 
>     return context->task_promise.get_future();
> }
> 
> std::future<storage_outcome<void>> blob_client::upload_block_blob_from_stream(const std::string &container, const std::string &blob, std::istream &is, const std::vector<std::pair<std::string, std::string>> &metadata)
> {
101d196
<     //check < 2^32
113c208,342
< std::future<storage_outcome<void>> blob_client::delete_blob(const std::string &container, const std::string &blob, bool delete_snapshots) {
---
> std::future<storage_outcome<void>> blob_client::upload_block_blob_from_stream(const std::string &container, const std::string &blob, std::istream &is, const std::vector<std::pair<std::string, std::string>> &metadata, uint64_t streamlen)
> {
>     auto http = m_client->get_handle();
> 
>     auto request = std::make_shared<create_block_blob_request>(container, blob);
> 
>     request->set_content_length(static_cast<unsigned int>(streamlen));
>     if (metadata.size() > 0)
>     {
>         request->set_metadata(metadata);
>     }
> 
>     http->set_input_stream(storage_istream(is));
>     http->set_is_input_length_known();
>     http->set_input_content_length(streamlen);
> 
>     return async_executor<void>::submit(m_account, request, http, m_context);
> }
> 
> std::future<storage_outcome<void>> blob_client::upload_block_blob_from_buffer(const std::string &container, const std::string &blob, const char* buffer, const std::vector<std::pair<std::string, std::string>> &metadata, uint64_t bufferlen, int parallelism)
> {
>     if (bufferlen > constants::max_num_blocks * constants::max_block_size)
>     {
>         storage_error error;
>         error.code = std::to_string(blob_too_big);
>         std::promise<storage_outcome<void>> promise;
>         promise.set_value(storage_outcome<void>(error));
>         return promise.get_future();
>     }
> 
>     parallelism = std::min(parallelism, int(concurrency()));
> 
>     const uint64_t grain_size = 4 * 1024 * 1024;
>     uint64_t block_size = bufferlen / constants::max_num_blocks;
>     block_size = (block_size + grain_size - 1) / grain_size * grain_size;
>     block_size = std::min(block_size, constants::max_block_size);
>     block_size = std::max(block_size, constants::default_block_size);
> 
>     int num_blocks = int((bufferlen + block_size - 1) / block_size);
> 
>     std::vector<put_block_list_request_base::block_item> block_list;
>     block_list.reserve(num_blocks);
>     std::string uuid = get_uuid();
>     for (int i = 0; i < num_blocks; ++i)
>     {
>         std::string block_id = std::to_string(i);
>         block_id = uuid + std::string(48 - uuid.length() - block_id.length(), '-') + block_id;
>         block_id = to_base64(reinterpret_cast<const unsigned char*>(block_id.data()), block_id.length());
>         block_list.emplace_back(put_block_list_request_base::block_item{ std::move(block_id), put_block_list_request_base::block_type::uncommitted });
>     }
> 
>     struct concurrent_task_info
>     {
>         std::string container;
>         std::string blob;
>         const char* buffer;
>         uint64_t blob_size;
>         uint64_t block_size;
>         int num_blocks;
>         std::vector<put_block_list_request_base::block_item> block_list;
>         std::vector<std::pair<std::string, std::string>> metadata;
>     };
>     struct concurrent_task_context
>     {
>         std::atomic<int> num_workers{ 0 };
>         std::atomic<int> block_index{ 0 };
>         std::atomic<bool> failed{ false };
>         storage_error failed_reason;
> 
>         std::promise<storage_outcome<void>> task_promise;
>         std::vector<std::future<void>> task_futures;
>     };
>     auto info = std::make_shared<concurrent_task_info>(concurrent_task_info{ container, blob, buffer, bufferlen, block_size, num_blocks, std::move(block_list), metadata });
>     auto context = std::make_shared<concurrent_task_context>();
>     context->num_workers = parallelism;
> 
>     auto thread_upload_func = [this, info, context]()
>     {
>         while (true)
>         {
>             int i = context->block_index.fetch_add(1);
>             if (i >= info->num_blocks || context->failed)
>             {
>                 break;
>             }
>             const char* block_buffer = info->buffer + info->block_size * i;
>             uint64_t block_size = std::min(info->block_size, info->blob_size - info->block_size * i);
>             auto result = upload_block_from_buffer(info->container, info->blob, info->block_list[i].id, block_buffer, block_size).get();
> 
>             if (!result.success() && !context->failed.exchange(true))
>             {
>                 context->failed_reason = result.error();
>             }
>         }
>         if (context->num_workers.fetch_sub(1) == 1)
>         {
>             // I'm the last worker thread
>             if (!context->failed)
>             {
>                 auto result = put_block_list(info->container, info->blob, info->block_list, info->metadata).get();
>                 if (!result.success())
>                 {
>                     context->failed.store(true);
>                     context->failed_reason = result.error();
>                 }
>             }
>             context->task_promise.set_value(context->failed ? storage_outcome<void>(context->failed_reason) : storage_outcome<void>());
>         }
>     };
> 
>     for (int i = 0; i < parallelism; ++i)
>     {
>         context->task_futures.emplace_back(std::async(std::launch::async, thread_upload_func));
>     }
> 
>     return context->task_promise.get_future();
> }
> 
> std::future<storage_outcome<void>> blob_client::upload_block_from_buffer(const std::string &container, const std::string &blob, const std::string &blockid, const char* buff, uint64_t bufferlen)
> {
>     auto http = m_client->get_handle();
> 
>     auto request = std::make_shared<put_block_request>(container, blob, blockid);
>     request->set_content_length(static_cast<unsigned int>(bufferlen));
> 
>     auto is = std::make_shared<imstream>(buff, bufferlen);
>     http->set_input_stream(storage_istream(is));
>     http->set_is_input_length_known();
>     http->set_input_content_length(bufferlen);
> 
>     return async_executor<void>::submit(m_account, request, http, m_context);
> }
> 
> std::future<storage_outcome<void>> blob_client::delete_blob(const std::string &container, const std::string &blob, bool delete_snapshots)
> {
121c350,351
< std::future<storage_outcome<void>> blob_client::create_container(const std::string &container) {
---
> std::future<storage_outcome<void>> blob_client::create_container(const std::string &container)
> {
129c359,360
< std::future<storage_outcome<void>> blob_client::delete_container(const std::string &container) {
---
> std::future<storage_outcome<void>> blob_client::delete_container(const std::string &container)
> {
137c368,369
< storage_outcome<container_property> blob_client::get_container_property(const std::string &container) {
---
> std::future<storage_outcome<container_property>> blob_client::get_container_properties(const std::string &container)
> {
142,146c374
<     auto response = async_executor<void>::submit(m_account, request, http, m_context).get();
<     container_property containerProperty(true);
<     if (response.success())
<     {
<         containerProperty.etag = http->get_header(constants::header_etag);
---
>     std::shared_future<storage_outcome<void>> response = async_executor<void>::submit(m_account, request, http, m_context);
148,149c376,378
<         auto& headers = http->get_headers();
<         for (auto iter = headers.begin(); iter != headers.end(); ++iter)
---
>     std::future<storage_outcome<container_property>> container_properties = std::async(std::launch::deferred, [http, response]()
>     {
>         if (response.get().success())
151c380,384
<             if (iter->first.find("x-ms-metadata-") == 0)
---
>             container_property properties(true);
>             properties.etag = http->get_response_header(constants::header_etag);
> 
>             auto& headers = http->get_response_headers();
>             for (auto iter = headers.begin(); iter != headers.end(); ++iter)
153c386,389
<                 containerProperty.metadata.push_back(std::make_pair(iter->first, iter->second));
---
>                 if (iter->first.find(constants::header_ms_meta_prefix) == 0)
>                 {
>                     properties.metadata.push_back(std::make_pair(iter->first.substr(constants::header_ms_meta_prefix_size), iter->second));
>                 }
154a391
>             return storage_outcome<container_property>(properties);
156,178c393,395
<     }
<     else
<     {
<         containerProperty.set_valid(false);
<     }
<     return storage_outcome<container_property>(containerProperty);
< }
< 
< /*AZURE_STORAGE_API std::vector<list_containers_item> blob_client::list_containers(const std::string &prefix, bool include_metadata) {
<     std::vector<list_containers_item> results;
<     retry_policy policy;
<     list_containers_request request(prefix, include_metadata);
<     request.set_maxresults(2);
< 
<     std::string marker;
<     do {
<         request.set_marker(marker);
<         auto outcome = executor<list_containers_response>::make_requests(*m_account, request, *m_client, **m_context.xml_parser(), policy);
<         if (outcome.success()) {
<             const auto &response = outcome.response();
<             marker = response.next_marker;
<             const auto &containers = response.containers;
<             results.insert(results.end(), containers.begin(), containers.end());
---
>         else
>         {
>             return storage_outcome<container_property>(response.get().error());
180,183c397,399
<     } while (!marker.empty());
< 
<     return results;
< }*/
---
>     });
>     return container_properties;
> }
185,189c401
< std::future<storage_outcome<list_containers_response>> blob_client::list_containers(
<         const std::string &prefix,
<         const std::string& continuation_token,
<         const int max_result,
<         bool include_metadata)
---
> std::future<storage_outcome<void>> blob_client::set_container_metadata(const std::string &container, const std::vector<std::pair<std::string, std::string>>& metadata)
193,196c405
<     auto request = std::make_shared<list_containers_request>(prefix, include_metadata);
<     request->set_maxresults(max_result);
< 	
< 	request->set_marker(continuation_token);
---
>     auto request = std::make_shared<set_container_metadata_request>(container, metadata);
198c407
<     return async_executor<list_containers_response>::submit(m_account, request, http, m_context);
---
>     return async_executor<void>::submit(m_account, request, http, m_context);
201c410,411
< std::future<storage_outcome<list_blobs_response>> blob_client::list_blobs(const std::string &container, const std::string &prefix) {
---
> std::future<storage_outcome<list_constainers_segmented_response>> blob_client::list_containers_segmented(const std::string &prefix, const std::string& continuation_token, const int max_result, bool include_metadata)
> {
204,205c414,416
<     auto request = std::make_shared<list_blobs_request>(container, prefix);
<     request->set_maxresults(2);
---
>     auto request = std::make_shared<list_containers_request>(prefix, include_metadata);
>     request->set_maxresults(max_result);
>     request->set_marker(continuation_token);
207c418
<     return async_executor<list_blobs_response>::submit(m_account, request, http, m_context);
---
>     return async_executor<list_constainers_segmented_response>::submit(m_account, request, http, m_context);
210c421,422
< std::future<storage_outcome<list_blobs_hierarchical_response>> blob_client::list_blobs_hierarchical(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix, int max_results) {
---
> std::future<storage_outcome<list_blobs_segmented_response>> blob_client::list_blobs_segmented(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix, int max_results)
> {
213c425
<     auto request = std::make_shared<list_blobs_hierarchical_request>(container, delimiter, continuation_token, prefix);
---
>     auto request = std::make_shared<list_blobs_segmented_request>(container, delimiter, continuation_token, prefix);
217c429
<     return async_executor<list_blobs_hierarchical_response>::submit(m_account, request, http, m_context);
---
>     return async_executor<list_blobs_segmented_response>::submit(m_account, request, http, m_context);
220c432,433
< std::future<storage_outcome<get_block_list_response>> blob_client::get_block_list(const std::string &container, const std::string &blob) {
---
> std::future<storage_outcome<get_block_list_response>> blob_client::get_block_list(const std::string &container, const std::string &blob)
> {
228c441,442
< storage_outcome<blob_property> blob_client::get_blob_property(const std::string &container, const std::string &blob) {
---
> std::future<storage_outcome<blob_property>> blob_client::get_blob_properties(const std::string &container, const std::string &blob)
> {
233,235c447,449
<     auto response = async_executor<void>::submit(m_account, request, http, m_context).get();
<     blob_property blobProperty(true);
<     if (response.success())
---
>     std::shared_future<storage_outcome<void>> response = async_executor<void>::submit(m_account, request, http, m_context);
> 
>     std::future<storage_outcome<blob_property>> blob_properties = std::async(std::launch::deferred, [http, response]()
237,248c451
<         blobProperty.cache_control = http->get_header(constants::header_cache_control);
<         blobProperty.content_disposition = http->get_header(constants::header_content_disposition);
<         blobProperty.content_encoding = http->get_header(constants::header_content_encoding);
<         blobProperty.content_language = http->get_header(constants::header_content_language);
<         blobProperty.content_md5 = http->get_header(constants::header_content_md5);
<         blobProperty.content_type = http->get_header(constants::header_content_type);
<         blobProperty.etag = http->get_header(constants::header_etag);
<         blobProperty.copy_status = http->get_header(constants::header_ms_copy_status);
<         blobProperty.last_modified = curl_getdate(http->get_header(constants::header_last_modified).c_str(), NULL);
<         std::string::size_type sz = 0;
<         std::string contentLength = http->get_header(constants::header_content_length);
<         if(contentLength.length() > 0)
---
>         if (response.get().success())
250,251c453,468
<             blobProperty.size = std::stoull(contentLength, &sz, 0);
<         }
---
>             blob_property properties(true);
>             properties.cache_control = http->get_response_header(constants::header_cache_control);
>             properties.content_disposition = http->get_response_header(constants::header_content_disposition);
>             properties.content_encoding = http->get_response_header(constants::header_content_encoding);
>             properties.content_language = http->get_response_header(constants::header_content_language);
>             properties.content_md5 = http->get_response_header(constants::header_content_md5);
>             properties.content_type = http->get_response_header(constants::header_content_type);
>             properties.etag = http->get_response_header(constants::header_etag);
>             properties.copy_status = http->get_response_header(constants::header_ms_copy_status);
>             properties.last_modified = curl_getdate(http->get_response_header(constants::header_last_modified).c_str(), NULL);
>             std::string::size_type sz = 0;
>             std::string contentLength = http->get_response_header(constants::header_content_length);
>             if (contentLength.length() > 0)
>             {
>                 properties.size = std::stoull(contentLength, &sz, 0);
>             }
253,256c470,471
<         auto& headers = http->get_headers();
<         for (auto iter = headers.begin(); iter != headers.end(); ++iter)
<         {
<             if (iter->first.find("x-ms-meta-") == 0)
---
>             auto& headers = http->get_response_headers();
>             for (auto iter = headers.begin(); iter != headers.end(); ++iter)
258,259c473,477
<                 // We need to strip ten characters from the front of the key to account for "x-ms-meta-", and two characters from the end of the value, to account for the "\r\n".
<                 blobProperty.metadata.push_back(std::make_pair(iter->first.substr(10), iter->second.substr(0, iter->second.size() - 2)));
---
>                 if (iter->first.find(constants::header_ms_meta_prefix) == 0)
>                 {
>                     // We need to strip ten characters from the front of the key to account for "x-ms-meta-".
>                     properties.metadata.push_back(std::make_pair(iter->first.substr(constants::header_ms_meta_prefix_size), iter->second));
>                 }
260a479
>             return storage_outcome<blob_property>(properties);
262,267c481,495
<     }
<     else
<     {
<         blobProperty.set_valid(false);
<     }
<     return storage_outcome<blob_property>(blobProperty);
---
>         else
>         {
>             return storage_outcome<blob_property>(response.get().error());
>         }
>     });
>     return blob_properties;
> }
> 
> std::future<storage_outcome<void>> blob_client::set_blob_metadata(const std::string &container, const std::string& blob, const std::vector<std::pair<std::string, std::string>>& metadata)
> {
>     auto http = m_client->get_handle();
> 
>     auto request = std::make_shared<set_blob_metadata_request>(container, blob, metadata);
> 
>     return async_executor<void>::submit(m_account, request, http, m_context);
270c498,499
< std::future<storage_outcome<void>> blob_client::upload_block_from_stream(const std::string &container, const std::string &blob, const std::string &blockid, std::istream &is) {
---
> std::future<storage_outcome<void>> blob_client::upload_block_from_stream(const std::string &container, const std::string &blob, const std::string &blockid, std::istream &is)
> {
279,280d507
<     //check < 2^32
<     //std::cout<<"content length: " << end-cur<<std::endl;
288c515,530
< std::future<storage_outcome<void>> blob_client::put_block_list(const std::string &container, const std::string &blob, const std::vector<put_block_list_request_base::block_item> &block_list, const std::vector<std::pair<std::string, std::string>> &metadata) {
---
> std::future<storage_outcome<void>> blob_client::upload_block_from_stream(const std::string &container, const std::string &blob, const std::string &blockid, std::istream &is, uint64_t streamlen)
> {
>     auto http = m_client->get_handle();
> 
>     auto request = std::make_shared<put_block_request>(container, blob, blockid);
>     request->set_content_length(static_cast<unsigned int>(streamlen));
> 
>     http->set_input_stream(storage_istream(is));
>     http->set_is_input_length_known();
>     http->set_input_content_length(streamlen);
> 
>     return async_executor<void>::submit(m_account, request, http, m_context);
> }
> 
> std::future<storage_outcome<void>> blob_client::put_block_list(const std::string &container, const std::string &blob, const std::vector<put_block_list_request_base::block_item> &block_list, const std::vector<std::pair<std::string, std::string>> &metadata)
> {
301c543,544
< std::future<storage_outcome<void>> blob_client::create_append_blob(const std::string &container, const std::string &blob) {
---
> std::future<storage_outcome<void>> blob_client::create_append_blob(const std::string &container, const std::string &blob)
> {
309c552,553
< std::future<storage_outcome<void>> blob_client::append_block_from_stream(const std::string &container, const std::string &blob, std::istream &is) {
---
> std::future<storage_outcome<void>> blob_client::append_block_from_stream(const std::string &container, const std::string &blob, std::istream &is)
> {
318d561
<     //check < 2^32
326c569,570
< std::future<storage_outcome<void>> blob_client::create_page_blob(const std::string &container, const std::string &blob, unsigned long long size) {
---
> std::future<storage_outcome<void>> blob_client::create_page_blob(const std::string &container, const std::string &blob, unsigned long long size)
> {
329d572
<     //check (size % 512 == 0)
335c578,579
< std::future<storage_outcome<void>> blob_client::put_page_from_stream(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, std::istream &is) {
---
> std::future<storage_outcome<void>> blob_client::put_page_from_stream(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size, std::istream &is)
> {
339c583,584
<     if (size > 0) {
---
>     if (size > 0)
>     {
343c588,589
<     else {
---
>     else
>     {
352d597
<     // check stream_size == size || size == 0
360c605,606
< std::future<storage_outcome<void>> blob_client::clear_page(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size) {
---
> std::future<storage_outcome<void>> blob_client::clear_page(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size)
> {
364c610,611
<     if (size > 0) {
---
>     if (size > 0)
>     {
368c615,616
<     else {
---
>     else
>     {
375c623,624
< std::future<storage_outcome<get_page_ranges_response>> blob_client::get_page_ranges(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size) {
---
> std::future<storage_outcome<get_page_ranges_response>> blob_client::get_page_ranges(const std::string &container, const std::string &blob, unsigned long long offset, unsigned long long size)
> {
379c628,629
<     if (size > 0) {
---
>     if (size > 0)
>     {
383c633,634
<     else {
---
>     else
>     {
399,400c650
< }
< }
---
> }}
diff -r azure-storage-cpp-lite-org/src/blob/blob_client_wrapper.cpp cpplite/src/blob/blob_client_wrapper.cpp
4,7c4
< #include <sys/stat.h>
< #include <unistd.h>
< #include <sys/types.h>
< #include <fcntl.h>
---
> 
10c7,10
< #include <uuid/uuid.h>
---
> 
> #ifndef _WIN32
> #include <sys/stat.h>
> #endif
13c13
< #include "base64.h"
---
> #include "logging.h"
14a15,17
> #include "base64.h"
> 
> namespace azure {  namespace storage_lite {
16,17d18
< namespace microsoft_azure {
<     namespace storage {
63,70c64
<         sync_blob_client::~sync_blob_client() {}
< 
<         std::shared_ptr<blob_client_wrapper> blob_client_wrapper_init_accountkey(
<             const std::string &account_name,
<             const std::string &account_key,
<             const unsigned int concurrency,
<             bool use_https,
<             const std::string &blob_endpoint)
---
>         blob_client_wrapper blob_client_wrapper::blob_client_wrapper_init(const std::string &account_name, const std::string &account_key, const std::string &sas_token, const unsigned int concurrency)
72,102c66
<             /* set a default concurrency value. */
<             unsigned int concurrency_limit = 40;
<             if(concurrency != 0)
<             {
<                 concurrency_limit = concurrency;
<             }
<             std::string accountName(account_name);
<             std::string accountKey(account_key);
<             try
<             {
<                 std::shared_ptr<storage_credential> cred;
<                 if (account_key.length() > 0)
<                 {
<                     cred = std::make_shared<shared_key_credential>(accountName, accountKey);
<                 }
<                 else
<                 {
<                     syslog(LOG_ERR, "Empty account key. Failed to create blob client.");
<                     return std::make_shared<blob_client_wrapper>(false);
<                 }
<                 std::shared_ptr<storage_account> account = std::make_shared<storage_account>(accountName, cred, use_https, blob_endpoint);
<                 std::shared_ptr<blob_client> blobClient= std::make_shared<microsoft_azure::storage::blob_client>(account, concurrency_limit);
<                 errno = 0;
<                 return std::make_shared<blob_client_wrapper>(blobClient);
<             }
<             catch(const std::exception &ex)
<             {
<                 syslog(LOG_ERR, "Failed to create blob client.  ex.what() = %s.", ex.what());
<                 errno = unknown_error;
<                 return std::make_shared<blob_client_wrapper>(false);
<             }
---
>             return blob_client_wrapper_init(account_name, account_key, sas_token, concurrency, false, NULL);
106,111c70,71
<         std::shared_ptr<blob_client_wrapper> blob_client_wrapper_init_sastoken(
<             const std::string &account_name,
<             const std::string &sas_token,
<             const unsigned int concurrency,
<             bool use_https,
<             const std::string &blob_endpoint)
---
>         blob_client_wrapper blob_client_wrapper::blob_client_wrapper_init(const std::string &account_name, const std::string &account_key, const std::string &sas_token,  const unsigned int concurrency, const bool use_https, 
>                                                                           const std::string &blob_endpoint)
112a73,78
>             if(account_name.empty() || ((account_key.empty() && sas_token.empty()) || (!account_key.empty() && !sas_token.empty())))
>             {
>                 errno = invalid_parameters;
>                 return blob_client_wrapper(false);
>             }
> 
120c86
<             std::string sasToken(sas_token);
---
>             std::string accountKey(account_key);
124,125c90,91
<                 std::shared_ptr<storage_credential> cred;
<                 if(sas_token.length() > 0)
---
>                 std::shared_ptr<storage_credential>  cred;
>                 if (account_key.length() > 0) 
127c93
<                     cred = std::make_shared<shared_access_signature_credential>(sas_token);
---
>                     cred = std::make_shared<shared_key_credential>(accountName, accountKey);
131,132c97,98
<                     syslog(LOG_ERR, "Empty account key. Failed to create blob client.");
<                     return std::make_shared<blob_client_wrapper>(false);
---
>                     // We have already verified that exactly one form of credentials is present, so if shared key is not present, it must be sas.
>                     cred = std::make_shared<shared_access_signature_credential>(sas_token);
135c101
<                 std::shared_ptr<blob_client> blobClient= std::make_shared<microsoft_azure::storage::blob_client>(account, concurrency_limit);
---
>                 std::shared_ptr<blob_client> blobClient= std::make_shared<azure::storage_lite::blob_client>(account, concurrency_limit);
137c103
<                 return std::make_shared<blob_client_wrapper>(blobClient);
---
>                 return blob_client_wrapper(blobClient);
141c107
<                 syslog(LOG_ERR, "Failed to create blob client.  ex.what() = %s.", ex.what());
---
>                 logger::log(log_level::error, "Failed to create blob client.  ex.what() = %s.", ex.what());
143,177c109
<                 return std::make_shared<blob_client_wrapper>(false);
<             }
<         }
< 
<         std::shared_ptr<blob_client_wrapper> blob_client_wrapper_init_oauth(
<             const std::string &account_name,
<             const unsigned int concurrency,
<             const std::string &blob_endpoint)
<         {
<             /* set a default concurrency value. */
<             unsigned int concurrency_limit = 40;
<             if(concurrency != 0)
<             {
<                 concurrency_limit = concurrency;
<             }
<             std::string accountName(account_name);
< 
<             try
<             {
<                 std::shared_ptr<storage_credential> cred = std::make_shared<token_credential>();
<                 std::shared_ptr<storage_account> account = std::make_shared<storage_account>(
<                     accountName,
<                     cred,
<                     true, //use_https must be true to use oauth
<                     blob_endpoint);
<                 std::shared_ptr<blob_client> blobClient =
<                     std::make_shared<microsoft_azure::storage::blob_client>(account, concurrency_limit);
<                 errno = 0;
<                 return std::make_shared<blob_client_wrapper>(blobClient);
<             }
<             catch(const std::exception &ex)
<             {
<                 syslog(LOG_ERR, "Failed to create blob client.  ex.what() = %s.", ex.what());
<                 errno = unknown_error;
<                 return std::make_shared<blob_client_wrapper>(false);
---
>                 return blob_client_wrapper(false);
213c145
<                 syslog(LOG_ERR, "Unknown failure in create_container.  ex.what() = %s, container = %s.", ex.what(), container.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in create_container.  ex.what() = %s, container = %s.", ex.what(), container.c_str());
248c180
<                 syslog(LOG_ERR, "Unknown failure in delete_container.  ex.what() = %s, container = %s.", ex.what(), container.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in delete_container.  ex.what() = %s, container = %s.", ex.what(), container.c_str());
269c201
<                 auto containerProperty = m_blobClient->get_container_property(container).response();
---
>                 auto containerProperty = m_blobClient->get_container_properties(container).get().response();
278c210
<                     syslog(LOG_ERR, "Unknown failure in container_exists.  No exception, but the container property object is invalid.  errno = %d.", errno);
---
>                     logger::log(log_level::error, "Unknown failure in container_exists.  No exception, but the container property object is invalid.  errno = %d.", errno);
285c217
<                 syslog(LOG_ERR, "Unknown failure in container_exists.  ex.what() = %s, container = %s.", ex.what(), container.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in container_exists.  ex.what() = %s, container = %s.", ex.what(), container.c_str());
291c223
<         std::vector<list_containers_item> blob_client_wrapper::list_containers(const std::string &prefix, const std::string& continuation_token, const int max_result, bool include_metadata)
---
>         std::vector<list_containers_item> blob_client_wrapper::list_containers_segmented(const std::string &prefix, const std::string& continuation_token, const int max_result, bool include_metadata)
298,302d229
<             if(prefix.length() == 0)
<             {
<                 errno = invalid_parameters;
<                 return std::vector<list_containers_item>();
<             }
306c233
<                 auto task = m_blobClient->list_containers(prefix, continuation_token, max_result, include_metadata);
---
>                 auto task = m_blobClient->list_containers_segmented(prefix, continuation_token, max_result, include_metadata);
318c245
<                 syslog(LOG_ERR, "Unknown failure in list_containers.  ex.what() = %s, prefix = %s.", ex.what(), prefix.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in list_containers.  ex.what() = %s, prefix = %s.", ex.what(), prefix.c_str());
324c251
<         list_blobs_hierarchical_response blob_client_wrapper::list_blobs_hierarchical(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix, int max_results)
---
>         list_blobs_segmented_response blob_client_wrapper::list_blobs_segmented(const std::string &container, const std::string &delimiter, const std::string &continuation_token, const std::string &prefix, int max_results)
329c256
<                 return list_blobs_hierarchical_response();
---
>                 return list_blobs_segmented_response();
334c261
<                 return list_blobs_hierarchical_response();
---
>                 return list_blobs_segmented_response();
339,340c266
<                 auto task = m_blobClient->list_blobs_hierarchical(container, delimiter, continuation_token, prefix, max_results);
<                 task.wait();
---
>                 auto task = m_blobClient->list_blobs_segmented(container, delimiter, continuation_token, prefix, max_results);
346,348c272
<                     //std::cout<< "error: " << result.error().code <<std::endl;
<                     //std::cout<< "error: " << result.error().message <<std::endl;
<                     return list_blobs_hierarchical_response();
---
>                     return list_blobs_segmented_response();
358c282
<                 syslog(LOG_ERR, "Unknown failure in list_blobs_hierarchial.  ex.what() = %s, container = %s, prefix = %s.", ex.what(), container.c_str(), prefix.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in list_blobs_hierarchial.  ex.what() = %s, container = %s, prefix = %s.", ex.what(), container.c_str(), prefix.c_str());
360c284
<                 return list_blobs_hierarchical_response();
---
>                 return list_blobs_segmented_response();
385c309
<                 syslog(LOG_ERR, "Failure to open the input stream in put_blob.  ex.what() = %s, sourcePath = %s.", ex.what(), sourcePath.c_str());
---
>                 logger::log(log_level::error, "Failure to open the input stream in put_blob.  ex.what() = %s, sourcePath = %s.", ex.what(), sourcePath.c_str());
389a314
>             int error_code = 0;
396,400c321
<                     errno = std::stoi(result.error().code);
<                 }
<                 else
<                 {
<                     errno = 0;
---
>                     error_code = std::stoi(result.error().code);
405,406c326,327
<                 syslog(LOG_ERR, "Failure to upload the blob in put_blob.  ex.what() = %s, container = %s, blob = %s, sourcePath = %s.", ex.what(), container.c_str(), blob.c_str(), sourcePath.c_str());
<                 errno = unknown_error;
---
>                 logger::log(log_level::error, "Failure to upload the blob in put_blob.  ex.what() = %s, container = %s, blob = %s, sourcePath = %s.", ex.what(), container.c_str(), blob.c_str(), sourcePath.c_str());
>                 error_code = unknown_error;
415,417c336,340
<                 // TODO close failed
<                 syslog(LOG_ERR, "Failure to close the input stream in put_blob.  ex.what() = %s, container = %s, blob = %s, sourcePath = %s.", ex.what(), container.c_str(), blob.c_str(), sourcePath.c_str());
<                 errno = unknown_error;
---
>                 logger::log(log_level::error, "Failure to close the input stream in put_blob.  ex.what() = %s, container = %s, blob = %s, sourcePath = %s.", ex.what(), container.c_str(), blob.c_str(), sourcePath.c_str());
>                 if (error_code == 0)
>                 {
>                     error_code = unknown_error;
>                 }
418a342
>             errno = error_code;
421c345
<         void blob_client_wrapper::upload_block_blob_from_stream(const std::string &container, const std::string blob, std::istream &is, const std::vector<std::pair<std::string, std::string>> &metadata)
---
>         void blob_client_wrapper::upload_block_blob_from_stream(const std::string &container, const std::string blob, std::istream &is, const std::vector<std::pair<std::string, std::string>> &metadata, size_t streamlen)
436c360,364
<                 auto task = m_blobClient->upload_block_blob_from_stream(container, blob, is, metadata);
---
>                 std::future<storage_outcome<void>> task;
>                 if(streamlen == blob_client_wrapper::NOT_USER_DEFINED_STREAMLEN)
>                     task = m_blobClient->upload_block_blob_from_stream(container, blob, is, metadata);
>                 else
>                     task = m_blobClient->upload_block_blob_from_stream(container, blob, is, metadata, streamlen);
452c380
<                 syslog(LOG_ERR, "Unknown failure in upload_block_blob_from_stream.  ex.what() = %s, container = %s, blob = %s", ex.what(), container.c_str(), blob.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in upload_block_blob_from_stream.  ex.what() = %s, container = %s, blob = %s streamlen=%zu.", ex.what(), container.c_str(), blob.c_str(), streamlen);
481c409
<                 return;
---
> 		return;
507c435
<                 syslog(LOG_ERR, "Failed to open the input stream in upload_file_to_blob.  errno = %d, sourcePath = %s.", errno, sourcePath.c_str());
---
>                 logger::log(log_level::error, "Failed to open the input stream in upload_file_to_blob.  errno = %d, sourcePath = %s.", errno, sourcePath.c_str());
532,536c460
<                 long long length = block_size;
<                 if(offset + length > fileSize)
<                 {
<                     length = fileSize - offset;
<                 }
---
>                 size_t length = static_cast<size_t>(std::min(block_size, fileSize - offset));
545c469
<                     syslog(LOG_ERR, "Failed to read from input stream in upload_file_to_blob.  sourcePath = %s, container = %s, blob = %s, offset = %lld, length = %d.", sourcePath.c_str(), container.c_str(), blob.c_str(), offset, (int)length);
---
>                     logger::log(log_level::error, "Failed to read from input stream in upload_file_to_blob.  sourcePath = %s, container = %s, blob = %s, offset = %lld, length = %d.", sourcePath.c_str(), container.c_str(), blob.c_str(), offset, length);
572,574c496
<                         std::istringstream in;
<                         in.rdbuf()->pubsetbuf(buffer, length);
<                         const auto blockResult = m_blobClient->upload_block_from_stream(container, blob, block_id, in).get();
---
>                         const auto blockResult = m_blobClient->upload_block_from_buffer(container, blob, block_id, buffer, length).get();
586d507
<                             // std::cout << blob << " upload failed " << blockResult.error().code << std::endl;
589c510
<                                 // It seems that timeouted requests has no code setup
---
>                                 // It seems that timeout requests has no code setup
607,609d527
<             if (0 != result) {
<                 //std::cout << blob << " request failed " << std::endl;
<             }
616c534
<                     syslog(LOG_ERR, "put_block_list failed in upload_file_to_blob.  error code = %d, sourcePath = %s, container = %s, blob = %s.", result, sourcePath.c_str(), container.c_str(), blob.c_str());
---
>                     logger::log(log_level::error, "put_block_list failed in upload_file_to_blob.  error code = %d, sourcePath = %s, container = %s, blob = %s.", result, sourcePath.c_str(), container.c_str(), blob.c_str());
654d571
<                     syslog(LOG_ERR, "Error while downloading blob container = %s, blob = %s, response status = %s .\n", container.c_str(), blob.c_str(), result.error().message.c_str());
663c580
<                 syslog(LOG_ERR, "Unknown failure in download_blob_to_stream.  ex.what() = %s, container = %s, blob = %s.", ex.what(), container.c_str(), blob.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in download_blob_to_stream.  ex.what() = %s, container = %s, blob = %s.", ex.what(), container.c_str(), blob.c_str());
687c604
<                     syslog(LOG_ERR, "get_chunk_to_stream_async failed for firstchunk in download_blob_to_file.  container = %s, blob = %s, destPath = %s.", container.c_str(), blob.c_str(), destPath.c_str());
---
>                     logger::log(log_level::error, "get_chunk_to_stream_async failed for firstchunk in download_blob_to_file.  container = %s, blob = %s, destPath = %s.", container.c_str(), blob.c_str(), destPath.c_str());
740c657
<                                 syslog(LOG_ERR, "get_chunk_to_stream_async failure in download_blob_to_file.  container = %s, blob = %s, destPath = %s, offset = %llu, range = %llu.", container.c_str(), blob.c_str(), destPath.c_str(), offset, range);
---
>                                 logger::log(log_level::error, "get_chunk_to_stream_async failure in download_blob_to_file.  container = %s, blob = %s, destPath = %s, offset = %llu, range = %llu.", container.c_str(), blob.c_str(), destPath.c_str(), offset, range);
754,755c671
<                     if (0 != result && errcode == 0) 
<                     {
---
>                     if (0 != result && errcode == 0) {
763c679
<                 syslog(LOG_ERR, "Unknown failure in download_blob_to_file.  ex.what() = %s, container = %s, blob = %s, destPath = %s.", ex.what(), container.c_str(), blob.c_str(), destPath.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in download_blob_to_file.  ex.what() = %s, container = %s, blob = %s, destPath = %s.", ex.what(), container.c_str(), blob.c_str(), destPath.c_str());
782c698
<                 auto result = m_blobClient->get_blob_property(container, blob);
---
>                 auto result = m_blobClient->get_blob_properties(container, blob).get();
786d701
<                     syslog(LOG_ERR, "Error getting blob property= %s\n", result.error().message.c_str());
797c712
<                 syslog(LOG_ERR, "Unknown failure in get_blob_property.  ex.what() = %s, container = %s, blob = %s.", ex.what(), container.c_str(), blob.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in get_blob_property.  ex.what() = %s, container = %s, blob = %s.", ex.what(), container.c_str(), blob.c_str());
823c738
<                 syslog(LOG_ERR, "Unknown failure in blob_exists.  ex.what() = %s, container = %s, blob = %s.", ex.what(), container.c_str(), blob.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in blob_exists.  ex.what() = %s, container = %s, blob = %s.", ex.what(), container.c_str(), blob.c_str());
859c774
<                 syslog(LOG_ERR, "Unknown failure in delete_blob.  ex.what() = %s, container = %s, blob = %s.", ex.what(), container.c_str(), blob.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in delete_blob.  ex.what() = %s, container = %s, blob = %s.", ex.what(), container.c_str(), blob.c_str());
897c812
<                 syslog(LOG_ERR, "Unknown failure in start_copy.  ex.what() = %s, sourceContainer = %s, sourceBlob = %s, destContainer = %s, destBlob = %s.", ex.what(), sourceContainer.c_str(), sourceBlob.c_str(), destContainer.c_str(), destBlob.c_str());
---
>                 logger::log(log_level::error, "Unknown failure in start_copy.  ex.what() = %s, sourceContainer = %s, sourceBlob = %s, destContainer = %s, destBlob = %s.", ex.what(), sourceContainer.c_str(), sourceBlob.c_str(), destContainer.c_str(), destBlob.c_str());
903,904c818
<     }
< } // microsoft_azure::storage
---
> }} // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/constants.cpp cpplite/src/constants.cpp
3,5c3
< namespace microsoft_azure {
<     namespace storage {
<         namespace constants {
---
> namespace azure {  namespace storage_lite {  namespace constants {
11,13c9
<         }
<     }
< }
---
> }}}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/copy_blob_request_base.cpp cpplite/src/copy_blob_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,10c8,10
<         void copy_blob_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
---
>     void copy_blob_request_base::build_request(const storage_account &a, http_base &h) const
>     {
>         const auto &r = *this;
12c12
<             h.set_absolute_timeout(5L);
---
>         h.set_absolute_timeout(5L);
14c14
<             h.set_method(http_base::http_method::put);
---
>         h.set_method(http_base::http_method::put);
16,18c16,18
<             // source
<             storage_url source_url = a.get_url(storage_account::service::blob);
<             source_url.append_path(r.container()).append_path(r.blob());
---
>         // source
>         storage_url source_url = a.get_url(storage_account::service::blob);
>         source_url.append_path(r.container()).append_path(r.blob());
20,22c20,22
<             // dest
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.destContainer()).append_path(r.destBlob());
---
>         // dest
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.destContainer()).append_path(r.destBlob());
24,25c24,25
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
---
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
27,29c27,30
<             storage_headers headers;
<             //add_access_condition_headers(h, headers, r);
<             add_content_length(h, headers, 0);
---
>         storage_headers headers;
>         // TODO: support access condition.
>         //add_access_condition_headers(h, headers, r);
>         add_content_length(h, headers, 0);
31c32
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
---
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
33,35c34,36
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
---
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
37,41c38,39
<             // set copy src
<             add_ms_header(h, headers, constants::header_ms_copy_source, a.credential()->transform_url(source_url.get_domain() + source_url.get_path()));
< 
<             a.credential()->sign_request(r, h, url, headers);
<         }
---
>         // set copy src
>         add_ms_header(h, headers, constants::header_ms_copy_source, a.credential()->transform_url(source_url.get_domain() + source_url.get_path()));
42a41
>         a.credential()->sign_request(r, h, url, headers);
44c43,44
< }
---
> 
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/create_container_request_base.cpp cpplite/src/create_container_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,36c8,37
<         void create_container_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
< 
<             h.set_absolute_timeout(5L);
< 
<             h.set_method(http_base::http_method::put);
< 
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.container());
< 
<             url.add_query(constants::query_restype, constants::query_restype_container);
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
< 
<             storage_headers headers;
<             add_content_length(h, headers, 0);
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
< 
<             switch (r.ms_blob_public_access()) {
<             case create_container_request_base::blob_public_access::blob:
<                 add_ms_header(h, headers, constants::header_ms_blob_public_access, constants::header_value_blob_public_access_blob);
<                 break;
<             case create_container_request_base::blob_public_access::container:
<                 add_ms_header(h, headers, constants::header_ms_blob_public_access, constants::header_value_blob_public_access_container);
<                 break;
<             default:
<                 break;
<             }
---
>     void create_container_request_base::build_request(const storage_account &a, http_base &h) const
>     {
>         const auto &r = *this;
> 
>         h.set_absolute_timeout(5L);
> 
>         h.set_method(http_base::http_method::put);
> 
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.container());
> 
>         url.add_query(constants::query_restype, constants::query_restype_container);
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
> 
>         storage_headers headers;
>         add_content_length(h, headers, 0);
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
> 
>         switch (r.ms_blob_public_access())
>         {
>         case create_container_request_base::blob_public_access::blob:
>             add_ms_header(h, headers, constants::header_ms_blob_public_access, constants::header_value_blob_public_access_blob);
>             break;
>         case create_container_request_base::blob_public_access::container:
>             add_ms_header(h, headers, constants::header_ms_blob_public_access, constants::header_value_blob_public_access_container);
>             break;
>         default:
>             break;
>         }
38c39
<             //add ms-meta
---
>         //TODO: add ms-meta
40,45c41,43
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
< 
<             a.credential()->sign_request(r, h, url, headers);
<         }
---
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
46a45
>         a.credential()->sign_request(r, h, url, headers);
48c47,48
< }
---
> 
> }}
diff -r azure-storage-cpp-lite-org/src/delete_blob_request_base.cpp cpplite/src/delete_blob_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure { namespace storage_lite {
9,10c8,9
<         void delete_blob_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
---
>     void delete_blob_request_base::build_request(const storage_account &a, http_base &h) const {
>         const auto &r = *this;
12c11
<             h.set_absolute_timeout(5L);
---
>         h.set_absolute_timeout(5L);
14,44c13
<             h.set_method(http_base::http_method::del);
< 
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.container()).append_path(r.blob());
< 
<             add_optional_query(url, constants::query_snapshot, r.snapshot());
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
< 
<             storage_headers headers;
<             add_access_condition_headers(h, headers, r);
< 
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
<             add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
< 
<             if (r.snapshot().empty()) {
<                 switch (r.ms_delete_snapshots()) {
<                 case delete_blob_request_base::delete_snapshots::only:
<                     add_ms_header(h, headers, constants::header_ms_delete_snapshots, constants::header_value_delete_snapshots_only);
<                     break;
<                 case delete_blob_request_base::delete_snapshots::include:
<                     add_ms_header(h, headers, constants::header_ms_delete_snapshots, constants::header_value_delete_snapshots_include);
<                     break;
<                 default:
<                     break;
<                 }
<             }
< 
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
---
>         h.set_method(http_base::http_method::del);
46c15,40
<             a.credential()->sign_request(r, h, url, headers);
---
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.container()).append_path(r.blob());
> 
>         add_optional_query(url, constants::query_snapshot, r.snapshot());
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
> 
>         storage_headers headers;
>         add_access_condition_headers(h, headers, r);
> 
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
>         add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
> 
>         if (r.snapshot().empty())
>         {
>             switch (r.ms_delete_snapshots())
>             {
>             case delete_blob_request_base::delete_snapshots::only:
>                 add_ms_header(h, headers, constants::header_ms_delete_snapshots, constants::header_value_delete_snapshots_only);
>                 break;
>             case delete_blob_request_base::delete_snapshots::include:
>                 add_ms_header(h, headers, constants::header_ms_delete_snapshots, constants::header_value_delete_snapshots_include);
>                 break;
>             default:
>                 break;
>             }
48a43,47
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
> 
>         a.credential()->sign_request(r, h, url, headers);
50c49,50
< }
---
> 
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/delete_container_request_base.cpp cpplite/src/delete_container_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,10c8,10
<         void delete_container_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
---
>     void delete_container_request_base::build_request(const storage_account &a, http_base &h) const
>     {
>         const auto &r = *this;
12c12
<             h.set_absolute_timeout(5L);
---
>         h.set_absolute_timeout(5L);
14c14
<             h.set_method(http_base::http_method::del);
---
>         h.set_method(http_base::http_method::del);
16,17c16,17
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.container());
---
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.container());
19,21c19,21
<             url.add_query(constants::query_restype, constants::query_restype_container);
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
---
>         url.add_query(constants::query_restype, constants::query_restype_container);
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
23,25c23,25
<             storage_headers headers;
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
<             add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
---
>         storage_headers headers;
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
>         add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
27,32c27,29
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
< 
<             a.credential()->sign_request(r, h, url, headers);
<         }
---
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
33a31
>         a.credential()->sign_request(r, h, url, headers);
35c33,34
< }
---
> 
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/get_blob_property_request_base.cpp cpplite/src/get_blob_property_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,10c8,10
<         void get_blob_property_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
---
>     void get_blob_property_request_base::build_request(const storage_account &a, http_base &h) const
>     {
>         const auto &r = *this;
12c12
<             h.set_absolute_timeout(5L);
---
>         h.set_absolute_timeout(5L);
14c14
<             h.set_method(http_base::http_method::head);
---
>         h.set_method(http_base::http_method::head);
16,17c16,17
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.container()).append_path(r.blob());
---
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.container()).append_path(r.blob());
19,21c19,21
<             add_optional_query(url, constants::query_snapshot, r.snapshot());
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
---
>         add_optional_query(url, constants::query_snapshot, r.snapshot());
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
23c23
<             storage_headers headers;
---
>         storage_headers headers;
25,27c25,27
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
<             // les is not supported.
<             // add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
---
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
>         // lease is not supported.
>         // add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
29,34c29,31
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
< 
<             a.credential()->sign_request(r, h, url, headers);
<         }
---
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
35a33
>         a.credential()->sign_request(r, h, url, headers);
37c35,36
< }
---
> 
> }} // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/get_blob_request_base.cpp cpplite/src/get_blob_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,10c8,10
<         void get_blob_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
---
>     void get_blob_request_base::build_request(const storage_account &a, http_base &h) const
>     {
>         const auto &r = *this;
12c12
<             h.set_data_rate_timeout();
---
>         h.set_data_rate_timeout();
14c14
<             h.set_method(http_base::http_method::get);
---
>         h.set_method(http_base::http_method::get);
16,17c16,17
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.container()).append_path(r.blob());
---
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.container()).append_path(r.blob());
19,21c19,21
<             add_optional_query(url, constants::query_snapshot, r.snapshot());
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
---
>         add_optional_query(url, constants::query_snapshot, r.snapshot());
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
23,24c23,24
<             storage_headers headers;
<             add_access_condition_headers(h, headers, r);
---
>         storage_headers headers;
>         add_access_condition_headers(h, headers, r);
26c26
<             add_optional_header(h, constants::header_origin, r.origin());
---
>         add_optional_header(h, constants::header_origin, r.origin());
28,40c28,34
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
<             add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
<             add_ms_header(h, headers, constants::header_ms_range, get_ms_range(r.start_byte(), r.end_byte()), true);
<             if (r.ms_range_get_content_md5()) {
<                 // TODO check range
<                 add_ms_header(h, headers, constants::header_ms_range_get_content_md5, "true");
<             }
< 
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
< 
<             a.credential()->sign_request(r, h, url, headers);
---
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
>         add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
>         add_ms_header(h, headers, constants::header_ms_range, get_ms_range(r.start_byte(), r.end_byte()), true);
>         if (r.ms_range_get_content_md5())
>         {
>             // TODO check range
>             add_ms_header(h, headers, constants::header_ms_range_get_content_md5, "true");
42a37,41
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
> 
>         a.credential()->sign_request(r, h, url, headers);
44c43,44
< }
---
> 
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/get_block_list_request_base.cpp cpplite/src/get_block_list_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9c8,9
<         void get_block_list_request_base::build_request(const storage_account &a, http_base &h) const {
---
>         void get_block_list_request_base::build_request(const storage_account &a, http_base &h) const
>         {
11a12
>             // TODO: allow setting max execution time.
43c44
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
---
>             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
48,49c49
<     }
< }
---
> }}
diff -r azure-storage-cpp-lite-org/src/get_container_property_request_base.cpp cpplite/src/get_container_property_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,10c8,10
<         void get_container_property_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
---
>     void get_container_property_request_base::build_request(const storage_account &a, http_base &h) const
>     {
>         const auto &r = *this;
12c12
<             h.set_absolute_timeout(5L);
---
>         h.set_absolute_timeout(5L);
14c14
<             h.set_method(http_base::http_method::head);
---
>         h.set_method(http_base::http_method::head);
16,17c16,17
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.container());
---
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.container());
19,21c19,21
<             url.add_query(constants::query_restype, constants::query_restype_container);
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
---
>         url.add_query(constants::query_restype, constants::query_restype_container);
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
23c23
<             storage_headers headers;
---
>         storage_headers headers;
25,27c25,27
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
<             // les is not supported.
<             // add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
---
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
>         // lease is not supported.
>         // add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
29,31c29,31
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
---
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
33,34c33
<             a.credential()->sign_request(r, h, url, headers);
<         }
---
>         a.credential()->sign_request(r, h, url, headers);
36c35
< }
---
> }}
diff -r azure-storage-cpp-lite-org/src/get_page_ranges_request_base.cpp cpplite/src/get_page_ranges_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,10c8,9
<         void get_page_ranges_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
---
>     void get_page_ranges_request_base::build_request(const storage_account &a, http_base &h) const {
>         const auto &r = *this;
12c11
<             h.set_absolute_timeout(30L);
---
>         h.set_absolute_timeout(30L);
14c13
<             h.set_method(http_base::http_method::get);
---
>         h.set_method(http_base::http_method::get);
16,17c15,16
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.container()).append_path(r.blob());
---
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.container()).append_path(r.blob());
19,22c18,21
<             url.add_query(constants::query_comp, constants::query_comp_pagelist);
<             add_optional_query(url, constants::query_snapshot, r.snapshot());
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
---
>         url.add_query(constants::query_comp, constants::query_comp_pagelist);
>         add_optional_query(url, constants::query_snapshot, r.snapshot());
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
24,25c23,24
<             storage_headers headers;
<             add_access_condition_headers(h, headers, r);
---
>         storage_headers headers;
>         add_access_condition_headers(h, headers, r);
27c26
<             add_ms_header(h, headers, constants::header_ms_range, get_ms_range(r.start_byte(), r.end_byte()), true);
---
>         add_ms_header(h, headers, constants::header_ms_range, get_ms_range(r.start_byte(), r.end_byte()), true);
29,30c28,29
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
<             add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
---
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
>         add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
32,37c31,33
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
< 
<             a.credential()->sign_request(r, h, url, headers);
<         }
---
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
38a35
>         a.credential()->sign_request(r, h, url, headers);
40c37,38
< }
---
> 
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/hash.cpp cpplite/src/hash.cpp
2d1
< 
5,9c4,16
< namespace microsoft_azure {
<     namespace storage {
<         std::string hash_impl(const std::string &to_sign, const std::vector<unsigned char> &key) {
<             unsigned int l = SHA256_DIGEST_LENGTH;
<             unsigned char digest[SHA256_DIGEST_LENGTH];
---
> #ifdef WIN32
> #define WIN32_LEAN_AND_MEAN
> #include <Windows.h>
> #include <bcrypt.h>
> #else
> #ifdef USE_OPENSSL
> #include <openssl/hmac.h>
> #else
> #include <gnutls/gnutls.h>
> #include <gnutls/crypto.h>
> #endif
> #endif
> #include <stdexcept>
10a18,44
> namespace azure {  namespace storage_lite {
>     std::string hash(const std::string &to_sign, const std::vector<unsigned char> &key)
>     {
>         unsigned int digest_length = SHA256_DIGEST_LENGTH;
>         unsigned char digest[SHA256_DIGEST_LENGTH];
> #ifdef WIN32
>         static const BCRYPT_ALG_HANDLE hmac_sha256_algorithm_handle = []() {
>             BCRYPT_ALG_HANDLE handle;
>             NTSTATUS status = BCryptOpenAlgorithmProvider(&handle, BCRYPT_SHA256_ALGORITHM, NULL, BCRYPT_ALG_HANDLE_HMAC_FLAG);
>             if (status != 0)
>             {
>                 throw std::runtime_error("Cannot open CNG provider");
>             }
>             return handle;
>         }();
> 
>         DWORD hash_object_size = 0;
>         DWORD output_size = 0;
>         BCryptGetProperty(hmac_sha256_algorithm_handle, BCRYPT_OBJECT_LENGTH, (PUCHAR)&hash_object_size, sizeof(DWORD), &output_size, 0);
> 
>         HANDLE hash_handle;
>         std::vector<char> hash_object(hash_object_size);
>         BCryptCreateHash(hmac_sha256_algorithm_handle, &hash_handle, (PUCHAR)hash_object.data(), hash_object_size, (PUCHAR)key.data(), (ULONG)key.size(), 0);
>         BCryptHashData(hash_handle, (PUCHAR)to_sign.data(), (ULONG)to_sign.length(), 0);
>         BCryptFinishHash(hash_handle, digest, digest_length, 0);
>         BCryptDestroyHash(hash_handle);
> #else
13,18c47,52
<             HMAC_CTX ctx;
<             HMAC_CTX_init(&ctx);
<             HMAC_Init_ex(&ctx, key.data(), static_cast<int>(key.size()), EVP_sha256(), NULL);
<             HMAC_Update(&ctx, (const unsigned char*)to_sign.c_str(), to_sign.size());
<             HMAC_Final(&ctx, digest, &l);
<             HMAC_CTX_cleanup(&ctx);
---
>         HMAC_CTX ctx;
>         HMAC_CTX_init(&ctx);
>         HMAC_Init_ex(&ctx, key.data(), static_cast<int>(key.size()), EVP_sha256(), NULL);
>         HMAC_Update(&ctx, (const unsigned char*)to_sign.c_str(), to_sign.size());
>         HMAC_Final(&ctx, digest, &digest_length);
>         HMAC_CTX_cleanup(&ctx);
20,25c54,59
<             HMAC_CTX * ctx = HMAC_CTX_new();
<             HMAC_CTX_reset(ctx);
<             HMAC_Init_ex(ctx, key.data(), key.size(), EVP_sha256(), NULL);
<             HMAC_Update(ctx, (const unsigned char*)to_sign.c_str(), to_sign.size());
<             HMAC_Final(ctx, digest, &l);
<             HMAC_CTX_free(ctx);
---
>         HMAC_CTX * ctx = HMAC_CTX_new();
>         HMAC_CTX_reset(ctx);
>         HMAC_Init_ex(ctx, key.data(), static_cast<int>(key.size()), EVP_sha256(), NULL);
>         HMAC_Update(ctx, (const unsigned char*)to_sign.c_str(), to_sign.size());
>         HMAC_Final(ctx, digest, &digest_length);
>         HMAC_CTX_free(ctx);
28,29c62
<             gnutls_hmac_fast(GNUTLS_MAC_SHA256, key.data(), key.size(), (const unsigned char *) to_sign.data(),
<                              to_sign.size(), digest);
---
>         gnutls_hmac_fast(GNUTLS_MAC_SHA256, key.data(), key.size(), (const unsigned char *)to_sign.data(), to_sign.size(), digest);
31,33c64,65
< 
<             return to_base64(std::vector<unsigned char>(digest, digest + l));
<         }
---
> #endif
>         return to_base64(std::vector<unsigned char>(digest, digest + digest_length));
35c67
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/http/libcurl_http_client.cpp cpplite/src/http/libcurl_http_client.cpp
7,22c7
< namespace microsoft_azure {
<     namespace storage {
< 
<         std::string to_lower(std::string original) {
<             std::string out;
< 
<             for (auto idx = original.begin(); idx < original.end(); idx++) {
<                 if(*idx >= 'A' && *idx <= 'Z') {
<                     out += char(*idx + 32); // This cast isn't required, but clang-tidy wants to complain without it.
<                 } else {
<                     out += *idx;
<                 }
<             }
< 
<             return out;
<         }
---
> namespace azure { namespace storage_lite {
25,27c10
<         : m_client(client),
<             m_curl(h),
<             m_slist(NULL)
---
>             : m_client(client), m_curl(h), m_slist(NULL)
29,30d11
<             m_input_content_length=0;
<             m_is_input_length_known =false;
35c16,17
<         CurlEasyRequest::~CurlEasyRequest() {
---
>         CurlEasyRequest::~CurlEasyRequest()
>         {
43,44c25,28
<         CURLcode CurlEasyRequest::perform() {
<             if (m_output_stream.valid()) {
---
>         CURLcode CurlEasyRequest::perform()
>         {
>             if (m_output_stream.valid())
>             {
49c33,34
<             switch (m_method) {
---
>             switch (m_method)
>             {
51c36
<                 check_code(curl_easy_setopt(m_curl, CURLOPT_HTTPGET, 1));
---
>                 check_code(curl_easy_setopt(m_curl, CURLOPT_HTTPGET, 1L));
54c39
<                 check_code(curl_easy_setopt(m_curl, CURLOPT_UPLOAD, 1));
---
>                 check_code(curl_easy_setopt(m_curl, CURLOPT_UPLOAD, 1L));
65a51,54
>             case http_method::patch:
>                 check_code(curl_easy_setopt(m_curl, CURLOPT_UPLOAD, 1L));
>                 check_code(curl_easy_setopt(m_curl, CURLOPT_CUSTOMREQUEST, constants::http_patch));
>                 break;
73a63,72
>             if (!m_client->get_capath().empty())
>             {
>                 check_code(curl_easy_setopt(m_curl, CURLOPT_CAINFO, m_client->get_capath().data()));
>             }
> 
>             if (!m_client->get_proxy().empty())
>             {
>                 check_code(curl_easy_setopt(m_curl, CURLOPT_PROXY, m_client->get_proxy().data()));
>             }
> 
79c78,79
<         size_t CurlEasyRequest::header_callback(char *buffer, size_t size, size_t nitems, void *userdata) {
---
>         size_t CurlEasyRequest::header_callback(char *buffer, size_t size, size_t nitems, void *userdata)
>         {
81a82,89
>             if (!header.empty() && header.back() == '\n')
>             {
>                 header.pop_back();
>             }
>             if (!header.empty() && header.back() == '\r')
>             {
>                 header.pop_back();
>             }
95c103
<                 p->m_headers[header.substr(0, colon)] = header.substr(colon + 2);
---
>                 p->m_response_headers[header.substr(0, colon)] = header.substr(colon + 2);
100,101c108
<     }
< }
---
> }} // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/list_blobs_request_base.cpp cpplite/src/list_blobs_request_base.cpp
6,7c6
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
9c8,9
< void list_blobs_request_base::build_request(const storage_account &a, http_base &h) const {
---
> void list_blobs_request_base::build_request(const storage_account &a, http_base &h) const
> {
26c26,27
<     if (r.includes() & list_blobs_request_base::include::snapshots) {
---
>     if (r.includes() & list_blobs_request_base::include::snapshots)
>     {
29c30,31
<     if (r.includes() & list_blobs_request_base::include::metadata) {
---
>     if (r.includes() & list_blobs_request_base::include::metadata)
>     {
32c34,35
<     if (r.includes() & list_blobs_request_base::include::uncommittedblobs) {
---
>     if (r.includes() & list_blobs_request_base::include::uncommittedblobs)
>     {
35c38,39
<     if (r.includes() & list_blobs_request_base::include::copy) {
---
>     if (r.includes() & list_blobs_request_base::include::copy)
>     {
47c51
<     add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
---
>     add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
52c56,57
< void list_blobs_hierarchical_request_base::build_request(const storage_account &a, http_base &h) const {
---
> void list_blobs_segmented_request_base::build_request(const storage_account &a, http_base &h) const
> {
81c86,87
<     if (r.includes() & list_blobs_request_base::include::snapshots) {
---
>     if (r.includes() & list_blobs_request_base::include::snapshots)
>     {
84c90,91
<     if (r.includes() & list_blobs_request_base::include::metadata) {
---
>     if (r.includes() & list_blobs_request_base::include::metadata)
>     {
87c94,95
<     if (r.includes() & list_blobs_request_base::include::uncommittedblobs) {
---
>     if (r.includes() & list_blobs_request_base::include::uncommittedblobs)
>     {
90c98,99
<     if (r.includes() & list_blobs_request_base::include::copy) {
---
>     if (r.includes() & list_blobs_request_base::include::copy)
>     {
102c111
<     add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
---
>     add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
106,107c115
< }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/list_containers_request_base.cpp cpplite/src/list_containers_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,10c8,10
<         void list_containers_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
---
>     void list_containers_request_base::build_request(const storage_account &a, http_base &h) const
>     {
>         const auto &r = *this;
12,34c12
<             h.set_absolute_timeout(30L);
<             
<             h.set_method(http_base::http_method::get);
< 
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path("");
< 
<             url.add_query(constants::query_comp, constants::query_comp_list);
<             add_optional_query(url, constants::query_prefix, r.prefix());
<             add_optional_query(url, constants::query_marker, r.marker());
<             add_optional_query(url, constants::query_maxresults, r.maxresults());
<             if (r.include_metadata()) {
<                 url.add_query(constants::query_include, constants::query_include_metadata);
<             }
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
< 
<             storage_headers headers;
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
< 
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
---
>         h.set_absolute_timeout(30L);
36c14,24
<             a.credential()->sign_request(r, h, url, headers);
---
>         h.set_method(http_base::http_method::get);
> 
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path("");
> 
>         url.add_query(constants::query_comp, constants::query_comp_list);
>         add_optional_query(url, constants::query_prefix, r.prefix());
>         add_optional_query(url, constants::query_marker, r.marker());
>         add_optional_query(url, constants::query_maxresults, r.maxresults());
>         if (r.include_metadata()) {
>             url.add_query(constants::query_include, constants::query_include_metadata);
37a26,30
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
> 
>         storage_headers headers;
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
38a32,36
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
> 
>         a.credential()->sign_request(r, h, url, headers);
40c38,39
< }
---
> 
> }}  // azure::storage_lite
Only in cpplite/src: logging.cpp
diff -r azure-storage-cpp-lite-org/src/put_blob_request_base.cpp cpplite/src/put_blob_request_base.cpp
6,7c6
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
9c8,9
< void put_blob_request_base::build_request(const storage_account &a, http_base &h) const {
---
> void put_blob_request_base::build_request(const storage_account &a, http_base &h) const
> {
40,41c40,41
<     if (r.ms_blob_type() == put_blob_request_base::blob_type::page_blob) {
<         // check % 512
---
>     if (r.ms_blob_type() == put_blob_request_base::blob_type::page_blob)
>     {
46c46,47
<     if (r.ms_blob_type() == put_blob_request_base::blob_type::page_blob) {
---
>     if (r.ms_blob_type() == put_blob_request_base::blob_type::page_blob)
>     {
73c74
<     add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
---
>     add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
78,79c79
< }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/put_block_list_request_base.cpp cpplite/src/put_block_list_request_base.cpp
8,9c8
< namespace microsoft_azure {
< namespace storage {
---
> namespace azure {  namespace storage_lite {
11c10,11
< void put_block_list_request_base::build_request(const storage_account &a, http_base &h) const {
---
> void put_block_list_request_base::build_request(const storage_account &a, http_base &h) const
> {
55c55
<     add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
---
>     add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
60,61c60
< }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/put_block_request_base.cpp cpplite/src/put_block_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,10c8,10
<         void put_block_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
---
>     void put_block_request_base::build_request(const storage_account &a, http_base &h) const
>     {
>         const auto &r = *this;
12c12
<             h.set_data_rate_timeout();
---
>         h.set_data_rate_timeout();
14c14
<             h.set_method(http_base::http_method::put);
---
>         h.set_method(http_base::http_method::put);
16,17c16,17
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.container()).append_path(r.blob());
---
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.container()).append_path(r.blob());
19,22c19,22
<             url.add_query(constants::query_comp, constants::query_comp_block);
<             url.add_query(constants::query_blockid, r.blockid());
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
---
>         url.add_query(constants::query_comp, constants::query_comp_block);
>         url.add_query(constants::query_blockid, r.blockid());
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
24,27c24,25
<             storage_headers headers;
<             add_content_length(h, headers, r.content_length());
<             //add_optional_content_md5(h, headers, r.content_md5());
<             // add_access_condition_headers(h, headers, r);
---
>         storage_headers headers;
>         add_content_length(h, headers, r.content_length());
29,30c27
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
<             // add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
---
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
32,37c29,31
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
< 
<             a.credential()->sign_request(r, h, url, headers);
<         }
---
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
38a33
>         a.credential()->sign_request(r, h, url, headers);
40c35,36
< }
---
> 
> }}
diff -r azure-storage-cpp-lite-org/src/put_page_request_base.cpp cpplite/src/put_page_request_base.cpp
6,7c6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
9,50c8,37
<         void put_page_request_base::build_request(const storage_account &a, http_base &h) const {
<             const auto &r = *this;
< 
<             h.set_data_rate_timeout();
< 
<             h.set_method(http_base::http_method::put);
< 
<             storage_url url = a.get_url(storage_account::service::blob);
<             url.append_path(r.container()).append_path(r.blob());
< 
<             url.add_query(constants::query_comp, constants::query_comp_page);
<             add_optional_query(url, constants::query_timeout, r.timeout());
<             h.set_url(url.to_string());
< 
<             storage_headers headers;
<             add_content_length(h, headers, r.content_length());
<             add_optional_content_md5(h, headers, r.content_md5());
<             add_access_condition_headers(h, headers, r);
< 
<             add_ms_header(h, headers, constants::header_ms_range, get_ms_range(r.start_byte(), r.end_byte()), true);
< 
<             switch (r.ms_page_write()) {
<             case put_page_request_base::page_write::update:
<                 add_ms_header(h, headers, constants::header_ms_page_write, constants::header_value_page_write_update);
<                 break;
<             case put_page_request_base::page_write::clear:
<                 add_ms_header(h, headers, constants::header_ms_page_write, constants::header_value_page_write_clear);
<                 break;
<             }
< 
<             add_ms_header(h, headers, constants::header_ms_if_sequence_number_lt, r.ms_if_sequence_number_lt(), true);
<             add_ms_header(h, headers, constants::header_ms_if_sequence_number_le, r.ms_if_sequence_number_le(), true);
<             add_ms_header(h, headers, constants::header_ms_if_sequence_number_eq, r.ms_if_sequence_number_eq(), true);
< 
<             add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
<             add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
< 
<             h.add_header(constants::header_user_agent, constants::header_value_user_agent);
<             add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
<             add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_version);
< 
<             a.credential()->sign_request(r, h, url, headers);
---
>     void put_page_request_base::build_request(const storage_account &a, http_base &h) const
>     {
>         const auto &r = *this;
> 
>         h.set_data_rate_timeout();
> 
>         h.set_method(http_base::http_method::put);
> 
>         storage_url url = a.get_url(storage_account::service::blob);
>         url.append_path(r.container()).append_path(r.blob());
> 
>         url.add_query(constants::query_comp, constants::query_comp_page);
>         add_optional_query(url, constants::query_timeout, r.timeout());
>         h.set_url(url.to_string());
> 
>         storage_headers headers;
>         add_content_length(h, headers, r.content_length());
>         add_optional_content_md5(h, headers, r.content_md5());
>         add_access_condition_headers(h, headers, r);
> 
>         add_ms_header(h, headers, constants::header_ms_range, get_ms_range(r.start_byte(), r.end_byte()), true);
> 
>         switch (r.ms_page_write())
>         {
>         case put_page_request_base::page_write::update:
>             add_ms_header(h, headers, constants::header_ms_page_write, constants::header_value_page_write_update);
>             break;
>         case put_page_request_base::page_write::clear:
>             add_ms_header(h, headers, constants::header_ms_page_write, constants::header_value_page_write_clear);
>             break;
52a40,51
>         add_ms_header(h, headers, constants::header_ms_if_sequence_number_lt, r.ms_if_sequence_number_lt(), true);
>         add_ms_header(h, headers, constants::header_ms_if_sequence_number_le, r.ms_if_sequence_number_le(), true);
>         add_ms_header(h, headers, constants::header_ms_if_sequence_number_eq, r.ms_if_sequence_number_eq(), true);
> 
>         add_ms_header(h, headers, constants::header_ms_client_request_id, r.ms_client_request_id(), true);
>         add_ms_header(h, headers, constants::header_ms_lease_id, r.ms_lease_id(), true);
> 
>         h.add_header(constants::header_user_agent, constants::header_value_user_agent);
>         add_ms_header(h, headers, constants::header_ms_date, get_ms_date(date_format::rfc_1123));
>         add_ms_header(h, headers, constants::header_ms_version, constants::header_value_storage_blob_version);
> 
>         a.credential()->sign_request(r, h, url, headers);
54c53,54
< }
---
> 
> }}  // azure::storage_lite
Only in cpplite/src: set_blob_metadata_request_base.cpp
Only in cpplite/src: set_container_metadata_request_base.cpp
diff -r azure-storage-cpp-lite-org/src/storage_account.cpp cpplite/src/storage_account.cpp
5,6c5,6
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
> 
16,33c16,20
<         // TODO: Clean up table queue and file services
<         storage_account::storage_account(const std::string &account_name, std::shared_ptr<storage_credential> credential, bool use_https, const std::string &blob_endpoint)
<             : m_credential(credential) {
<             if (use_https) {
<                 append_all("https://");
<             }
<             else {
<                 append_all("http://");
<             }
< 
<             if(blob_endpoint.empty())
<             {
<                 append_all(account_name);
< 
<                 m_blob_domain.append(".blob");
<                 m_table_domain.append(".table");
<                 m_queue_domain.append(".queue");
<                 m_file_domain.append(".file");
---
>     // TODO: Clean up table queue and file services
>     storage_account::storage_account(const std::string &account_name, std::shared_ptr<storage_credential> credential, bool use_https, const std::string &blob_endpoint)
>         : m_credential(credential)
>     {
>         std::string scheme = use_https ? "https://" : "http://";
35,37c22,36
<                 append_all(constants::default_endpoint_suffix);
<             }
<             else
---
>         if (blob_endpoint.empty())
>         {
>             std::string domain = scheme + account_name;
> 
>             m_blob_url.set_domain(domain + ".blob" + constants::default_endpoint_suffix);
>             m_table_url.set_domain(domain + ".table" + constants::default_endpoint_suffix);
>             m_queue_url.set_domain(domain + ".queue" + constants::default_endpoint_suffix);
>             m_file_url.set_domain(domain + ".file" + constants::default_endpoint_suffix);
>             m_adls_url.set_domain(domain + ".dfs" + constants::default_endpoint_suffix);
>         }
>         else
>         {
>             std::string endpoint = blob_endpoint;
>             auto scheme_pos = endpoint.find("://");
>             if (scheme_pos != std::string::npos)
39c38
<                 append_all(blob_endpoint);
---
>                 endpoint = endpoint.substr(scheme_pos + 3);
41d39
<         }
43,58c41,42
<         AZURE_STORAGE_API storage_url storage_account::get_url(service service) const {
<             storage_url url;
<             switch (service) {
<             case storage_account::service::blob:
<                 url.set_domain(m_blob_domain);
<                 break;
<             case storage_account::service::table:
<                 url.set_domain(m_table_domain);
<                 break;
<             case storage_account::service::queue:
<                 url.set_domain(m_queue_domain);
<                 break;
<             case storage_account::service::file:
<                 url.set_domain(m_file_domain);
<                 break;
<             }
---
>             auto slash_pos = endpoint.find('/');
>             std::string host = endpoint.substr(0, slash_pos);
60,61c44,45
<             return url;
<         }
---
>             auto path_start = endpoint.find_first_not_of('/', slash_pos);
>             std::string path = path_start == std::string::npos ? "" : endpoint.substr(path_start);
63,67c47,60
<         AZURE_STORAGE_API void storage_account::append_all(const std::string &part) {
<             m_blob_domain.append(part);
<             m_table_domain.append(part);
<             m_queue_domain.append(part);
<             m_file_domain.append(part);
---
>             std::string domain = scheme + host;
>             m_blob_url.set_domain(domain);
>             m_table_url.set_domain(domain);
>             m_queue_url.set_domain(domain);
>             m_file_url.set_domain(domain);
>             m_adls_url.set_domain(domain);
> 
>             if (!path.empty()) {
>                 m_blob_url.append_path(path);
>                 m_table_url.append_path(path);
>                 m_queue_url.append_path(path);
>                 m_file_url.append_path(path);
>                 m_adls_url.append_path(path);
>             }
69d61
< 
71c63,64
< }
---
> 
> }}
diff -r azure-storage-cpp-lite-org/src/storage_credential.cpp cpplite/src/storage_credential.cpp
3d2
< #include "hash.h"
5a5
> #include "hash.h"
8,9c8
< namespace microsoft_azure {
<     namespace storage {
---
> namespace azure {  namespace storage_lite {
11,23c10,38
<         shared_key_credential::shared_key_credential(const std::string &account_name, const std::string &account_key)
<             : m_account_name(account_name),
<             m_account_key(from_base64(account_key)) {}
< 
<         shared_key_credential::shared_key_credential(const std::string &account_name, const std::vector<unsigned char> &account_key)
<             : m_account_name(account_name),
<             m_account_key(account_key) {}
< 
<         void shared_key_credential::sign_request(
<                 const storage_request_base &,
<                 http_base &h,
<                 const storage_url &url,
<                 const storage_headers &headers) const
---
>     shared_key_credential::shared_key_credential(const std::string &account_name, const std::string &account_key)
>         : m_account_name(account_name),
>         m_account_key(from_base64(account_key)) {}
> 
>     shared_key_credential::shared_key_credential(const std::string &account_name, const std::vector<unsigned char> &account_key)
>         : m_account_name(account_name),
>         m_account_key(account_key) {}
> 
>     void shared_key_credential::sign_request(const storage_request_base &, http_base &h, const storage_url &url, const storage_headers &headers) const
>     {
>         std::string string_to_sign(get_http_verb(h.get_method()));
>         string_to_sign.append("\n");
> 
>         string_to_sign.append(headers.content_encoding).append("\n");
>         string_to_sign.append(headers.content_language).append("\n");
>         string_to_sign.append(headers.content_length).append("\n");
>         string_to_sign.append(headers.content_md5).append("\n");
>         string_to_sign.append(headers.content_type).append("\n");
>         // TODO: add date to string_to_sign when date is supported.
>         string_to_sign.append("\n"); // Date
>         string_to_sign.append(headers.if_modified_since).append("\n");
>         string_to_sign.append(headers.if_match).append("\n");
>         string_to_sign.append(headers.if_none_match).append("\n");
>         string_to_sign.append(headers.if_unmodified_since).append("\n");
>         string_to_sign.append("\n"); // Range
> 
>         // Canonicalized headers
>         std::map<std::string, std::string> ordered_ms_headers;
>         for (const auto& header : headers.ms_headers)
25,44c40,45
<             std::string string_to_sign(get_http_verb(h.get_method()));
<             string_to_sign.append("\n");
< 
<             string_to_sign.append(headers.content_encoding).append("\n");
<             string_to_sign.append(headers.content_language).append("\n");
<             string_to_sign.append(headers.content_length).append("\n");
<             string_to_sign.append(headers.content_md5).append("\n");
<             string_to_sign.append(headers.content_type).append("\n");
<             string_to_sign.append("\n"); // Date
<             string_to_sign.append(headers.if_modified_since).append("\n");
<             string_to_sign.append(headers.if_match).append("\n");
<             string_to_sign.append(headers.if_none_match).append("\n");
<             string_to_sign.append(headers.if_unmodified_since).append("\n");
<             string_to_sign.append("\n"); // Range
< 
<             // Canonicalized headers
<             for (const auto &header : headers.ms_headers)
<             {
<                 string_to_sign.append(header.first).append(":").append(header.second).append("\n");
<             }
---
>             ordered_ms_headers.emplace(to_lowercase(header.first), header.second);
>         }
>         for (const auto &header : ordered_ms_headers)
>         {
>             string_to_sign.append(header.first).append(":").append(header.second).append("\n");
>         }
46,63c47,55
<             // Canonicalized resource
<             string_to_sign.append("/").append(m_account_name).append(url.get_encoded_path());
<             for (const auto &name : url.get_query())
<             {
<                 string_to_sign.append("\n").append(name.first);
<                 bool first_value = true;
<                 for (const auto &value : name.second)
<                 {
<                     if (first_value)
<                     {
<                         string_to_sign.append(":");
<                         first_value = false;
<                     }
<                     else
<                         {
<                         string_to_sign.append(",");
<                     }
<                     string_to_sign.append(value);
---
>         // Canonicalized resource
>         string_to_sign.append("/").append(m_account_name).append(url.get_encoded_path());
>         for (const auto &name : url.get_query()) {
>             string_to_sign.append("\n").append(to_lowercase(name.first));
>             bool first_value = true;
>             for (const auto &value : name.second) {
>                 if (first_value) {
>                     string_to_sign.append(":");
>                     first_value = false;
64a57,60
>                 else {
>                     string_to_sign.append(",");
>                 }
>                 string_to_sign.append(value);
66,69d61
< 
<             std::string authorization("SharedKey ");
<             authorization.append(m_account_name).append(":").append(hash_impl(string_to_sign, m_account_key));
<             h.add_header(constants::header_authorization, authorization);
72,75c64,67
<         void shared_key_credential::sign_request(const table_request_base &,
<                 http_base &,
<                 const storage_url &,
<                 const storage_headers &) const {}
---
>         std::string authorization("SharedKey ");
>         authorization.append(m_account_name).append(":").append(hash(string_to_sign, m_account_key));
>         h.add_header(constants::header_authorization, authorization);
>     }
77,87c69
<         std::string shared_access_signature_credential::transform_url(std::string url) const
<         {
<             if (url.find('?') != std::string::npos) {
<                 url.append("&");
<             }
<             else {
<                 url.append("?");
<             }
<             url.append(m_sas_token);
<             return url;
<         }
---
>     void shared_key_credential::sign_request(const table_request_base &, http_base &, const storage_url &, const storage_headers &) const {}
89,95c71,74
<         void shared_access_signature_credential::sign_request(const storage_request_base &,
<                 http_base &h,
<                 const storage_url &,
<                 const storage_headers &) const
<         {
<             std::string transformed_url = transform_url(h.get_url());
<             h.set_url(transformed_url);
---
>     std::string shared_access_signature_credential::transform_url(std::string url) const
>     {
>         if (url.find('?') != std::string::npos) {
>             url.append("&");
97,99c76,77
< 
<         AZURE_STORAGE_API token_credential::token_credential(){
<             m_credmgr_ptr = GetTokenManagerInstance(EmptyCallback);
---
>         else {
>             url.append("?");
100a79,81
>         url.append(m_sas_token);
>         return url;
>     }
102,110c83,87
<         AZURE_STORAGE_API token_credential::token_credential(const std::string &token) : m_token(std::move(token)) {}
< 
<         void token_credential::sign_request(const microsoft_azure::storage::storage_request_base &,
<                                             microsoft_azure::storage::http_base & h,
<                                             const microsoft_azure::storage::storage_url &,
<                                             const microsoft_azure::storage::storage_headers &) const
<         {
<             // a token mutex is no longer needeed as the oauth token manager handles this for us.
<             std::string authorization("Bearer ");
---
>     void shared_access_signature_credential::sign_request(const storage_request_base &, http_base &h, const storage_url &, const storage_headers &) const
>     {
>         std::string transformed_url = transform_url(h.get_url());
>         h.set_url(transformed_url);
>     }
112,121c89,90
<             if (m_token.empty())
<             {
<                 OAuthToken token = m_credmgr_ptr->get_token();
<                 authorization.append(token.access_token);
<             }
<             else // deprecated fallback case for explicitly set token
<             {
<                 std::lock_guard<std::mutex> lg(m_token_mutex);
<                 authorization.append(m_token);
<             }
---
>     AZURE_STORAGE_API token_credential::token_credential(const std::string &token)
>         : m_token(std::move(token)) {}
123,124c92,95
<             h.add_header(constants::header_authorization, authorization);
<         }
---
>     void token_credential::set_token(const std::string& token) {
>         std::lock_guard<std::mutex> lg(m_token_mutex);
>         m_token = token;
>     }
126,129c97,101
<         void token_credential::set_token(const std::string &token) {
<             std::lock_guard<std::mutex> lg(m_token_mutex);
<             m_token = token;
<         }
---
>     void token_credential::sign_request(const storage_request_base &, http_base &h, const storage_url &, const storage_headers &) const {
>         std::lock_guard<std::mutex> lg(m_token_mutex);
>         std::string authorization("Bearer ");
>         authorization.append(m_token);
>         h.add_header(constants::header_authorization, authorization);
131c103
< }
---
> }}   // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/storage_url.cpp cpplite/src/storage_url.cpp
1,2d0
< #include <ctime>
< 
3a2
> #include "utility.h"
5c4
< #include "constants.h"
---
> namespace azure {  namespace storage_lite {
7,19c6,9
< #ifdef _WIN32
< #define WIN32_LEAN_AND_MEAN
< #include <Windows.h>
< #else
< #include <uuid/uuid.h>
< #include <sys/stat.h>
< #include <sys/types.h>
< #include <fcntl.h>
< #include <unistd.h>
< #endif
< #include <cctype>
< #include <vector>
< #include <algorithm>
---
>     std::string storage_url::get_encoded_path() const
>     {
>         return encode_url_path(m_path);
>     }
21,23c11
< namespace microsoft_azure 
< {
<     namespace storage 
---
>     std::string storage_url::to_string() const
25,28c13,14
<         bool is_alnum(char ch)        
<         {
<             return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');
<         }
---
>         std::string url(m_domain);
>         url.append(encode_url_path(m_path));
30c16,17
<         bool is_unreserved(char ch)
---
>         bool first_query = true;
>         for (const auto &q : m_query)
32,36c19
<             return is_alnum(ch) || ch == '-' || ch == '.' || ch == '_' || ch == '~';
<         }
<         bool is_sub_delim(char ch)
<         {
<             switch(ch)
---
>             if (first_query)
38,51c21,22
<             case '!':
<             case '$':
<             case '&':
<             case '\'':
<             case '(':
<             case ')':
<             case '*':
<             case '+':
<             case ',':
<             case ';':
<             case '=':
<                 return true;
<             default:
<                 return false;
---
>                 url.append("?");
>                 first_query = false;
53,88c24
<         }
< 
<         bool is_path_character(char ch)
<         {
<             return is_unreserved(ch) || is_sub_delim(ch) || ch == '%' || ch == '/' || ch == ':' || ch == '@';
<         }
<         
<         bool is_query_character(char ch)
<         {
<             return is_path_character(ch) || ch == '?';
<         }
< 
<         static const char* unreserved = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
<         static const char* subdelimiters = "!$&'()*+,;=";
<         static const char* encoded_chars[] = {
<         "%00", "%01", "%02", "%03", "%04", "%05", "%06", "%07", "%08", "%09", "%0A", "%0B", "%0C", "%0D", "%0E", "%0F",
<         "%10", "%11", "%12", "%13", "%14", "%15", "%16", "%17", "%18", "%19", "%1A", "%1B", "%1C", "%1D", "%1E", "%1F",
<         "%20", "%21", "%22", "%23", "%24", "%25", "%26", "%27", "%28", "%29", "%2A", "%2B", "%2C", "%2D", "%2E", "%2F",
<         "%30", "%31", "%32", "%33", "%34", "%35", "%36", "%37", "%38", "%39", "%3A", "%3B", "%3C", "%3D", "%3E", "%3F",
<         "%40", "%41", "%42", "%43", "%44", "%45", "%46", "%47", "%48", "%49", "%4A", "%4B", "%4C", "%4D", "%4E", "%4F",
<         "%50", "%51", "%52", "%53", "%54", "%55", "%56", "%57", "%58", "%59", "%5A", "%5B", "%5C", "%5D", "%5E", "%5F",
<         "%60", "%61", "%62", "%63", "%64", "%65", "%66", "%67", "%68", "%69", "%6A", "%6B", "%6C", "%6D", "%6E", "%6F",
<         "%70", "%71", "%72", "%73", "%74", "%75", "%76", "%77", "%78", "%79", "%7A", "%7B", "%7C", "%7D", "%7E", "%7F",
<         "%80", "%81", "%82", "%83", "%84", "%85", "%86", "%87", "%88", "%89", "%8A", "%8B", "%8C", "%8D", "%8E", "%8F",
<         "%90", "%91", "%92", "%93", "%94", "%95", "%96", "%97", "%98", "%99", "%9A", "%9B", "%9C", "%9D", "%9E", "%9F",
<         "%A0", "%A1", "%A2", "%A3", "%A4", "%A5", "%A6", "%A7", "%A8", "%A9", "%AA", "%AB", "%AC", "%AD", "%AE", "%AF",
<         "%B0", "%B1", "%B2", "%B3", "%B4", "%B5", "%B6", "%B7", "%B8", "%B9", "%BA", "%BB", "%BC", "%BD", "%BE", "%BF",
<         "%C0", "%C1", "%C2", "%C3", "%C4", "%C5", "%C6", "%C7", "%C8", "%C9", "%CA", "%CB", "%CC", "%CD", "%CE", "%CF",
<         "%D0", "%D1", "%D2", "%D3", "%D4", "%D5", "%D6", "%D7", "%D8", "%D9", "%DA", "%DB", "%DC", "%DD", "%DE", "%DF",
<         "%E0", "%E1", "%E2", "%E3", "%E4", "%E5", "%E6", "%E7", "%E8", "%E9", "%EA", "%EB", "%EC", "%ED", "%EE", "%EF",
<         "%F0", "%F1", "%F2", "%F3", "%F4", "%F5", "%F6", "%F7", "%F8", "%F9", "%FA", "%FB", "%FC", "%FD", "%FE", "%FF"
<         };
< 
<         std::string encode_url_path(const std::string& path)
<         {
<             static const std::vector<uint8_t> is_path_char = []()
---
>             else
90,110c26
<                 std::vector<uint8_t> ret(256, 0);
<                 for (char c : std::string(unreserved) + std::string(subdelimiters) + "%!@")
<                 {
<                     ret[c] = 1;
<                 }
<                 // Parameter path is already joint with '/'.
<                 ret['/'] = 1;
<                 return ret;
<             }();
< 
<             std::string result;
<             for (char c : path)
<             {
<                 if (is_path_char[c])
<                 {
<                     result += c;
<                 }
<                 else
<                 {
<                     result += encoded_chars[static_cast<unsigned char>(c)];
<                 }
---
>                 url.append("&");
112,154c28
< 
<             return result;
<         }
< 
<         std::string encode_url_query(const std::string& query)
<         {
<             static const std::vector<uint8_t> is_query_char = []()
<             {
<                 std::vector<uint8_t> ret(256, 0);
<                 for (char c : std::string(unreserved) + std::string(subdelimiters) + "%!@/?")
<                 {
<                     ret[c] = 1;
<                 }
<                 // Literal + needs to be encoded
<                 ret['+'] = 0;
<                 // Surprisingly, '=' also needs to be encoded because Azure Storage server side is so strict.
<                 ret['='] = 0;
<                 return ret;
<             }();
< 
<             std::string result;
<             for (char c : query)
<             {
<                 if (is_query_char[c])
<                 {
<                     result += c;
<                 }
<                 else
<                 {
<                     result += encoded_chars[static_cast<unsigned char>(c)];
<                 }
<             }
< 
<             return result;
<         }
< 
<         std::string storage_url::to_string() const
<         {
<             std::string url(m_domain);
<             url.append(encode_url_path(m_path));
< 
<             bool first_query = true;
<             for (const auto &q : m_query) 
---
>             for (const auto &value : q.second)
156,168c30
<                 if (first_query) 
<                 {
<                     url.append("?");
<                     first_query = false;
<                 }
<                 else 
<                 {
<                     url.append("&");
<                 }
<                 for (const auto &value : q.second) 
<                 {
<                     url.append(encode_url_query(q.first)).append("=").append(encode_url_query(value));
<                 }
---
>                 url.append(encode_url_query(q.first)).append("=").append(encode_url_query(value));
170,247d31
<             return url;
<         }
< 
<         // The URLs this is going to need to parse are fairly unadvanced.
<         // They'll all be similar to http://blah.com/path1/path2?query1=xxx&query2=xxx
<         // It's assumed they will be pre-encoded.
<         // This is _primarily_ to support the custom MSI endpoint scenario requested by AML.
<         std::shared_ptr<storage_url> parse_url(const std::string& url) {
<             auto output = std::make_shared<storage_url>();
< 
<             std::string runningString;
<             std::string qpname; // A secondary buffer for query parameter strings.
<             // 0 = scheme, 1 = hostname, 2 = path, 3 = query
<             // the scheme ends up attached to the hostname due to the way storage_urls work.
<             int segment = 0;
<             for (auto charptr = url.begin(); charptr < url.end(); charptr++) {
<                 switch (segment) {
<                     case 0:
<                         runningString += *charptr;
< 
<                         // ends up something like "https://"
<                         if (*(charptr - 2) == ':' && *(charptr - 1) == '/' && *charptr == '/')
<                         {
<                             // We've reached the end of the scheme.
<                             segment++;
<                         }
<                         break;
<                     case 1:
<                         // Avoid adding the / between the path element and the domain, as storage_url does that for us.
<                         if(*charptr != '/')
<                             runningString += *charptr;
< 
<                         if (*charptr == '/' || charptr == url.end() - 1)
<                         {
<                             // Only append the new char if it's the end of the string.
<                             output->set_domain(std::string(runningString));
<                             // empty the buffer, do not append the new char to the string because storage_url handles it for us, rather than checking itself
<                             runningString.clear();
<                             segment++;
<                         }
<                         break;
<                     case 2:
<                         // Avoid adding the ? to the path.
<                         if(*charptr != '?')
<                             runningString += *charptr;
< 
<                         if (*charptr == '?' || charptr == url.end() - 1)
<                         {
<                             // We don't need to append by segment here, we can just append the entire thing.
<                             output->append_path(std::string(runningString));
<                             // Empty the buffer
<                             runningString.clear();
<                             segment++;
<                         }
<                         break;
<                     case 3:
<                         // Avoid adding any of the separators to the path.
<                         if (*charptr != '=' && *charptr != '&')
<                             runningString += *charptr;
< 
<                         if (*charptr == '=')
<                         {
<                             qpname = std::string(runningString);
<                             runningString.clear();
<                         }
<                         else if (*charptr == '&' || charptr == url.end() - 1)
<                         {
<                             output->add_query(std::string(qpname), std::string(runningString));
<                             qpname.clear();
<                             runningString.clear();
<                         }
<                         break;
<                     default:
<                         throw std::runtime_error("Unexpected segment section");
<                 }
<             }
< 
<             return output;
248a33
>         return url;
250c35,36
< }
---
> 
> }}   // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/tinyxml2.cpp cpplite/src/tinyxml2.cpp
48c48
< 		int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
---
> 		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
55c55
< 		int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
---
> 		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
104c104
< static const char LINE_FEED				= (char)0x0a;			// all line endings are normalized to LF
---
> static const char LINE_FEED				= static_cast<char>(0x0a);			// all line endings are normalized to LF
106c106
< static const char CARRIAGE_RETURN		= (char)0x0d;			// CR gets filtered out
---
> static const char CARRIAGE_RETURN		= static_cast<char>(0x0d);			// CR gets filtered out
200c200
<     char  endChar = *endTag;
---
>     const char  endChar = *endTag;
313c313
<                         char* adjusted = const_cast<char*>( XMLUtil::GetCharacterRef( p, buf, &len ) );
---
>                         const char* adjusted = const_cast<char*>( XMLUtil::GetCharacterRef( p, buf, &len ) );
433c433
<             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
---
>             *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
438c438
<             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
---
>             *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
443c443
<             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
---
>             *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
448c448
<             *output = (char)(input | FIRST_BYTE_MARK[*length]);
---
>             *output = static_cast<char>(input | FIRST_BYTE_MARK[*length]);
585c585
< void XMLUtil::ToStr(int64_t v, char* buffer, int bufferSize)
---
> void XMLUtil::ToStr( int64_t v, char* buffer, int bufferSize )
588c588
< 	TIXML_SNPRINTF(buffer, bufferSize, "%lld", (long long)v);
---
> 	TIXML_SNPRINTF(buffer, bufferSize, "%lld", static_cast<long long>(v));
590a591,595
> void XMLUtil::ToStr( uint64_t v, char* buffer, int bufferSize )
> {
>     // horrible syntax trick to make the compiler happy about %llu
>     TIXML_SNPRINTF(buffer, bufferSize, "%llu", (long long)v);
> }
615,617c620,627
<     if ( StringEqual( str, "true" ) ) {
<         *value = true;
<         return true;
---
>     static const char* TRUE[] = { "true", "True", "TRUE", 0 };
>     static const char* FALSE[] = { "false", "False", "FALSE", 0 };
> 
>     for (int i = 0; TRUE[i]; ++i) {
>         if (StringEqual(str, TRUE[i])) {
>             *value = true;
>             return true;
>         }
619,621c629,633
<     else if ( StringEqual( str, "false" ) ) {
<         *value = false;
<         return true;
---
>     for (int i = 0; FALSE[i]; ++i) {
>         if (StringEqual(str, FALSE[i])) {
>             *value = false;
>             return true;
>         }
649c661
< 		*value = (int64_t)v;
---
> 		*value = static_cast<int64_t>(v);
655a668,677
> bool XMLUtil::ToUnsigned64(const char* str, uint64_t* value) {
>     unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llu
>     if(TIXML_SSCANF(str, "%llu", &v) == 1) {
>         *value = (uint64_t)v;
>         return true;
>     }
>     return false;
> }
> 
> 
1020c1042
<         int initialLineNum = node->_parseLineNum;
---
>        const int initialLineNum = node->_parseLineNum;
1032c1054
<         XMLDeclaration* decl = node->ToDeclaration();
---
>         const XMLDeclaration* const decl = node->ToDeclaration();
1041c1063
<             // declarations have so far been addded.
---
>             // declarations have so far been added.
1376c1398
<     char endTag[2] = { *p, 0 };
---
>     const char endTag[2] = { *p, 0 };
1416a1439,1447
> XMLError XMLAttribute::QueryUnsigned64Value(uint64_t* value) const
> {
>     if(XMLUtil::ToUnsigned64(Value(), value)) {
>         return XML_SUCCESS;
>     }
>     return XML_WRONG_ATTRIBUTE_TYPE;
> }
> 
> 
1472a1504,1509
> void XMLAttribute::SetAttribute(uint64_t v)
> {
>     char buf[BUF_SIZE];
>     XMLUtil::ToStr(v, buf, BUF_SIZE);
>     _value.SetStr(buf);
> }
1558a1596,1602
> uint64_t XMLElement::Unsigned64Attribute(const char* name, uint64_t defaultValue) const
> {
> 	uint64_t i = defaultValue;
> 	QueryUnsigned64Attribute(name, &i);
> 	return i;
> }
> 
1622a1667,1672
> void XMLElement::SetText(uint64_t v) {
>     char buf[BUF_SIZE];
>     XMLUtil::ToStr(v, buf, BUF_SIZE);
>     SetText(buf);
> }
> 
1686a1737,1749
> XMLError XMLElement::QueryUnsigned64Text(uint64_t* ival) const
> {
>     if(FirstChild() && FirstChild()->ToText()) {
>         const char* t = FirstChild()->Value();
>         if(XMLUtil::ToUnsigned64(t, ival)) {
>             return XML_SUCCESS;
>         }
>         return XML_CAN_NOT_CONVERT_TEXT;
>     }
>     return XML_NO_TEXT_NODE;
> }
> 
> 
1745a1809,1815
> uint64_t XMLElement::Unsigned64Text(uint64_t defaultValue) const
> {
> 	uint64_t i = defaultValue;
> 	QueryUnsigned64Text(&i);
> 	return i;
> }
> 
1833c1903
<             int attrLineNum = attrib->_parseLineNum;
---
>             const int attrLineNum = attrib->_parseLineNum;
2139c2209
<     errno_t err = fopen_s( &fp, filepath, mode );
---
>     const errno_t err = fopen_s( &fp, filepath, mode );
2197c2267
<         return value < (size_t)-1;
---
>         return value < static_cast<size_t>(-1);
2242c2312
<     size_t read = fread( _charBuffer, 1, size, fp );
---
>     const size_t read = fread( _charBuffer, 1, size, fp );
2293c2363
<     if ( len == (size_t)(-1) ) {
---
>     if ( len == static_cast<size_t>(-1) ) {
2335c2405
<     size_t BUFFER_SIZE = 1000;
---
>     const size_t BUFFER_SIZE = 1000;
2427c2497
<         const unsigned char flagIndex = (unsigned char)entityValue;
---
>         const unsigned char flagIndex = static_cast<unsigned char>(entityValue);
2431,2433c2501,2503
<     _restrictedEntityFlag[(unsigned char)'&'] = true;
<     _restrictedEntityFlag[(unsigned char)'<'] = true;
<     _restrictedEntityFlag[(unsigned char)'>'] = true;	// not required, but consistency is nice
---
>     _restrictedEntityFlag[static_cast<unsigned char>('&')] = true;
>     _restrictedEntityFlag[static_cast<unsigned char>('<')] = true;
>     _restrictedEntityFlag[static_cast<unsigned char>('>')] = true;	// not required, but consistency is nice
2508c2578
<                 if ( flag[(unsigned char)(*q)] ) {
---
>                 if ( flag[static_cast<unsigned char>(*q)] ) {
2511c2581
<                         const int toPrint = ( INT_MAX < delta ) ? INT_MAX : (int)delta;
---
>                         const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
2539c2609
<             const int toPrint = ( INT_MAX < delta ) ? INT_MAX : (int)delta;
---
>             const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
2616a2687,2694
> void XMLPrinter::PushAttribute(const char* name, uint64_t v)
> {
> 	char buf[BUF_SIZE];
> 	XMLUtil::ToStr(v, buf, BUF_SIZE);
> 	PushAttribute(name, buf);
> }
> 
> 
2685a2764
> 
2691a2771,2779
> 
> 
> void XMLPrinter::PushText( uint64_t value )
> {
> 	char buf[BUF_SIZE];
> 	XMLUtil::ToStr(value, buf, BUF_SIZE);
> 	PushText(buf, false);
> }
> 
diff -r azure-storage-cpp-lite-org/src/tinyxml2_parser.cpp cpplite/src/tinyxml2_parser.cpp
2d1
< #include "utility.h"
4,5c3
< namespace microsoft_azure {
< namespace storage {
---
> #include "utility.h"
7,10c5
< //On parsing xml responses, if a value we expect from the xml is not found
< //throw an invalid_argument exception to indicate we were not given a valid response in the
< //format that we expected. invalid_argument exceptions thrown here will get caught in the
< //executor and will retry again for a valid response.
---
> namespace azure {  namespace storage_lite {
12c7,8
< std::string tinyxml2_parser::parse_text(tinyxml2::XMLElement *ele, const std::string &name) const {
---
> std::string tinyxml2_parser::parse_text(tinyxml2::XMLElement *ele, const std::string &name) const
> {
14,27c10,12
<     if(ele)
<     {
<         ele = ele->FirstChildElement(name.data());
<         if (ele && ele->FirstChild()) {
<             text = ele->FirstChild()->ToText()->Value();
<         }
<         //if we couldn't find the first child, that's okay
<         //xml responses can come back and have empty values in this case
<     }
<     else
<     {
<         //was passed a null pointer to a xml element
<         std::string exception_sstr = "Unable to parse " + name + " from xml element text";
<         throw std::invalid_argument(exception_sstr.c_str()); 
---
>     ele = ele->FirstChildElement(name.data());
>     if (ele && ele->FirstChild()) {
>         text = ele->FirstChild()->ToText()->Value();
33c18,19
< unsigned long long tinyxml2_parser::parse_long(tinyxml2::XMLElement *ele, const std::string &name) const {
---
> unsigned long long tinyxml2_parser::parse_long(tinyxml2::XMLElement *ele, const std::string &name) const
> {
45c31,32
< storage_error tinyxml2_parser::parse_storage_error(const std::string &xml) const {
---
> storage_error tinyxml2_parser::parse_storage_error(const std::string &xml) const
> {
49c36,37
<     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XMLError::XML_SUCCESS) {
---
>     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XMLError::XML_SUCCESS)
>     {
51,59c39,40
<         if(xerror)
<         {
<             error.code_name = parse_text(xerror, "Code");
<             error.message = parse_text(xerror, "Message");
<         }
<         else
<         {
<             throw std::invalid_argument("Unable to parse \"Error\" from storage_error"); 
<         }
---
>         error.code_name = parse_text(xerror, "Code");
>         error.message = parse_text(xerror, "Message");
65c46,47
< list_containers_item tinyxml2_parser::parse_list_containers_item(tinyxml2::XMLElement *ele) const {
---
> list_containers_item tinyxml2_parser::parse_list_containers_item(tinyxml2::XMLElement *ele) const
> {
70,91c52,59
<     if(ele)
<     {
<         auto xproperty = ele->FirstChildElement("Properties");
<         if(xproperty)
<         {
<             item.etag = parse_text(xproperty, "Etag");
<             item.last_modified = parse_text(xproperty, "Last-Modified");
<             item.status = parse_lease_status(parse_text(xproperty, "LeaseStatus"));
<             item.state = parse_lease_state(parse_text(xproperty, "LeaseState"));
<             item.duration = parse_lease_duration(parse_text(xproperty, "LeaseDuration"));
<         }
<         else
<         {
<             throw std::invalid_argument("Unable to parse \"Properties\" from list_containers_item");
<         }
<         
<     }
<     else
<     {
<         throw std::invalid_argument("Unable to parse \"Name\" from list_containers_item");
<     }
<     //parse_metadata
---
>     auto xproperty = ele->FirstChildElement("Properties");
>     item.etag = parse_text(xproperty, "Etag");
>     item.last_modified = parse_text(xproperty, "Last-Modified");
>     item.status = parse_lease_status(parse_text(xproperty, "LeaseStatus"));
>     item.state = parse_lease_state(parse_text(xproperty, "LeaseState"));
>     item.duration = parse_lease_duration(parse_text(xproperty, "LeaseDuration"));
> 
>     //TODO: parse_metadata
96,97c64,66
< /*list_containers_response tinyxml2_parser::parse_list_containers_response(const std::string &xml, std::vector<list_containers_item> &items) const {
<     list_containers_response response;
---
> list_constainers_segmented_response tinyxml2_parser::parse_list_constainers_segmented_response(const std::string &xml) const
> {
>     list_constainers_segmented_response response;
100c69,70
<     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XML_SUCCESS) {
---
>     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XML_SUCCESS)
>     {
103,136c73,77
<         auto xcontainers = xresults->FirstChildElement("Containers");
<         auto xcontainer = xcontainers->FirstChildElement("Container");
<         while (xcontainer) {
<             items.push_back(parse_list_containers_item(xcontainer));
<             xcontainer = xcontainer->NextSiblingElement("Container");
<         }
<     }
< 
<     return response;
< }*/
< 
< list_containers_response tinyxml2_parser::parse_list_containers_response(const std::string &xml) const {
<     list_containers_response response;
< 
<     tinyxml2::XMLDocument xdoc;
<     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XML_SUCCESS) {
<         auto xresults = xdoc.FirstChildElement("EnumerationResults");
<         if(xresults)
<         {
<             response.next_marker = parse_text(xresults, "NextMarker");
<             auto xitems = xresults->FirstChildElement("Containers");
<             if(xitems)
<             {
<                 auto xitem = xitems->FirstChildElement("Container");
<                 while (xitem) {
<                     response.containers.push_back(parse_list_containers_item(xitem));
<                     xitem = xitem->NextSiblingElement("Container");
<                 }
<             }
<             else
<             {
<                 throw std::invalid_argument("Unable to parse \"Containers\" from list_containers_response");
<             }
<             
---
>         auto xitems = xresults->FirstChildElement("Containers");
>         auto xitem = xitems->FirstChildElement("Container");
>         while (xitem) {
>             response.containers.push_back(parse_list_containers_item(xitem));
>             xitem = xitem->NextSiblingElement("Container");
143c84,85
< list_blobs_item tinyxml2_parser::parse_list_blobs_item(tinyxml2::XMLElement *ele) const {
---
> list_blobs_item tinyxml2_parser::parse_list_blobs_item(tinyxml2::XMLElement *ele) const
> {
146,148c88,101
<     if(ele)
<     {
<         item.name = parse_text(ele, "Name");
---
>     item.name = parse_text(ele, "Name");
> 
>     auto xproperty = ele->FirstChildElement("Properties");
>     item.etag = parse_text(xproperty, "Etag");
>     item.last_modified = parse_text(xproperty, "Last-Modified");
>     item.cache_control = parse_text(xproperty, "Cache-Control");
>     item.content_encoding = parse_text(xproperty, "Content-Encoding");
>     item.content_language = parse_text(xproperty, "Content-Language");
>     item.content_type = parse_text(xproperty, "Content-Type");
>     item.content_md5 = parse_text(xproperty, "Content-MD5");
>     item.content_length = parse_long(xproperty, "Content-Length");
>     item.status = parse_lease_status(parse_text(xproperty, "LeaseStatus"));
>     item.state = parse_lease_state(parse_text(xproperty, "LeaseState"));
>     item.duration = parse_lease_duration(parse_text(xproperty, "LeaseDuration"));
150,169d102
<         auto xproperty = ele->FirstChildElement("Properties");
<         if(xproperty)
<         {
<             item.etag = parse_text(xproperty, "Etag");
<             item.last_modified = parse_text(xproperty, "Last-Modified");
<             item.cache_control = parse_text(xproperty, "Cache-Control");
<             item.content_encoding = parse_text(xproperty, "Content-Encoding");
<             item.content_language = parse_text(xproperty, "Content-Language");
<             item.content_type = parse_text(xproperty, "Content-Type");
<             item.content_md5 = parse_text(xproperty, "Content-MD5");
<             item.content_length = parse_long(xproperty, "Content-Length");
<             item.status = parse_lease_status(parse_text(xproperty, "LeaseStatus"));
<             item.state = parse_lease_state(parse_text(xproperty, "LeaseState"));
<             item.duration = parse_lease_duration(parse_text(xproperty, "LeaseDuration"));
<         }
<         else
<         {
<             throw std::invalid_argument("Unable to parse \"Properties\" from list_blobs_item");
<         }
<     }
175c108,109
< list_blobs_response tinyxml2_parser::parse_list_blobs_response(const std::string &xml) const {
---
> list_blobs_response tinyxml2_parser::parse_list_blobs_response(const std::string &xml) const
> {
181,200c115,120
<         if(xresults)
<         {
<             response.next_marker = parse_text(xresults, "NextMarker");
<             auto xitems = xresults->FirstChildElement("Blobs");
<             if(xitems)
<             {
<                 auto xitem = xitems->FirstChildElement("Blob");
<                 while (xitem) {
<                     response.blobs.push_back(parse_list_blobs_item(xitem));
<                     xitem = xitem->NextSiblingElement("Blob");
<                 }
<             }
<             else
<             {
<                 throw std::invalid_argument("Unable to parse \"Blobs\" from list_blobs_response");
<             }
<         }
<         else
<         {
<             throw std::invalid_argument("Unable to parse \"EnumerationResults\" from list_blobs_response");
---
>         response.next_marker = parse_text(xresults, "NextMarker");
>         auto xitems = xresults->FirstChildElement("Blobs");
>         auto xitem = xitems->FirstChildElement("Blob");
>         while (xitem) {
>             response.blobs.push_back(parse_list_blobs_item(xitem));
>             xitem = xitem->NextSiblingElement("Blob");
203,207d122
<     else
<     {
<         throw std::invalid_argument("Unable to parse list_blobs_response");
<     }
<     
212c127,128
< std::vector<std::pair<std::string, std::string>> tinyxml2_parser::parse_blob_metadata(tinyxml2::XMLElement *ele) const {
---
> std::vector<std::pair<std::string, std::string>> tinyxml2_parser::parse_blob_metadata(tinyxml2::XMLElement *ele) const
> {
214c130,131
<     if(ele)
---
>     tinyxml2::XMLElement *current = ele->FirstChildElement();
>     while (current)
216,227c133,136
<         tinyxml2::XMLElement *current = ele->FirstChildElement();
<         while (current)
<         {
<             std::string name(current->Name());
<             std::string value(current->GetText());
<             metadata.push_back(make_pair(name, value));
<             current = current->NextSiblingElement();
<         }
<     }
<     else
<     {
<         throw std::invalid_argument("Unable to parse blob_metadata");
---
>         std::string name(current->Name());
>         std::string value(current->GetText());
>         metadata.push_back(make_pair(name, value));
>         current = current->NextSiblingElement();
232,233c141,143
< list_blobs_hierarchical_item tinyxml2_parser::parse_list_blobs_hierarchical_item(tinyxml2::XMLElement *ele, bool is_directory) const {
<     list_blobs_hierarchical_item item;
---
> list_blobs_segmented_item tinyxml2_parser::parse_list_blobs_segmented_item(tinyxml2::XMLElement *ele, bool is_directory) const
> {
>     list_blobs_segmented_item item;
235c145,147
<     if(ele)
---
>     item.name = parse_text(ele, "Name");
>     item.is_directory = is_directory;
>     if (!is_directory)
237,239c149,162
<         item.name = parse_text(ele, "Name");
<         item.is_directory = is_directory;
<         if (!is_directory)
---
>         auto xproperty = ele->FirstChildElement("Properties");
>         item.etag = parse_text(xproperty, "Etag");
>         item.last_modified = parse_text(xproperty, "Last-Modified");
>         item.cache_control = parse_text(xproperty, "Cache-Control");
>         item.content_encoding = parse_text(xproperty, "Content-Encoding");
>         item.content_language = parse_text(xproperty, "Content-Language");
>         item.content_type = parse_text(xproperty, "Content-Type");
>         item.content_md5 = parse_text(xproperty, "Content-MD5");
>         item.content_length = parse_long(xproperty, "Content-Length");
>         item.status = parse_lease_status(parse_text(xproperty, "LeaseStatus"));
>         item.state = parse_lease_state(parse_text(xproperty, "LeaseState"));
>         item.duration = parse_lease_duration(parse_text(xproperty, "LeaseDuration"));
>         auto xmetadata = ele->FirstChildElement("Metadata");
>         if (xmetadata)
241,268c164
<             auto xproperty = ele->FirstChildElement("Properties");
<             if(xproperty)
<             {
<                 item.etag = parse_text(xproperty, "Etag");
<                 item.last_modified = parse_text(xproperty, "Last-Modified");
<                 item.cache_control = parse_text(xproperty, "Cache-Control");
<                 item.content_encoding = parse_text(xproperty, "Content-Encoding");
<                 item.content_language = parse_text(xproperty, "Content-Language");
<                 item.content_type = parse_text(xproperty, "Content-Type");
<                 item.content_md5 = parse_text(xproperty, "Content-MD5");
<                 item.content_length = parse_long(xproperty, "Content-Length");
<                 item.status = parse_lease_status(parse_text(xproperty, "LeaseStatus"));
<                 item.state = parse_lease_state(parse_text(xproperty, "LeaseState"));
<                 item.duration = parse_lease_duration(parse_text(xproperty, "LeaseDuration"));
<                 auto xmetadata = ele->FirstChildElement("Metadata");
<                 if (xmetadata)
<                 {
<                     item.metadata = parse_blob_metadata(xmetadata);
<                 }
<                 else
<                 {
<                     throw std::invalid_argument("Unable to parse \"Metadata\" from list_blobs_hierarchical_item");
<                 }
<             }
<             else
<             {
<                 throw std::invalid_argument("Unable to parse \"Properties\" from the list_blobs_hierarchical_response");
<             }
---
>             item.metadata = parse_blob_metadata(xmetadata);
276,277c172,174
< list_blobs_hierarchical_response tinyxml2_parser::parse_list_blobs_hierarchical_response(const std::string &xml) const {
<     list_blobs_hierarchical_response response;
---
> list_blobs_segmented_response tinyxml2_parser::parse_list_blobs_segmented_response(const std::string &xml) const
> {
>     list_blobs_segmented_response response;
280c177,178
<     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XML_SUCCESS) {
---
>     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XML_SUCCESS)
>     {
282c180,183
<         if(xresults)
---
>         response.next_marker = parse_text(xresults, "NextMarker");
>         auto xitems = xresults->FirstChildElement("Blobs");
>         auto xitem = xitems->FirstChildElement("Blob");
>         while (xitem)
284,303c185,186
<             response.next_marker = parse_text(xresults, "NextMarker");
<             auto xitems = xresults->FirstChildElement("Blobs");
<             if(xitems)
<             {
<                 auto xitem = xitems->FirstChildElement("Blob");
<                 while (xitem) {
<                     response.blobs.push_back(parse_list_blobs_hierarchical_item(xitem, false));
<                     xitem = xitem->NextSiblingElement("Blob");
<                 }
< 
<                 auto xdir = xitems->FirstChildElement("BlobPrefix");
<                 while (xdir) {
<                     response.blobs.push_back(parse_list_blobs_hierarchical_item(xdir, true));
<                     xdir = xdir->NextSiblingElement("BlobPrefix");
<                 }
<             }
<             else
<             {
<                 throw std::invalid_argument("Unable to parse \"NextMarker\" from list_blobs_hierarchical_response");
<             }
---
>             response.blobs.push_back(parse_list_blobs_segmented_item(xitem, false));
>             xitem = xitem->NextSiblingElement("Blob");
305c188,190
<         else
---
> 
>         auto xdir = xitems->FirstChildElement("BlobPrefix");
>         while (xdir)
307c192,193
<             throw std::invalid_argument("Unable to parse \"EnumerationResults\" from the list_blobs_hierarchical_response");
---
>             response.blobs.push_back(parse_list_blobs_segmented_item(xdir, true));
>             xdir = xdir->NextSiblingElement("BlobPrefix");
310,313c196
<     else
<     {
<         throw std::invalid_argument("Unable to parse list_blobs_hierarchical_response");
<     }
---
> 
318c201,202
< get_block_list_item tinyxml2_parser::parse_get_block_list_item(tinyxml2::XMLElement *ele) const {
---
> get_block_list_item tinyxml2_parser::parse_get_block_list_item(tinyxml2::XMLElement *ele) const
> {
327c211,212
< get_block_list_response tinyxml2_parser::parse_get_block_list_response(const std::string &xml) const {
---
> get_block_list_response tinyxml2_parser::parse_get_block_list_response(const std::string &xml) const
> {
331c216,217
<     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XML_SUCCESS) {
---
>     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XML_SUCCESS)
>     {
333,355c219,223
<         if(xresults)
<         {
<             auto xitems = xresults->FirstChildElement("CommittedBlocks");
<             if(xitems)
<             {
<                 auto xitem = xitems->FirstChildElement("Block");
<                 while (xitem) {
<                     response.committed.push_back(parse_get_block_list_item(xitem));
<                     xitem = xitem->NextSiblingElement("Block");
<                 }
< 
<                 xitems = xresults->FirstChildElement("UncommittedBlocks");
<                 xitem = xitems->FirstChildElement("Block");
<                 while (xitem) {
<                     response.uncommitted.push_back(parse_get_block_list_item(xitem));
<                     xitem = xitem->NextSiblingElement("Block");
<                 }
<             }
<             else
<             {
<                 throw std::invalid_argument("Unable to parse \"CommittedBlocks\" from the block_list_response");
<             }
<             
---
>         auto xitems = xresults->FirstChildElement("CommittedBlocks");
>         auto xitem = xitems->FirstChildElement("Block");
>         while (xitem) {
>             response.committed.push_back(parse_get_block_list_item(xitem));
>             xitem = xitem->NextSiblingElement("Block");
357,359c225,230
<         else
<         {
<             throw std::invalid_argument("Unable to parse \"BlockList\" from the block_list_response");
---
> 
>         xitems = xresults->FirstChildElement("UncommittedBlocks");
>         xitem = xitems->FirstChildElement("Block");
>         while (xitem) {
>             response.uncommitted.push_back(parse_get_block_list_item(xitem));
>             xitem = xitem->NextSiblingElement("Block");
362,366d232
<     else
<     {
<         throw std::invalid_argument("Failed to parse XML block_list_response");
<     }
<     
371c237,238
< get_page_ranges_item tinyxml2_parser::parse_get_page_ranges_item(tinyxml2::XMLElement *ele) const {
---
> get_page_ranges_item tinyxml2_parser::parse_get_page_ranges_item(tinyxml2::XMLElement *ele) const
> {
380c247,248
< get_page_ranges_response tinyxml2_parser::parse_get_page_ranges_response(const std::string &xml) const {
---
> get_page_ranges_response tinyxml2_parser::parse_get_page_ranges_response(const std::string &xml) const
> {
384c252,253
<     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XML_SUCCESS) {
---
>     if (xdoc.Parse(xml.data(), xml.size()) == tinyxml2::XML_SUCCESS)
>     {
386,396c255,258
<         if(xresults)
<         {
<             auto xitem = xresults->FirstChildElement("PageRange");
<             while (xitem) {
<                 response.pagelist.push_back(parse_get_page_ranges_item(xitem));
<                 xitem = xitem->NextSiblingElement("PageRange");
<             }
<         }
<         else
<         {
<             throw std::invalid_argument("Failed to parse \"PageList\" from page_ranges_response");
---
>         auto xitem = xresults->FirstChildElement("PageRange");
>         while (xitem) {
>             response.pagelist.push_back(parse_get_page_ranges_item(xitem));
>             xitem = xitem->NextSiblingElement("PageRange");
398,402d259
<         
<     }
<     else
<     {
<         throw std::invalid_argument("Failed to parse XML page_ranges_response");
408,409c265
< }
< }
---
> }}  // azure::storage_lite
diff -r azure-storage-cpp-lite-org/src/utility.cpp cpplite/src/utility.cpp
8,9c8,9
< #include <windows.h>
< #include <filesystem>
---
> #define WIN32_LEAN_AND_MEAN
> #include <Windows.h>
17,18c17,28
< namespace microsoft_azure {
<     namespace storage {
---
> #include <cctype>
> #include <vector>
> #include <algorithm>
> 
> namespace azure {  namespace storage_lite {
> 
>     std::string to_lowercase(std::string str)
>     {
>         std::transform(str.begin(), str.end(), str.begin(), [](char c) { return char(std::tolower(c)); });
>         return str;
>     }
> 
38a49
> 
42,46c53,55
<         try
<         {
<             std::experimental::filesystem::resize_file(path, static_cast<uintmax_t>(length));
<         }
<         catch (...)
---
>         HANDLE h_file = CreateFile(path.data(), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
> 
>         if (h_file == INVALID_HANDLE_VALUE)
50c59,65
<         return true;
---
> 
>         LARGE_INTEGER distance;
>         distance.QuadPart = length;
>         bool ret = SetFilePointerEx(h_file, distance, nullptr, FILE_BEGIN) && SetEndOfFile(h_file);
> 
>         CloseHandle(h_file);
>         return ret;
64,71c79,88
<         std::string get_ms_date(date_format format) {
<             char buf[30];
<             std::time_t t = std::time(nullptr);
<             std::tm *pm;
< #ifdef WIN32
<             std::tm m;
<             pm = &m;
<             gmtime_s(pm, &t);
---
> 
>     std::string get_ms_date(date_format format)
>     {
>         char buf[30];
>         std::time_t t = std::time(nullptr);
>         std::tm *pm;
> #ifdef _WIN32
>         std::tm m;
>         pm = &m;
>         gmtime_s(pm, &t);
73c90
<             pm = std::gmtime(&t);
---
>         pm = std::gmtime(&t);
75,76c92,105
<             size_t s = std::strftime(buf, 30, (format == date_format::iso_8601 ? constants::date_format_iso_8601 : constants::date_format_rfc_1123), pm);
<             return std::string(buf, s);
---
>         size_t s = std::strftime(buf, 30, (format == date_format::iso_8601 ? constants::date_format_iso_8601 : constants::date_format_rfc_1123), pm);
>         return std::string(buf, s);
>     }
> 
>     std::string get_ms_range(unsigned long long start_byte, unsigned long long end_byte)
>     {
>         std::string result;
>         if (start_byte == 0 && end_byte == 0)
>         {
>             return result;
>         }
>         result.append("bytes=" + std::to_string(start_byte) + "-");
>         if (end_byte != 0) {
>             result.append(std::to_string(end_byte));
77a107,128
>         return result;
>     }
> 
>     std::string get_http_verb(http_base::http_method method)
>     {
>         switch (method)
>         {
>         case http_base::http_method::del:
>             return constants::http_delete;
>         case http_base::http_method::get:
>             return constants::http_get;
>         case http_base::http_method::head:
>             return constants::http_head;
>         case http_base::http_method::post:
>             return constants::http_post;
>         case http_base::http_method::put:
>             return constants::http_put;
>         case http_base::http_method::patch:
>             return constants::http_patch;
>         }
>         return std::string();
>     }
79,81c130,196
<         std::string get_ms_range(unsigned long long start_byte, unsigned long long end_byte) {
<             std::string result;
<             if (start_byte == 0 && end_byte == 0)
---
>     void add_access_condition_headers(http_base &h, storage_headers &headers, const blob_request_base &r)
>     {
>         if (!r.if_modified_since().empty())
>         {
>             h.add_header(constants::header_if_modified_since, r.if_modified_since());
>             headers.if_modified_since = r.if_modified_since();
>         }
>         if (!r.if_match().empty())
>         {
>             h.add_header(constants::header_if_match, r.if_match());
>             headers.if_match = r.if_match();
>         }
>         if (!r.if_none_match().empty())
>         {
>             h.add_header(constants::header_if_none_match, r.if_none_match());
>             headers.if_none_match = r.if_none_match();
>         }
>         if (!r.if_unmodified_since().empty())
>         {
>             h.add_header(constants::header_if_unmodified_since, r.if_unmodified_since());
>             headers.if_unmodified_since = r.if_unmodified_since();
>         }
>     }
> 
>     bool retryable(http_base::http_code status_code)
>     {
>         if (status_code == 408 /*Request Timeout*/)
>         {
>             return true;
>         }
>         if (status_code >= 300 && status_code < 500)
>         {
>             return false;
>         }
>         if (status_code == 501 /*Not Implemented*/ || status_code == 505 /*HTTP Version Not Supported*/)
>         {
>             return false;
>         }
>         return true;
>     }
> 
>     static const char* unreserved = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
>     static const char* subdelimiters = "!$&'()*+,;=";
>     static const char* encoded_chars[] = {
>         "%00", "%01", "%02", "%03", "%04", "%05", "%06", "%07", "%08", "%09", "%0A", "%0B", "%0C", "%0D", "%0E", "%0F",
>         "%10", "%11", "%12", "%13", "%14", "%15", "%16", "%17", "%18", "%19", "%1A", "%1B", "%1C", "%1D", "%1E", "%1F",
>         "%20", "%21", "%22", "%23", "%24", "%25", "%26", "%27", "%28", "%29", "%2A", "%2B", "%2C", "%2D", "%2E", "%2F",
>         "%30", "%31", "%32", "%33", "%34", "%35", "%36", "%37", "%38", "%39", "%3A", "%3B", "%3C", "%3D", "%3E", "%3F",
>         "%40", "%41", "%42", "%43", "%44", "%45", "%46", "%47", "%48", "%49", "%4A", "%4B", "%4C", "%4D", "%4E", "%4F",
>         "%50", "%51", "%52", "%53", "%54", "%55", "%56", "%57", "%58", "%59", "%5A", "%5B", "%5C", "%5D", "%5E", "%5F",
>         "%60", "%61", "%62", "%63", "%64", "%65", "%66", "%67", "%68", "%69", "%6A", "%6B", "%6C", "%6D", "%6E", "%6F",
>         "%70", "%71", "%72", "%73", "%74", "%75", "%76", "%77", "%78", "%79", "%7A", "%7B", "%7C", "%7D", "%7E", "%7F",
>         "%80", "%81", "%82", "%83", "%84", "%85", "%86", "%87", "%88", "%89", "%8A", "%8B", "%8C", "%8D", "%8E", "%8F",
>         "%90", "%91", "%92", "%93", "%94", "%95", "%96", "%97", "%98", "%99", "%9A", "%9B", "%9C", "%9D", "%9E", "%9F",
>         "%A0", "%A1", "%A2", "%A3", "%A4", "%A5", "%A6", "%A7", "%A8", "%A9", "%AA", "%AB", "%AC", "%AD", "%AE", "%AF",
>         "%B0", "%B1", "%B2", "%B3", "%B4", "%B5", "%B6", "%B7", "%B8", "%B9", "%BA", "%BB", "%BC", "%BD", "%BE", "%BF",
>         "%C0", "%C1", "%C2", "%C3", "%C4", "%C5", "%C6", "%C7", "%C8", "%C9", "%CA", "%CB", "%CC", "%CD", "%CE", "%CF",
>         "%D0", "%D1", "%D2", "%D3", "%D4", "%D5", "%D6", "%D7", "%D8", "%D9", "%DA", "%DB", "%DC", "%DD", "%DE", "%DF",
>         "%E0", "%E1", "%E2", "%E3", "%E4", "%E5", "%E6", "%E7", "%E8", "%E9", "%EA", "%EB", "%EC", "%ED", "%EE", "%EF",
>         "%F0", "%F1", "%F2", "%F3", "%F4", "%F5", "%F6", "%F7", "%F8", "%F9", "%FA", "%FB", "%FC", "%FD", "%FE", "%FF"
>     };
>     std::string encode_url_path(const std::string& path)
>     {
>         static const std::vector<uint8_t> is_path_char = []()
>         {
>             std::vector<uint8_t> ret(256, 0);
>             for (char c : std::string(unreserved) + std::string(subdelimiters) + "%!@")
83,87c198
<                 return result;
<             }
<             result.append("bytes=" + std::to_string(start_byte) + "-");
<             if (end_byte != 0) {
<                 result.append(std::to_string(end_byte));
---
>                 ret[c] = 1;
89,90c200,203
<             return result;
<         }
---
>             // Parameter path is already joint with '/'.
>             ret['/'] = 1;
>             return ret;
>         }();
92,123c205,214
<         std::string get_http_verb(http_base::http_method method) {
<             switch (method) {
<             case http_base::http_method::del:
<                 return constants::http_delete;
<             case http_base::http_method::get:
<                 return constants::http_get;
<             case http_base::http_method::head:
<                 return constants::http_head;
<             case http_base::http_method::post:
<                 return constants::http_post;
<             case http_base::http_method::put:
<                 return constants::http_put;
<             }
<             return std::string();
<         }
< 
<         void add_access_condition_headers(http_base &h, storage_headers &headers, const blob_request_base &r) {
<             if (!r.if_modified_since().empty()) {
<                 h.add_header(constants::header_if_modified_since, r.if_modified_since());
<                 headers.if_modified_since = r.if_modified_since();
<             }
<             if (!r.if_match().empty()) {
<                 h.add_header(constants::header_if_match, r.if_match());
<                 headers.if_match = r.if_match();
<             }
<             if (!r.if_none_match().empty()) {
<                 h.add_header(constants::header_if_none_match, r.if_none_match());
<                 headers.if_none_match = r.if_none_match();
<             }
<             if (!r.if_unmodified_since().empty()) {
<                 h.add_header(constants::header_if_unmodified_since, r.if_unmodified_since());
<                 headers.if_unmodified_since = r.if_unmodified_since();
---
>         std::string result;
>         for (char c : path)
>         {
>             if (is_path_char[c])
>             {
>                 result += c;
>             }
>             else
>             {
>                 result += encoded_chars[static_cast<unsigned char>(c)];
127,129c218,228
<         bool retryable(http_base::http_code status_code) {
<             if (status_code == 408 /*Request Timeout*/) {
<                 return true;
---
>         return result;
>     }
> 
>     std::string encode_url_query(const std::string& query)
>     {
>         static const std::vector<uint8_t> is_query_char = []()
>         {
>             std::vector<uint8_t> ret(256, 0);
>             for (char c : std::string(unreserved) + std::string(subdelimiters) + "%!@/?")
>             {
>                 ret[c] = 1;
131,132c230,242
<             if (status_code >= 300 && status_code < 500) {
<                 return false;
---
>             // Literal + needs to be encoded
>             ret['+'] = 0;
>             // Surprisingly, '=' also needs to be encoded because Azure Storage server side is so strict.
>             ret['='] = 0;
>             return ret;
>         }();
> 
>         std::string result;
>         for (char c : query)
>         {
>             if (is_query_char[c])
>             {
>                 result += c;
134,135c244,246
<             if (status_code == 501 /*Not Implemented*/ || status_code == 505 /*HTTP Version Not Supported*/) {
<                 return false;
---
>             else
>             {
>                 result += encoded_chars[static_cast<unsigned char>(c)];
137d247
<             return true;
139a250
>         return result;
141c252,253
< }
---
> 
> }}   // azure::storage_lite
Only in cpplite/: test
